{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\nStimulus 3.1.0\nCopyright Â© 2022 Basecamp, LLC\n */\nclass EventListener {\n  constructor(eventTarget, eventName, eventOptions) {\n    this.eventTarget = eventTarget;\n    this.eventName = eventName;\n    this.eventOptions = eventOptions;\n    this.unorderedBindings = new Set();\n  }\n\n  connect() {\n    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);\n  }\n\n  disconnect() {\n    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);\n  }\n\n  bindingConnected(binding) {\n    this.unorderedBindings.add(binding);\n  }\n\n  bindingDisconnected(binding) {\n    this.unorderedBindings.delete(binding);\n  }\n\n  handleEvent(event) {\n    const extendedEvent = extendEvent(event);\n\n    for (const binding of this.bindings) {\n      if (extendedEvent.immediatePropagationStopped) {\n        break;\n      } else {\n        binding.handleEvent(extendedEvent);\n      }\n    }\n  }\n\n  get bindings() {\n    return Array.from(this.unorderedBindings).sort((left, right) => {\n      const leftIndex = left.index,\n            rightIndex = right.index;\n      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;\n    });\n  }\n\n}\n\nfunction extendEvent(event) {\n  if (\"immediatePropagationStopped\" in event) {\n    return event;\n  } else {\n    const stopImmediatePropagation = event.stopImmediatePropagation;\n    return Object.assign(event, {\n      immediatePropagationStopped: false,\n\n      stopImmediatePropagation() {\n        this.immediatePropagationStopped = true;\n        stopImmediatePropagation.call(this);\n      }\n\n    });\n  }\n}\n\nclass Dispatcher {\n  constructor(application) {\n    this.application = application;\n    this.eventListenerMaps = new Map();\n    this.started = false;\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this.eventListeners.forEach(eventListener => eventListener.connect());\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this.eventListeners.forEach(eventListener => eventListener.disconnect());\n    }\n  }\n\n  get eventListeners() {\n    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);\n  }\n\n  bindingConnected(binding) {\n    this.fetchEventListenerForBinding(binding).bindingConnected(binding);\n  }\n\n  bindingDisconnected(binding) {\n    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);\n  }\n\n  handleError(error, message) {\n    let detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.application.handleError(error, \"Error \".concat(message), detail);\n  }\n\n  fetchEventListenerForBinding(binding) {\n    const eventTarget = binding.eventTarget,\n          eventName = binding.eventName,\n          eventOptions = binding.eventOptions;\n    return this.fetchEventListener(eventTarget, eventName, eventOptions);\n  }\n\n  fetchEventListener(eventTarget, eventName, eventOptions) {\n    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n    const cacheKey = this.cacheKey(eventName, eventOptions);\n    let eventListener = eventListenerMap.get(cacheKey);\n\n    if (!eventListener) {\n      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);\n      eventListenerMap.set(cacheKey, eventListener);\n    }\n\n    return eventListener;\n  }\n\n  createEventListener(eventTarget, eventName, eventOptions) {\n    const eventListener = new EventListener(eventTarget, eventName, eventOptions);\n\n    if (this.started) {\n      eventListener.connect();\n    }\n\n    return eventListener;\n  }\n\n  fetchEventListenerMapForEventTarget(eventTarget) {\n    let eventListenerMap = this.eventListenerMaps.get(eventTarget);\n\n    if (!eventListenerMap) {\n      eventListenerMap = new Map();\n      this.eventListenerMaps.set(eventTarget, eventListenerMap);\n    }\n\n    return eventListenerMap;\n  }\n\n  cacheKey(eventName, eventOptions) {\n    const parts = [eventName];\n    Object.keys(eventOptions).sort().forEach(key => {\n      parts.push(\"\".concat(eventOptions[key] ? \"\" : \"!\").concat(key));\n    });\n    return parts.join(\":\");\n  }\n\n}\n\nconst descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;\n\nfunction parseActionDescriptorString(descriptorString) {\n  const source = descriptorString.trim();\n  const matches = source.match(descriptorPattern) || [];\n  return {\n    eventTarget: parseEventTarget(matches[4]),\n    eventName: matches[2],\n    eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},\n    identifier: matches[5],\n    methodName: matches[7]\n  };\n}\n\nfunction parseEventTarget(eventTargetName) {\n  if (eventTargetName == \"window\") {\n    return window;\n  } else if (eventTargetName == \"document\") {\n    return document;\n  }\n}\n\nfunction parseEventOptions(eventOptions) {\n  return eventOptions.split(\":\").reduce((options, token) => Object.assign(options, {\n    [token.replace(/^!/, \"\")]: !/^!/.test(token)\n  }), {});\n}\n\nfunction stringifyEventTarget(eventTarget) {\n  if (eventTarget == window) {\n    return \"window\";\n  } else if (eventTarget == document) {\n    return \"document\";\n  }\n}\n\nfunction camelize(value) {\n  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());\n}\n\nfunction capitalize(value) {\n  return value.charAt(0).toUpperCase() + value.slice(1);\n}\n\nfunction dasherize(value) {\n  return value.replace(/([A-Z])/g, (_, char) => \"-\".concat(char.toLowerCase()));\n}\n\nfunction tokenize(value) {\n  return value.match(/[^\\s]+/g) || [];\n}\n\nclass Action {\n  constructor(element, index, descriptor) {\n    this.element = element;\n    this.index = index;\n    this.eventTarget = descriptor.eventTarget || element;\n    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\");\n    this.eventOptions = descriptor.eventOptions || {};\n    this.identifier = descriptor.identifier || error(\"missing identifier\");\n    this.methodName = descriptor.methodName || error(\"missing method name\");\n  }\n\n  static forToken(token) {\n    return new this(token.element, token.index, parseActionDescriptorString(token.content));\n  }\n\n  toString() {\n    const eventNameSuffix = this.eventTargetName ? \"@\".concat(this.eventTargetName) : \"\";\n    return \"\".concat(this.eventName).concat(eventNameSuffix, \"->\").concat(this.identifier, \"#\").concat(this.methodName);\n  }\n\n  get params() {\n    const params = {};\n    const pattern = new RegExp(\"^data-\".concat(this.identifier, \"-(.+)-param$\"));\n\n    for (const _ref of Array.from(this.element.attributes)) {\n      const name = _ref.name;\n      const value = _ref.value;\n      const match = name.match(pattern);\n      const key = match && match[1];\n\n      if (key) {\n        params[camelize(key)] = typecast(value);\n      }\n    }\n\n    return params;\n  }\n\n  get eventTargetName() {\n    return stringifyEventTarget(this.eventTarget);\n  }\n\n}\n\nconst defaultEventNames = {\n  \"a\": e => \"click\",\n  \"button\": e => \"click\",\n  \"form\": e => \"submit\",\n  \"details\": e => \"toggle\",\n  \"input\": e => e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\",\n  \"select\": e => \"change\",\n  \"textarea\": e => \"input\"\n};\n\nfunction getDefaultEventNameForElement(element) {\n  const tagName = element.tagName.toLowerCase();\n\n  if (tagName in defaultEventNames) {\n    return defaultEventNames[tagName](element);\n  }\n}\n\nfunction error(message) {\n  throw new Error(message);\n}\n\nfunction typecast(value) {\n  try {\n    return JSON.parse(value);\n  } catch (o_O) {\n    return value;\n  }\n}\n\nclass Binding {\n  constructor(context, action) {\n    this.context = context;\n    this.action = action;\n  }\n\n  get index() {\n    return this.action.index;\n  }\n\n  get eventTarget() {\n    return this.action.eventTarget;\n  }\n\n  get eventOptions() {\n    return this.action.eventOptions;\n  }\n\n  get identifier() {\n    return this.context.identifier;\n  }\n\n  handleEvent(event) {\n    if (this.willBeInvokedByEvent(event) && this.shouldBeInvokedPerSelf(event)) {\n      this.processStopPropagation(event);\n      this.processPreventDefault(event);\n      this.invokeWithEvent(event);\n    }\n  }\n\n  get eventName() {\n    return this.action.eventName;\n  }\n\n  get method() {\n    const method = this.controller[this.methodName];\n\n    if (typeof method == \"function\") {\n      return method;\n    }\n\n    throw new Error(\"Action \\\"\".concat(this.action, \"\\\" references undefined method \\\"\").concat(this.methodName, \"\\\"\"));\n  }\n\n  processStopPropagation(event) {\n    if (this.eventOptions.stop) {\n      event.stopPropagation();\n    }\n  }\n\n  processPreventDefault(event) {\n    if (this.eventOptions.prevent) {\n      event.preventDefault();\n    }\n  }\n\n  invokeWithEvent(event) {\n    const target = event.target,\n          currentTarget = event.currentTarget;\n\n    try {\n      const params = this.action.params;\n      const actionEvent = Object.assign(event, {\n        params\n      });\n      this.method.call(this.controller, actionEvent);\n      this.context.logDebugActivity(this.methodName, {\n        event,\n        target,\n        currentTarget,\n        action: this.methodName\n      });\n    } catch (error) {\n      const identifier = this.identifier,\n            controller = this.controller,\n            element = this.element,\n            index = this.index;\n      const detail = {\n        identifier,\n        controller,\n        element,\n        index,\n        event\n      };\n      this.context.handleError(error, \"invoking action \\\"\".concat(this.action, \"\\\"\"), detail);\n    }\n  }\n\n  shouldBeInvokedPerSelf(event) {\n    if (this.action.eventOptions.self === true) {\n      return this.action.element === event.target;\n    } else {\n      return true;\n    }\n  }\n\n  willBeInvokedByEvent(event) {\n    const eventTarget = event.target;\n\n    if (this.element === eventTarget) {\n      return true;\n    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n      return this.scope.containsElement(eventTarget);\n    } else {\n      return this.scope.containsElement(this.action.element);\n    }\n  }\n\n  get controller() {\n    return this.context.controller;\n  }\n\n  get methodName() {\n    return this.action.methodName;\n  }\n\n  get element() {\n    return this.scope.element;\n  }\n\n  get scope() {\n    return this.context.scope;\n  }\n\n}\n\nclass ElementObserver {\n  constructor(element, delegate) {\n    this.mutationObserverInit = {\n      attributes: true,\n      childList: true,\n      subtree: true\n    };\n    this.element = element;\n    this.started = false;\n    this.delegate = delegate;\n    this.elements = new Set();\n    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this.mutationObserver.observe(this.element, this.mutationObserverInit);\n      this.refresh();\n    }\n  }\n\n  pause(callback) {\n    if (this.started) {\n      this.mutationObserver.disconnect();\n      this.started = false;\n    }\n\n    callback();\n\n    if (!this.started) {\n      this.mutationObserver.observe(this.element, this.mutationObserverInit);\n      this.started = true;\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords();\n      this.mutationObserver.disconnect();\n      this.started = false;\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      const matches = new Set(this.matchElementsInTree());\n\n      for (const element of Array.from(this.elements)) {\n        if (!matches.has(element)) {\n          this.removeElement(element);\n        }\n      }\n\n      for (const element of Array.from(matches)) {\n        this.addElement(element);\n      }\n    }\n  }\n\n  processMutations(mutations) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation);\n      }\n    }\n  }\n\n  processMutation(mutation) {\n    if (mutation.type == \"attributes\") {\n      this.processAttributeChange(mutation.target, mutation.attributeName);\n    } else if (mutation.type == \"childList\") {\n      this.processRemovedNodes(mutation.removedNodes);\n      this.processAddedNodes(mutation.addedNodes);\n    }\n  }\n\n  processAttributeChange(node, attributeName) {\n    const element = node;\n\n    if (this.elements.has(element)) {\n      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n        this.delegate.elementAttributeChanged(element, attributeName);\n      } else {\n        this.removeElement(element);\n      }\n    } else if (this.matchElement(element)) {\n      this.addElement(element);\n    }\n  }\n\n  processRemovedNodes(nodes) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node);\n\n      if (element) {\n        this.processTree(element, this.removeElement);\n      }\n    }\n  }\n\n  processAddedNodes(nodes) {\n    for (const node of Array.from(nodes)) {\n      const element = this.elementFromNode(node);\n\n      if (element && this.elementIsActive(element)) {\n        this.processTree(element, this.addElement);\n      }\n    }\n  }\n\n  matchElement(element) {\n    return this.delegate.matchElement(element);\n  }\n\n  matchElementsInTree() {\n    let tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;\n    return this.delegate.matchElementsInTree(tree);\n  }\n\n  processTree(tree, processor) {\n    for (const element of this.matchElementsInTree(tree)) {\n      processor.call(this, element);\n    }\n  }\n\n  elementFromNode(node) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      return node;\n    }\n  }\n\n  elementIsActive(element) {\n    if (element.isConnected != this.element.isConnected) {\n      return false;\n    } else {\n      return this.element.contains(element);\n    }\n  }\n\n  addElement(element) {\n    if (!this.elements.has(element)) {\n      if (this.elementIsActive(element)) {\n        this.elements.add(element);\n\n        if (this.delegate.elementMatched) {\n          this.delegate.elementMatched(element);\n        }\n      }\n    }\n  }\n\n  removeElement(element) {\n    if (this.elements.has(element)) {\n      this.elements.delete(element);\n\n      if (this.delegate.elementUnmatched) {\n        this.delegate.elementUnmatched(element);\n      }\n    }\n  }\n\n}\n\nclass AttributeObserver {\n  constructor(element, attributeName, delegate) {\n    this.attributeName = attributeName;\n    this.delegate = delegate;\n    this.elementObserver = new ElementObserver(element, this);\n  }\n\n  get element() {\n    return this.elementObserver.element;\n  }\n\n  get selector() {\n    return \"[\".concat(this.attributeName, \"]\");\n  }\n\n  start() {\n    this.elementObserver.start();\n  }\n\n  pause(callback) {\n    this.elementObserver.pause(callback);\n  }\n\n  stop() {\n    this.elementObserver.stop();\n  }\n\n  refresh() {\n    this.elementObserver.refresh();\n  }\n\n  get started() {\n    return this.elementObserver.started;\n  }\n\n  matchElement(element) {\n    return element.hasAttribute(this.attributeName);\n  }\n\n  matchElementsInTree(tree) {\n    const match = this.matchElement(tree) ? [tree] : [];\n    const matches = Array.from(tree.querySelectorAll(this.selector));\n    return match.concat(matches);\n  }\n\n  elementMatched(element) {\n    if (this.delegate.elementMatchedAttribute) {\n      this.delegate.elementMatchedAttribute(element, this.attributeName);\n    }\n  }\n\n  elementUnmatched(element) {\n    if (this.delegate.elementUnmatchedAttribute) {\n      this.delegate.elementUnmatchedAttribute(element, this.attributeName);\n    }\n  }\n\n  elementAttributeChanged(element, attributeName) {\n    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n      this.delegate.elementAttributeValueChanged(element, attributeName);\n    }\n  }\n\n}\n\nclass StringMapObserver {\n  constructor(element, delegate) {\n    this.element = element;\n    this.delegate = delegate;\n    this.started = false;\n    this.stringMap = new Map();\n    this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));\n  }\n\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this.mutationObserver.observe(this.element, {\n        attributes: true,\n        attributeOldValue: true\n      });\n      this.refresh();\n    }\n  }\n\n  stop() {\n    if (this.started) {\n      this.mutationObserver.takeRecords();\n      this.mutationObserver.disconnect();\n      this.started = false;\n    }\n  }\n\n  refresh() {\n    if (this.started) {\n      for (const attributeName of this.knownAttributeNames) {\n        this.refreshAttribute(attributeName, null);\n      }\n    }\n  }\n\n  processMutations(mutations) {\n    if (this.started) {\n      for (const mutation of mutations) {\n        this.processMutation(mutation);\n      }\n    }\n  }\n\n  processMutation(mutation) {\n    const attributeName = mutation.attributeName;\n\n    if (attributeName) {\n      this.refreshAttribute(attributeName, mutation.oldValue);\n    }\n  }\n\n  refreshAttribute(attributeName, oldValue) {\n    const key = this.delegate.getStringMapKeyForAttribute(attributeName);\n\n    if (key != null) {\n      if (!this.stringMap.has(attributeName)) {\n        this.stringMapKeyAdded(key, attributeName);\n      }\n\n      const value = this.element.getAttribute(attributeName);\n\n      if (this.stringMap.get(attributeName) != value) {\n        this.stringMapValueChanged(value, key, oldValue);\n      }\n\n      if (value == null) {\n        const oldValue = this.stringMap.get(attributeName);\n        this.stringMap.delete(attributeName);\n        if (oldValue) this.stringMapKeyRemoved(key, attributeName, oldValue);\n      } else {\n        this.stringMap.set(attributeName, value);\n      }\n    }\n  }\n\n  stringMapKeyAdded(key, attributeName) {\n    if (this.delegate.stringMapKeyAdded) {\n      this.delegate.stringMapKeyAdded(key, attributeName);\n    }\n  }\n\n  stringMapValueChanged(value, key, oldValue) {\n    if (this.delegate.stringMapValueChanged) {\n      this.delegate.stringMapValueChanged(value, key, oldValue);\n    }\n  }\n\n  stringMapKeyRemoved(key, attributeName, oldValue) {\n    if (this.delegate.stringMapKeyRemoved) {\n      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);\n    }\n  }\n\n  get knownAttributeNames() {\n    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));\n  }\n\n  get currentAttributeNames() {\n    return Array.from(this.element.attributes).map(attribute => attribute.name);\n  }\n\n  get recordedAttributeNames() {\n    return Array.from(this.stringMap.keys());\n  }\n\n}\n\nfunction add(map, key, value) {\n  fetch(map, key).add(value);\n}\n\nfunction del(map, key, value) {\n  fetch(map, key).delete(value);\n  prune(map, key);\n}\n\nfunction fetch(map, key) {\n  let values = map.get(key);\n\n  if (!values) {\n    values = new Set();\n    map.set(key, values);\n  }\n\n  return values;\n}\n\nfunction prune(map, key) {\n  const values = map.get(key);\n\n  if (values != null && values.size == 0) {\n    map.delete(key);\n  }\n}\n\nclass Multimap {\n  constructor() {\n    this.valuesByKey = new Map();\n  }\n\n  get keys() {\n    return Array.from(this.valuesByKey.keys());\n  }\n\n  get values() {\n    const sets = Array.from(this.valuesByKey.values());\n    return sets.reduce((values, set) => values.concat(Array.from(set)), []);\n  }\n\n  get size() {\n    const sets = Array.from(this.valuesByKey.values());\n    return sets.reduce((size, set) => size + set.size, 0);\n  }\n\n  add(key, value) {\n    add(this.valuesByKey, key, value);\n  }\n\n  delete(key, value) {\n    del(this.valuesByKey, key, value);\n  }\n\n  has(key, value) {\n    const values = this.valuesByKey.get(key);\n    return values != null && values.has(value);\n  }\n\n  hasKey(key) {\n    return this.valuesByKey.has(key);\n  }\n\n  hasValue(value) {\n    const sets = Array.from(this.valuesByKey.values());\n    return sets.some(set => set.has(value));\n  }\n\n  getValuesForKey(key) {\n    const values = this.valuesByKey.get(key);\n    return values ? Array.from(values) : [];\n  }\n\n  getKeysForValue(value) {\n    return Array.from(this.valuesByKey).filter(_ref2 => {\n      let _ref3 = _slicedToArray(_ref2, 2),\n          key = _ref3[0],\n          values = _ref3[1];\n\n      return values.has(value);\n    }).map(_ref4 => {\n      let _ref5 = _slicedToArray(_ref4, 2),\n          key = _ref5[0],\n          values = _ref5[1];\n\n      return key;\n    });\n  }\n\n}\n\nclass IndexedMultimap extends Multimap {\n  constructor() {\n    super();\n    this.keysByValue = new Map();\n  }\n\n  get values() {\n    return Array.from(this.keysByValue.keys());\n  }\n\n  add(key, value) {\n    super.add(key, value);\n    add(this.keysByValue, value, key);\n  }\n\n  delete(key, value) {\n    super.delete(key, value);\n    del(this.keysByValue, value, key);\n  }\n\n  hasValue(value) {\n    return this.keysByValue.has(value);\n  }\n\n  getKeysForValue(value) {\n    const set = this.keysByValue.get(value);\n    return set ? Array.from(set) : [];\n  }\n\n}\n\nclass TokenListObserver {\n  constructor(element, attributeName, delegate) {\n    this.attributeObserver = new AttributeObserver(element, attributeName, this);\n    this.delegate = delegate;\n    this.tokensByElement = new Multimap();\n  }\n\n  get started() {\n    return this.attributeObserver.started;\n  }\n\n  start() {\n    this.attributeObserver.start();\n  }\n\n  pause(callback) {\n    this.attributeObserver.pause(callback);\n  }\n\n  stop() {\n    this.attributeObserver.stop();\n  }\n\n  refresh() {\n    this.attributeObserver.refresh();\n  }\n\n  get element() {\n    return this.attributeObserver.element;\n  }\n\n  get attributeName() {\n    return this.attributeObserver.attributeName;\n  }\n\n  elementMatchedAttribute(element) {\n    this.tokensMatched(this.readTokensForElement(element));\n  }\n\n  elementAttributeValueChanged(element) {\n    const _this$refreshTokensFo = this.refreshTokensForElement(element),\n          _this$refreshTokensFo2 = _slicedToArray(_this$refreshTokensFo, 2),\n          unmatchedTokens = _this$refreshTokensFo2[0],\n          matchedTokens = _this$refreshTokensFo2[1];\n\n    this.tokensUnmatched(unmatchedTokens);\n    this.tokensMatched(matchedTokens);\n  }\n\n  elementUnmatchedAttribute(element) {\n    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));\n  }\n\n  tokensMatched(tokens) {\n    tokens.forEach(token => this.tokenMatched(token));\n  }\n\n  tokensUnmatched(tokens) {\n    tokens.forEach(token => this.tokenUnmatched(token));\n  }\n\n  tokenMatched(token) {\n    this.delegate.tokenMatched(token);\n    this.tokensByElement.add(token.element, token);\n  }\n\n  tokenUnmatched(token) {\n    this.delegate.tokenUnmatched(token);\n    this.tokensByElement.delete(token.element, token);\n  }\n\n  refreshTokensForElement(element) {\n    const previousTokens = this.tokensByElement.getValuesForKey(element);\n    const currentTokens = this.readTokensForElement(element);\n    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(_ref6 => {\n      let _ref7 = _slicedToArray(_ref6, 2),\n          previousToken = _ref7[0],\n          currentToken = _ref7[1];\n\n      return !tokensAreEqual(previousToken, currentToken);\n    });\n\n    if (firstDifferingIndex == -1) {\n      return [[], []];\n    } else {\n      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];\n    }\n  }\n\n  readTokensForElement(element) {\n    const attributeName = this.attributeName;\n    const tokenString = element.getAttribute(attributeName) || \"\";\n    return parseTokenString(tokenString, element, attributeName);\n  }\n\n}\n\nfunction parseTokenString(tokenString, element, attributeName) {\n  return tokenString.trim().split(/\\s+/).filter(content => content.length).map((content, index) => ({\n    element,\n    attributeName,\n    content,\n    index\n  }));\n}\n\nfunction zip(left, right) {\n  const length = Math.max(left.length, right.length);\n  return Array.from({\n    length\n  }, (_, index) => [left[index], right[index]]);\n}\n\nfunction tokensAreEqual(left, right) {\n  return left && right && left.index == right.index && left.content == right.content;\n}\n\nclass ValueListObserver {\n  constructor(element, attributeName, delegate) {\n    this.tokenListObserver = new TokenListObserver(element, attributeName, this);\n    this.delegate = delegate;\n    this.parseResultsByToken = new WeakMap();\n    this.valuesByTokenByElement = new WeakMap();\n  }\n\n  get started() {\n    return this.tokenListObserver.started;\n  }\n\n  start() {\n    this.tokenListObserver.start();\n  }\n\n  stop() {\n    this.tokenListObserver.stop();\n  }\n\n  refresh() {\n    this.tokenListObserver.refresh();\n  }\n\n  get element() {\n    return this.tokenListObserver.element;\n  }\n\n  get attributeName() {\n    return this.tokenListObserver.attributeName;\n  }\n\n  tokenMatched(token) {\n    const element = token.element;\n\n    const _this$fetchParseResul = this.fetchParseResultForToken(token),\n          value = _this$fetchParseResul.value;\n\n    if (value) {\n      this.fetchValuesByTokenForElement(element).set(token, value);\n      this.delegate.elementMatchedValue(element, value);\n    }\n  }\n\n  tokenUnmatched(token) {\n    const element = token.element;\n\n    const _this$fetchParseResul2 = this.fetchParseResultForToken(token),\n          value = _this$fetchParseResul2.value;\n\n    if (value) {\n      this.fetchValuesByTokenForElement(element).delete(token);\n      this.delegate.elementUnmatchedValue(element, value);\n    }\n  }\n\n  fetchParseResultForToken(token) {\n    let parseResult = this.parseResultsByToken.get(token);\n\n    if (!parseResult) {\n      parseResult = this.parseToken(token);\n      this.parseResultsByToken.set(token, parseResult);\n    }\n\n    return parseResult;\n  }\n\n  fetchValuesByTokenForElement(element) {\n    let valuesByToken = this.valuesByTokenByElement.get(element);\n\n    if (!valuesByToken) {\n      valuesByToken = new Map();\n      this.valuesByTokenByElement.set(element, valuesByToken);\n    }\n\n    return valuesByToken;\n  }\n\n  parseToken(token) {\n    try {\n      const value = this.delegate.parseValueForToken(token);\n      return {\n        value\n      };\n    } catch (error) {\n      return {\n        error\n      };\n    }\n  }\n\n}\n\nclass BindingObserver {\n  constructor(context, delegate) {\n    this.context = context;\n    this.delegate = delegate;\n    this.bindingsByAction = new Map();\n  }\n\n  start() {\n    if (!this.valueListObserver) {\n      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);\n      this.valueListObserver.start();\n    }\n  }\n\n  stop() {\n    if (this.valueListObserver) {\n      this.valueListObserver.stop();\n      delete this.valueListObserver;\n      this.disconnectAllActions();\n    }\n  }\n\n  get element() {\n    return this.context.element;\n  }\n\n  get identifier() {\n    return this.context.identifier;\n  }\n\n  get actionAttribute() {\n    return this.schema.actionAttribute;\n  }\n\n  get schema() {\n    return this.context.schema;\n  }\n\n  get bindings() {\n    return Array.from(this.bindingsByAction.values());\n  }\n\n  connectAction(action) {\n    const binding = new Binding(this.context, action);\n    this.bindingsByAction.set(action, binding);\n    this.delegate.bindingConnected(binding);\n  }\n\n  disconnectAction(action) {\n    const binding = this.bindingsByAction.get(action);\n\n    if (binding) {\n      this.bindingsByAction.delete(action);\n      this.delegate.bindingDisconnected(binding);\n    }\n  }\n\n  disconnectAllActions() {\n    this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding));\n    this.bindingsByAction.clear();\n  }\n\n  parseValueForToken(token) {\n    const action = Action.forToken(token);\n\n    if (action.identifier == this.identifier) {\n      return action;\n    }\n  }\n\n  elementMatchedValue(element, action) {\n    this.connectAction(action);\n  }\n\n  elementUnmatchedValue(element, action) {\n    this.disconnectAction(action);\n  }\n\n}\n\nclass ValueObserver {\n  constructor(context, receiver) {\n    this.context = context;\n    this.receiver = receiver;\n    this.stringMapObserver = new StringMapObserver(this.element, this);\n    this.valueDescriptorMap = this.controller.valueDescriptorMap;\n  }\n\n  start() {\n    this.stringMapObserver.start();\n    this.invokeChangedCallbacksForDefaultValues();\n  }\n\n  stop() {\n    this.stringMapObserver.stop();\n  }\n\n  get element() {\n    return this.context.element;\n  }\n\n  get controller() {\n    return this.context.controller;\n  }\n\n  getStringMapKeyForAttribute(attributeName) {\n    if (attributeName in this.valueDescriptorMap) {\n      return this.valueDescriptorMap[attributeName].name;\n    }\n  }\n\n  stringMapKeyAdded(key, attributeName) {\n    const descriptor = this.valueDescriptorMap[attributeName];\n\n    if (!this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));\n    }\n  }\n\n  stringMapValueChanged(value, name, oldValue) {\n    const descriptor = this.valueDescriptorNameMap[name];\n    if (value === null) return;\n\n    if (oldValue === null) {\n      oldValue = descriptor.writer(descriptor.defaultValue);\n    }\n\n    this.invokeChangedCallback(name, value, oldValue);\n  }\n\n  stringMapKeyRemoved(key, attributeName, oldValue) {\n    const descriptor = this.valueDescriptorNameMap[key];\n\n    if (this.hasValue(key)) {\n      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);\n    } else {\n      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);\n    }\n  }\n\n  invokeChangedCallbacksForDefaultValues() {\n    for (const _ref8 of this.valueDescriptors) {\n      const key = _ref8.key;\n      const name = _ref8.name;\n      const defaultValue = _ref8.defaultValue;\n      const writer = _ref8.writer;\n\n      if (defaultValue != undefined && !this.controller.data.has(key)) {\n        this.invokeChangedCallback(name, writer(defaultValue), undefined);\n      }\n    }\n  }\n\n  invokeChangedCallback(name, rawValue, rawOldValue) {\n    const changedMethodName = \"\".concat(name, \"Changed\");\n    const changedMethod = this.receiver[changedMethodName];\n\n    if (typeof changedMethod == \"function\") {\n      const descriptor = this.valueDescriptorNameMap[name];\n\n      try {\n        const value = descriptor.reader(rawValue);\n        let oldValue = rawOldValue;\n\n        if (rawOldValue) {\n          oldValue = descriptor.reader(rawOldValue);\n        }\n\n        changedMethod.call(this.receiver, value, oldValue);\n      } catch (error) {\n        if (!(error instanceof TypeError)) throw error;\n        throw new TypeError(\"Stimulus Value \\\"\".concat(this.context.identifier, \".\").concat(descriptor.name, \"\\\" - \").concat(error.message));\n      }\n    }\n  }\n\n  get valueDescriptors() {\n    const valueDescriptorMap = this.valueDescriptorMap;\n    return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key]);\n  }\n\n  get valueDescriptorNameMap() {\n    const descriptors = {};\n    Object.keys(this.valueDescriptorMap).forEach(key => {\n      const descriptor = this.valueDescriptorMap[key];\n      descriptors[descriptor.name] = descriptor;\n    });\n    return descriptors;\n  }\n\n  hasValue(attributeName) {\n    const descriptor = this.valueDescriptorNameMap[attributeName];\n    const hasMethodName = \"has\".concat(capitalize(descriptor.name));\n    return this.receiver[hasMethodName];\n  }\n\n}\n\nclass TargetObserver {\n  constructor(context, delegate) {\n    this.context = context;\n    this.delegate = delegate;\n    this.targetsByName = new Multimap();\n  }\n\n  start() {\n    if (!this.tokenListObserver) {\n      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);\n      this.tokenListObserver.start();\n    }\n  }\n\n  stop() {\n    if (this.tokenListObserver) {\n      this.disconnectAllTargets();\n      this.tokenListObserver.stop();\n      delete this.tokenListObserver;\n    }\n  }\n\n  tokenMatched(_ref9) {\n    let element = _ref9.element,\n        name = _ref9.content;\n\n    if (this.scope.containsElement(element)) {\n      this.connectTarget(element, name);\n    }\n  }\n\n  tokenUnmatched(_ref10) {\n    let element = _ref10.element,\n        name = _ref10.content;\n    this.disconnectTarget(element, name);\n  }\n\n  connectTarget(element, name) {\n    var _a;\n\n    if (!this.targetsByName.has(name, element)) {\n      this.targetsByName.add(name, element);\n      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));\n    }\n  }\n\n  disconnectTarget(element, name) {\n    var _a;\n\n    if (this.targetsByName.has(name, element)) {\n      this.targetsByName.delete(name, element);\n      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));\n    }\n  }\n\n  disconnectAllTargets() {\n    for (const name of this.targetsByName.keys) {\n      for (const element of this.targetsByName.getValuesForKey(name)) {\n        this.disconnectTarget(element, name);\n      }\n    }\n  }\n\n  get attributeName() {\n    return \"data-\".concat(this.context.identifier, \"-target\");\n  }\n\n  get element() {\n    return this.context.element;\n  }\n\n  get scope() {\n    return this.context.scope;\n  }\n\n}\n\nclass Context {\n  constructor(module, scope) {\n    var _this = this;\n\n    this.logDebugActivity = function (functionName) {\n      let detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const identifier = _this.identifier,\n            controller = _this.controller,\n            element = _this.element;\n      detail = Object.assign({\n        identifier,\n        controller,\n        element\n      }, detail);\n\n      _this.application.logDebugActivity(_this.identifier, functionName, detail);\n    };\n\n    this.module = module;\n    this.scope = scope;\n    this.controller = new module.controllerConstructor(this);\n    this.bindingObserver = new BindingObserver(this, this.dispatcher);\n    this.valueObserver = new ValueObserver(this, this.controller);\n    this.targetObserver = new TargetObserver(this, this);\n\n    try {\n      this.controller.initialize();\n      this.logDebugActivity(\"initialize\");\n    } catch (error) {\n      this.handleError(error, \"initializing controller\");\n    }\n  }\n\n  connect() {\n    this.bindingObserver.start();\n    this.valueObserver.start();\n    this.targetObserver.start();\n\n    try {\n      this.controller.connect();\n      this.logDebugActivity(\"connect\");\n    } catch (error) {\n      this.handleError(error, \"connecting controller\");\n    }\n  }\n\n  disconnect() {\n    try {\n      this.controller.disconnect();\n      this.logDebugActivity(\"disconnect\");\n    } catch (error) {\n      this.handleError(error, \"disconnecting controller\");\n    }\n\n    this.targetObserver.stop();\n    this.valueObserver.stop();\n    this.bindingObserver.stop();\n  }\n\n  get application() {\n    return this.module.application;\n  }\n\n  get identifier() {\n    return this.module.identifier;\n  }\n\n  get schema() {\n    return this.application.schema;\n  }\n\n  get dispatcher() {\n    return this.application.dispatcher;\n  }\n\n  get element() {\n    return this.scope.element;\n  }\n\n  get parentElement() {\n    return this.element.parentElement;\n  }\n\n  handleError(error, message) {\n    let detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const identifier = this.identifier,\n          controller = this.controller,\n          element = this.element;\n    detail = Object.assign({\n      identifier,\n      controller,\n      element\n    }, detail);\n    this.application.handleError(error, \"Error \".concat(message), detail);\n  }\n\n  targetConnected(element, name) {\n    this.invokeControllerMethod(\"\".concat(name, \"TargetConnected\"), element);\n  }\n\n  targetDisconnected(element, name) {\n    this.invokeControllerMethod(\"\".concat(name, \"TargetDisconnected\"), element);\n  }\n\n  invokeControllerMethod(methodName) {\n    const controller = this.controller;\n\n    if (typeof controller[methodName] == \"function\") {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      controller[methodName](...args);\n    }\n  }\n\n}\n\nfunction readInheritableStaticArrayValues(constructor, propertyName) {\n  const ancestors = getAncestorsForConstructor(constructor);\n  return Array.from(ancestors.reduce((values, constructor) => {\n    getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name));\n    return values;\n  }, new Set()));\n}\n\nfunction readInheritableStaticObjectPairs(constructor, propertyName) {\n  const ancestors = getAncestorsForConstructor(constructor);\n  return ancestors.reduce((pairs, constructor) => {\n    pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));\n    return pairs;\n  }, []);\n}\n\nfunction getAncestorsForConstructor(constructor) {\n  const ancestors = [];\n\n  while (constructor) {\n    ancestors.push(constructor);\n    constructor = Object.getPrototypeOf(constructor);\n  }\n\n  return ancestors.reverse();\n}\n\nfunction getOwnStaticArrayValues(constructor, propertyName) {\n  const definition = constructor[propertyName];\n  return Array.isArray(definition) ? definition : [];\n}\n\nfunction getOwnStaticObjectPairs(constructor, propertyName) {\n  const definition = constructor[propertyName];\n  return definition ? Object.keys(definition).map(key => [key, definition[key]]) : [];\n}\n\nfunction bless(constructor) {\n  return shadow(constructor, getBlessedProperties(constructor));\n}\n\nfunction shadow(constructor, properties) {\n  const shadowConstructor = extend(constructor);\n  const shadowProperties = getShadowProperties(constructor.prototype, properties);\n  Object.defineProperties(shadowConstructor.prototype, shadowProperties);\n  return shadowConstructor;\n}\n\nfunction getBlessedProperties(constructor) {\n  const blessings = readInheritableStaticArrayValues(constructor, \"blessings\");\n  return blessings.reduce((blessedProperties, blessing) => {\n    const properties = blessing(constructor);\n\n    for (const key in properties) {\n      const descriptor = blessedProperties[key] || {};\n      blessedProperties[key] = Object.assign(descriptor, properties[key]);\n    }\n\n    return blessedProperties;\n  }, {});\n}\n\nfunction getShadowProperties(prototype, properties) {\n  return getOwnKeys(properties).reduce((shadowProperties, key) => {\n    const descriptor = getShadowedDescriptor(prototype, properties, key);\n\n    if (descriptor) {\n      Object.assign(shadowProperties, {\n        [key]: descriptor\n      });\n    }\n\n    return shadowProperties;\n  }, {});\n}\n\nfunction getShadowedDescriptor(prototype, properties, key) {\n  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);\n  const shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor;\n\n  if (!shadowedByValue) {\n    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;\n\n    if (shadowingDescriptor) {\n      descriptor.get = shadowingDescriptor.get || descriptor.get;\n      descriptor.set = shadowingDescriptor.set || descriptor.set;\n    }\n\n    return descriptor;\n  }\n}\n\nconst getOwnKeys = (() => {\n  if (typeof Object.getOwnPropertySymbols == \"function\") {\n    return object => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];\n  } else {\n    return Object.getOwnPropertyNames;\n  }\n})();\n\nconst extend = (() => {\n  function extendWithReflect(constructor) {\n    function extended() {\n      return Reflect.construct(constructor, arguments, new.target);\n    }\n\n    extended.prototype = Object.create(constructor.prototype, {\n      constructor: {\n        value: extended\n      }\n    });\n    Reflect.setPrototypeOf(extended, constructor);\n    return extended;\n  }\n\n  function testReflectExtension() {\n    const a = function () {\n      this.a.call(this);\n    };\n\n    const b = extendWithReflect(a);\n\n    b.prototype.a = function () {};\n\n    return new b();\n  }\n\n  try {\n    testReflectExtension();\n    return extendWithReflect;\n  } catch (error) {\n    return constructor => class extended extends constructor {};\n  }\n})();\n\nfunction blessDefinition(definition) {\n  return {\n    identifier: definition.identifier,\n    controllerConstructor: bless(definition.controllerConstructor)\n  };\n}\n\nclass Module {\n  constructor(application, definition) {\n    this.application = application;\n    this.definition = blessDefinition(definition);\n    this.contextsByScope = new WeakMap();\n    this.connectedContexts = new Set();\n  }\n\n  get identifier() {\n    return this.definition.identifier;\n  }\n\n  get controllerConstructor() {\n    return this.definition.controllerConstructor;\n  }\n\n  get contexts() {\n    return Array.from(this.connectedContexts);\n  }\n\n  connectContextForScope(scope) {\n    const context = this.fetchContextForScope(scope);\n    this.connectedContexts.add(context);\n    context.connect();\n  }\n\n  disconnectContextForScope(scope) {\n    const context = this.contextsByScope.get(scope);\n\n    if (context) {\n      this.connectedContexts.delete(context);\n      context.disconnect();\n    }\n  }\n\n  fetchContextForScope(scope) {\n    let context = this.contextsByScope.get(scope);\n\n    if (!context) {\n      context = new Context(this, scope);\n      this.contextsByScope.set(scope, context);\n    }\n\n    return context;\n  }\n\n}\n\nclass ClassMap {\n  constructor(scope) {\n    this.scope = scope;\n  }\n\n  has(name) {\n    return this.data.has(this.getDataKey(name));\n  }\n\n  get(name) {\n    return this.getAll(name)[0];\n  }\n\n  getAll(name) {\n    const tokenString = this.data.get(this.getDataKey(name)) || \"\";\n    return tokenize(tokenString);\n  }\n\n  getAttributeName(name) {\n    return this.data.getAttributeNameForKey(this.getDataKey(name));\n  }\n\n  getDataKey(name) {\n    return \"\".concat(name, \"-class\");\n  }\n\n  get data() {\n    return this.scope.data;\n  }\n\n}\n\nclass DataMap {\n  constructor(scope) {\n    this.scope = scope;\n  }\n\n  get element() {\n    return this.scope.element;\n  }\n\n  get identifier() {\n    return this.scope.identifier;\n  }\n\n  get(key) {\n    const name = this.getAttributeNameForKey(key);\n    return this.element.getAttribute(name);\n  }\n\n  set(key, value) {\n    const name = this.getAttributeNameForKey(key);\n    this.element.setAttribute(name, value);\n    return this.get(key);\n  }\n\n  has(key) {\n    const name = this.getAttributeNameForKey(key);\n    return this.element.hasAttribute(name);\n  }\n\n  delete(key) {\n    if (this.has(key)) {\n      const name = this.getAttributeNameForKey(key);\n      this.element.removeAttribute(name);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  getAttributeNameForKey(key) {\n    return \"data-\".concat(this.identifier, \"-\").concat(dasherize(key));\n  }\n\n}\n\nclass Guide {\n  constructor(logger) {\n    this.warnedKeysByObject = new WeakMap();\n    this.logger = logger;\n  }\n\n  warn(object, key, message) {\n    let warnedKeys = this.warnedKeysByObject.get(object);\n\n    if (!warnedKeys) {\n      warnedKeys = new Set();\n      this.warnedKeysByObject.set(object, warnedKeys);\n    }\n\n    if (!warnedKeys.has(key)) {\n      warnedKeys.add(key);\n      this.logger.warn(message, object);\n    }\n  }\n\n}\n\nfunction attributeValueContainsToken(attributeName, token) {\n  return \"[\".concat(attributeName, \"~=\\\"\").concat(token, \"\\\"]\");\n}\n\nclass TargetSet {\n  constructor(scope) {\n    this.scope = scope;\n  }\n\n  get element() {\n    return this.scope.element;\n  }\n\n  get identifier() {\n    return this.scope.identifier;\n  }\n\n  get schema() {\n    return this.scope.schema;\n  }\n\n  has(targetName) {\n    return this.find(targetName) != null;\n  }\n\n  find() {\n    for (var _len2 = arguments.length, targetNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      targetNames[_key2] = arguments[_key2];\n    }\n\n    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);\n  }\n\n  findAll() {\n    for (var _len3 = arguments.length, targetNames = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      targetNames[_key3] = arguments[_key3];\n    }\n\n    return targetNames.reduce((targets, targetName) => [...targets, ...this.findAllTargets(targetName), ...this.findAllLegacyTargets(targetName)], []);\n  }\n\n  findTarget(targetName) {\n    const selector = this.getSelectorForTargetName(targetName);\n    return this.scope.findElement(selector);\n  }\n\n  findAllTargets(targetName) {\n    const selector = this.getSelectorForTargetName(targetName);\n    return this.scope.findAllElements(selector);\n  }\n\n  getSelectorForTargetName(targetName) {\n    const attributeName = this.schema.targetAttributeForScope(this.identifier);\n    return attributeValueContainsToken(attributeName, targetName);\n  }\n\n  findLegacyTarget(targetName) {\n    const selector = this.getLegacySelectorForTargetName(targetName);\n    return this.deprecate(this.scope.findElement(selector), targetName);\n  }\n\n  findAllLegacyTargets(targetName) {\n    const selector = this.getLegacySelectorForTargetName(targetName);\n    return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName));\n  }\n\n  getLegacySelectorForTargetName(targetName) {\n    const targetDescriptor = \"\".concat(this.identifier, \".\").concat(targetName);\n    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);\n  }\n\n  deprecate(element, targetName) {\n    if (element) {\n      const identifier = this.identifier;\n      const attributeName = this.schema.targetAttribute;\n      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);\n      this.guide.warn(element, \"target:\".concat(targetName), \"Please replace \".concat(attributeName, \"=\\\"\").concat(identifier, \".\").concat(targetName, \"\\\" with \").concat(revisedAttributeName, \"=\\\"\").concat(targetName, \"\\\". \") + \"The \".concat(attributeName, \" attribute is deprecated and will be removed in a future version of Stimulus.\"));\n    }\n\n    return element;\n  }\n\n  get guide() {\n    return this.scope.guide;\n  }\n\n}\n\nclass Scope {\n  constructor(schema, element, identifier, logger) {\n    this.targets = new TargetSet(this);\n    this.classes = new ClassMap(this);\n    this.data = new DataMap(this);\n\n    this.containsElement = element => {\n      return element.closest(this.controllerSelector) === this.element;\n    };\n\n    this.schema = schema;\n    this.element = element;\n    this.identifier = identifier;\n    this.guide = new Guide(logger);\n  }\n\n  findElement(selector) {\n    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);\n  }\n\n  findAllElements(selector) {\n    return [...(this.element.matches(selector) ? [this.element] : []), ...this.queryElements(selector).filter(this.containsElement)];\n  }\n\n  queryElements(selector) {\n    return Array.from(this.element.querySelectorAll(selector));\n  }\n\n  get controllerSelector() {\n    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);\n  }\n\n}\n\nclass ScopeObserver {\n  constructor(element, schema, delegate) {\n    this.element = element;\n    this.schema = schema;\n    this.delegate = delegate;\n    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);\n    this.scopesByIdentifierByElement = new WeakMap();\n    this.scopeReferenceCounts = new WeakMap();\n  }\n\n  start() {\n    this.valueListObserver.start();\n  }\n\n  stop() {\n    this.valueListObserver.stop();\n  }\n\n  get controllerAttribute() {\n    return this.schema.controllerAttribute;\n  }\n\n  parseValueForToken(token) {\n    const element = token.element,\n          identifier = token.content;\n    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);\n    let scope = scopesByIdentifier.get(identifier);\n\n    if (!scope) {\n      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);\n      scopesByIdentifier.set(identifier, scope);\n    }\n\n    return scope;\n  }\n\n  elementMatchedValue(element, value) {\n    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;\n    this.scopeReferenceCounts.set(value, referenceCount);\n\n    if (referenceCount == 1) {\n      this.delegate.scopeConnected(value);\n    }\n  }\n\n  elementUnmatchedValue(element, value) {\n    const referenceCount = this.scopeReferenceCounts.get(value);\n\n    if (referenceCount) {\n      this.scopeReferenceCounts.set(value, referenceCount - 1);\n\n      if (referenceCount == 1) {\n        this.delegate.scopeDisconnected(value);\n      }\n    }\n  }\n\n  fetchScopesByIdentifierForElement(element) {\n    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);\n\n    if (!scopesByIdentifier) {\n      scopesByIdentifier = new Map();\n      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);\n    }\n\n    return scopesByIdentifier;\n  }\n\n}\n\nclass Router {\n  constructor(application) {\n    this.application = application;\n    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);\n    this.scopesByIdentifier = new Multimap();\n    this.modulesByIdentifier = new Map();\n  }\n\n  get element() {\n    return this.application.element;\n  }\n\n  get schema() {\n    return this.application.schema;\n  }\n\n  get logger() {\n    return this.application.logger;\n  }\n\n  get controllerAttribute() {\n    return this.schema.controllerAttribute;\n  }\n\n  get modules() {\n    return Array.from(this.modulesByIdentifier.values());\n  }\n\n  get contexts() {\n    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);\n  }\n\n  start() {\n    this.scopeObserver.start();\n  }\n\n  stop() {\n    this.scopeObserver.stop();\n  }\n\n  loadDefinition(definition) {\n    this.unloadIdentifier(definition.identifier);\n    const module = new Module(this.application, definition);\n    this.connectModule(module);\n  }\n\n  unloadIdentifier(identifier) {\n    const module = this.modulesByIdentifier.get(identifier);\n\n    if (module) {\n      this.disconnectModule(module);\n    }\n  }\n\n  getContextForElementAndIdentifier(element, identifier) {\n    const module = this.modulesByIdentifier.get(identifier);\n\n    if (module) {\n      return module.contexts.find(context => context.element == element);\n    }\n  }\n\n  handleError(error, message, detail) {\n    this.application.handleError(error, message, detail);\n  }\n\n  createScopeForElementAndIdentifier(element, identifier) {\n    return new Scope(this.schema, element, identifier, this.logger);\n  }\n\n  scopeConnected(scope) {\n    this.scopesByIdentifier.add(scope.identifier, scope);\n    const module = this.modulesByIdentifier.get(scope.identifier);\n\n    if (module) {\n      module.connectContextForScope(scope);\n    }\n  }\n\n  scopeDisconnected(scope) {\n    this.scopesByIdentifier.delete(scope.identifier, scope);\n    const module = this.modulesByIdentifier.get(scope.identifier);\n\n    if (module) {\n      module.disconnectContextForScope(scope);\n    }\n  }\n\n  connectModule(module) {\n    this.modulesByIdentifier.set(module.identifier, module);\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n    scopes.forEach(scope => module.connectContextForScope(scope));\n  }\n\n  disconnectModule(module) {\n    this.modulesByIdentifier.delete(module.identifier);\n    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n    scopes.forEach(scope => module.disconnectContextForScope(scope));\n  }\n\n}\n\nconst defaultSchema = {\n  controllerAttribute: \"data-controller\",\n  actionAttribute: \"data-action\",\n  targetAttribute: \"data-target\",\n  targetAttributeForScope: identifier => \"data-\".concat(identifier, \"-target\")\n};\n\nclass Application {\n  constructor() {\n    var _this2 = this;\n\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;\n    let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSchema;\n    this.logger = console;\n    this.debug = false;\n\n    this.logDebugActivity = function (identifier, functionName) {\n      let detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (_this2.debug) {\n        _this2.logFormattedMessage(identifier, functionName, detail);\n      }\n    };\n\n    this.element = element;\n    this.schema = schema;\n    this.dispatcher = new Dispatcher(this);\n    this.router = new Router(this);\n  }\n\n  static start(element, schema) {\n    const application = new Application(element, schema);\n    application.start();\n    return application;\n  }\n\n  async start() {\n    await domReady();\n    this.logDebugActivity(\"application\", \"starting\");\n    this.dispatcher.start();\n    this.router.start();\n    this.logDebugActivity(\"application\", \"start\");\n  }\n\n  stop() {\n    this.logDebugActivity(\"application\", \"stopping\");\n    this.dispatcher.stop();\n    this.router.stop();\n    this.logDebugActivity(\"application\", \"stop\");\n  }\n\n  register(identifier, controllerConstructor) {\n    this.load({\n      identifier,\n      controllerConstructor\n    });\n  }\n\n  load(head) {\n    for (var _len4 = arguments.length, rest = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      rest[_key4 - 1] = arguments[_key4];\n    }\n\n    const definitions = Array.isArray(head) ? head : [head, ...rest];\n    definitions.forEach(definition => {\n      if (definition.controllerConstructor.shouldLoad) {\n        this.router.loadDefinition(definition);\n      }\n    });\n  }\n\n  unload(head) {\n    for (var _len5 = arguments.length, rest = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      rest[_key5 - 1] = arguments[_key5];\n    }\n\n    const identifiers = Array.isArray(head) ? head : [head, ...rest];\n    identifiers.forEach(identifier => this.router.unloadIdentifier(identifier));\n  }\n\n  get controllers() {\n    return this.router.contexts.map(context => context.controller);\n  }\n\n  getControllerForElementAndIdentifier(element, identifier) {\n    const context = this.router.getContextForElementAndIdentifier(element, identifier);\n    return context ? context.controller : null;\n  }\n\n  handleError(error, message, detail) {\n    var _a;\n\n    this.logger.error(\"%s\\n\\n%o\\n\\n%o\", message, error, detail);\n    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, \"\", 0, 0, error);\n  }\n\n  logFormattedMessage(identifier, functionName) {\n    let detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    detail = Object.assign({\n      application: this\n    }, detail);\n    this.logger.groupCollapsed(\"\".concat(identifier, \" #\").concat(functionName));\n    this.logger.log(\"details:\", Object.assign({}, detail));\n    this.logger.groupEnd();\n  }\n\n}\n\nfunction domReady() {\n  return new Promise(resolve => {\n    if (document.readyState == \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", () => resolve());\n    } else {\n      resolve();\n    }\n  });\n}\n\nfunction ClassPropertiesBlessing(constructor) {\n  const classes = readInheritableStaticArrayValues(constructor, \"classes\");\n  return classes.reduce((properties, classDefinition) => {\n    return Object.assign(properties, propertiesForClassDefinition(classDefinition));\n  }, {});\n}\n\nfunction propertiesForClassDefinition(key) {\n  return {\n    [\"\".concat(key, \"Class\")]: {\n      get() {\n        const classes = this.classes;\n\n        if (classes.has(key)) {\n          return classes.get(key);\n        } else {\n          const attribute = classes.getAttributeName(key);\n          throw new Error(\"Missing attribute \\\"\".concat(attribute, \"\\\"\"));\n        }\n      }\n\n    },\n    [\"\".concat(key, \"Classes\")]: {\n      get() {\n        return this.classes.getAll(key);\n      }\n\n    },\n    [\"has\".concat(capitalize(key), \"Class\")]: {\n      get() {\n        return this.classes.has(key);\n      }\n\n    }\n  };\n}\n\nfunction TargetPropertiesBlessing(constructor) {\n  const targets = readInheritableStaticArrayValues(constructor, \"targets\");\n  return targets.reduce((properties, targetDefinition) => {\n    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));\n  }, {});\n}\n\nfunction propertiesForTargetDefinition(name) {\n  return {\n    [\"\".concat(name, \"Target\")]: {\n      get() {\n        const target = this.targets.find(name);\n\n        if (target) {\n          return target;\n        } else {\n          throw new Error(\"Missing target element \\\"\".concat(name, \"\\\" for \\\"\").concat(this.identifier, \"\\\" controller\"));\n        }\n      }\n\n    },\n    [\"\".concat(name, \"Targets\")]: {\n      get() {\n        return this.targets.findAll(name);\n      }\n\n    },\n    [\"has\".concat(capitalize(name), \"Target\")]: {\n      get() {\n        return this.targets.has(name);\n      }\n\n    }\n  };\n}\n\nfunction ValuePropertiesBlessing(constructor) {\n  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, \"values\");\n  const propertyDescriptorMap = {\n    valueDescriptorMap: {\n      get() {\n        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {\n          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);\n          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);\n          return Object.assign(result, {\n            [attributeName]: valueDescriptor\n          });\n        }, {});\n      }\n\n    }\n  };\n  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {\n    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));\n  }, propertyDescriptorMap);\n}\n\nfunction propertiesForValueDefinitionPair(valueDefinitionPair, controller) {\n  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);\n  const key = definition.key,\n        name = definition.name,\n        read = definition.reader,\n        write = definition.writer;\n  return {\n    [name]: {\n      get() {\n        const value = this.data.get(key);\n\n        if (value !== null) {\n          return read(value);\n        } else {\n          return definition.defaultValue;\n        }\n      },\n\n      set(value) {\n        if (value === undefined) {\n          this.data.delete(key);\n        } else {\n          this.data.set(key, write(value));\n        }\n      }\n\n    },\n    [\"has\".concat(capitalize(name))]: {\n      get() {\n        return this.data.has(key) || definition.hasCustomDefaultValue;\n      }\n\n    }\n  };\n}\n\nfunction parseValueDefinitionPair(_ref11, controller) {\n  let _ref12 = _slicedToArray(_ref11, 2),\n      token = _ref12[0],\n      typeDefinition = _ref12[1];\n\n  return valueDescriptorForTokenAndTypeDefinition({\n    controller,\n    token,\n    typeDefinition\n  });\n}\n\nfunction parseValueTypeConstant(constant) {\n  switch (constant) {\n    case Array:\n      return \"array\";\n\n    case Boolean:\n      return \"boolean\";\n\n    case Number:\n      return \"number\";\n\n    case Object:\n      return \"object\";\n\n    case String:\n      return \"string\";\n  }\n}\n\nfunction parseValueTypeDefault(defaultValue) {\n  switch (typeof defaultValue) {\n    case \"boolean\":\n      return \"boolean\";\n\n    case \"number\":\n      return \"number\";\n\n    case \"string\":\n      return \"string\";\n  }\n\n  if (Array.isArray(defaultValue)) return \"array\";\n  if (Object.prototype.toString.call(defaultValue) === \"[object Object]\") return \"object\";\n}\n\nfunction parseValueTypeObject(payload) {\n  const typeFromObject = parseValueTypeConstant(payload.typeObject.type);\n  if (!typeFromObject) return;\n  const defaultValueType = parseValueTypeDefault(payload.typeObject.default);\n\n  if (typeFromObject !== defaultValueType) {\n    const propertyPath = payload.controller ? \"\".concat(payload.controller, \".\").concat(payload.token) : payload.token;\n    throw new Error(\"The specified default value for the Stimulus Value \\\"\".concat(propertyPath, \"\\\" must match the defined type \\\"\").concat(typeFromObject, \"\\\". The provided default value of \\\"\").concat(payload.typeObject.default, \"\\\" is of type \\\"\").concat(defaultValueType, \"\\\".\"));\n  }\n\n  return typeFromObject;\n}\n\nfunction parseValueTypeDefinition(payload) {\n  const typeFromObject = parseValueTypeObject({\n    controller: payload.controller,\n    token: payload.token,\n    typeObject: payload.typeDefinition\n  });\n  const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition);\n  const typeFromConstant = parseValueTypeConstant(payload.typeDefinition);\n  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;\n  if (type) return type;\n  const propertyPath = payload.controller ? \"\".concat(payload.controller, \".\").concat(payload.typeDefinition) : payload.token;\n  throw new Error(\"Unknown value type \\\"\".concat(propertyPath, \"\\\" for \\\"\").concat(payload.token, \"\\\" value\"));\n}\n\nfunction defaultValueForDefinition(typeDefinition) {\n  const constant = parseValueTypeConstant(typeDefinition);\n  if (constant) return defaultValuesByType[constant];\n  const defaultValue = typeDefinition.default;\n  if (defaultValue !== undefined) return defaultValue;\n  return typeDefinition;\n}\n\nfunction valueDescriptorForTokenAndTypeDefinition(payload) {\n  const key = \"\".concat(dasherize(payload.token), \"-value\");\n  const type = parseValueTypeDefinition(payload);\n  return {\n    type,\n    key,\n    name: camelize(key),\n\n    get defaultValue() {\n      return defaultValueForDefinition(payload.typeDefinition);\n    },\n\n    get hasCustomDefaultValue() {\n      return parseValueTypeDefault(payload.typeDefinition) !== undefined;\n    },\n\n    reader: readers[type],\n    writer: writers[type] || writers.default\n  };\n}\n\nconst defaultValuesByType = {\n  get array() {\n    return [];\n  },\n\n  boolean: false,\n  number: 0,\n\n  get object() {\n    return {};\n  },\n\n  string: \"\"\n};\nconst readers = {\n  array(value) {\n    const array = JSON.parse(value);\n\n    if (!Array.isArray(array)) {\n      throw new TypeError(\"expected value of type \\\"array\\\" but instead got value \\\"\".concat(value, \"\\\" of type \\\"\").concat(parseValueTypeDefault(array), \"\\\"\"));\n    }\n\n    return array;\n  },\n\n  boolean(value) {\n    return !(value == \"0\" || String(value).toLowerCase() == \"false\");\n  },\n\n  number(value) {\n    return Number(value);\n  },\n\n  object(value) {\n    const object = JSON.parse(value);\n\n    if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n      throw new TypeError(\"expected value of type \\\"object\\\" but instead got value \\\"\".concat(value, \"\\\" of type \\\"\").concat(parseValueTypeDefault(object), \"\\\"\"));\n    }\n\n    return object;\n  },\n\n  string(value) {\n    return value;\n  }\n\n};\nconst writers = {\n  default: writeString,\n  array: writeJSON,\n  object: writeJSON\n};\n\nfunction writeJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction writeString(value) {\n  return \"\".concat(value);\n}\n\nclass Controller {\n  constructor(context) {\n    this.context = context;\n  }\n\n  static get shouldLoad() {\n    return true;\n  }\n\n  get application() {\n    return this.context.application;\n  }\n\n  get scope() {\n    return this.context.scope;\n  }\n\n  get element() {\n    return this.scope.element;\n  }\n\n  get identifier() {\n    return this.scope.identifier;\n  }\n\n  get targets() {\n    return this.scope.targets;\n  }\n\n  get classes() {\n    return this.scope.classes;\n  }\n\n  get data() {\n    return this.scope.data;\n  }\n\n  initialize() {}\n\n  connect() {}\n\n  disconnect() {}\n\n  dispatch(eventName) {\n    let _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref13$target = _ref13.target,\n        target = _ref13$target === void 0 ? this.element : _ref13$target,\n        _ref13$detail = _ref13.detail,\n        detail = _ref13$detail === void 0 ? {} : _ref13$detail,\n        _ref13$prefix = _ref13.prefix,\n        prefix = _ref13$prefix === void 0 ? this.identifier : _ref13$prefix,\n        _ref13$bubbles = _ref13.bubbles,\n        bubbles = _ref13$bubbles === void 0 ? true : _ref13$bubbles,\n        _ref13$cancelable = _ref13.cancelable,\n        cancelable = _ref13$cancelable === void 0 ? true : _ref13$cancelable;\n\n    const type = prefix ? \"\".concat(prefix, \":\").concat(eventName) : eventName;\n    const event = new CustomEvent(type, {\n      detail,\n      bubbles,\n      cancelable\n    });\n    target.dispatchEvent(event);\n    return event;\n  }\n\n}\n\nController.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];\nController.targets = [];\nController.values = {};\nexport { Application, AttributeObserver, Context, Controller, ElementObserver, IndexedMultimap, Multimap, StringMapObserver, TokenListObserver, ValueListObserver, add, defaultSchema, del, fetch, prune };","map":null,"metadata":{},"sourceType":"module"}