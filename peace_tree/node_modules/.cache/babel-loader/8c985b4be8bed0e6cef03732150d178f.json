{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n(function (e) {\n  if (typeof exports == \"object\" && typeof module == \"object\") module.exports = e();else if (typeof define == \"function\" && define.amd) define(e);else {\n    var f = typeof globalThis < \"u\" ? globalThis : typeof global < \"u\" ? global : typeof self < \"u\" ? self : this || {};\n    f.prettier = e();\n  }\n})(function () {\n  \"use strict\";\n\n  var we = (e, n) => () => (n || e((n = {\n    exports: {}\n  }).exports, n), n.exports);\n\n  var Ye = we((Ig, ru) => {\n    var rr = function (e) {\n      return e && e.Math == Math && e;\n    };\n\n    ru.exports = rr(typeof globalThis == \"object\" && globalThis) || rr(typeof window == \"object\" && window) || rr(typeof self == \"object\" && self) || rr(typeof global == \"object\" && global) || function () {\n      return this;\n    }() || Function(\"return this\")();\n  });\n  var Dt = we((Lg, nu) => {\n    nu.exports = function (e) {\n      try {\n        return !!e();\n      } catch {\n        return !0;\n      }\n    };\n  });\n  var Ct = we((jg, uu) => {\n    var So = Dt();\n    uu.exports = !So(function () {\n      return Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1] != 7;\n    });\n  });\n  var nr = we((Og, su) => {\n    var xo = Dt();\n    su.exports = !xo(function () {\n      var e = function () {}.bind();\n\n      return typeof e != \"function\" || e.hasOwnProperty(\"prototype\");\n    });\n  });\n  var Et = we((qg, iu) => {\n    var bo = nr(),\n        ur = Function.prototype.call;\n    iu.exports = bo ? ur.bind(ur) : function () {\n      return ur.apply(ur, arguments);\n    };\n  });\n  var cu = we(lu => {\n    \"use strict\";\n\n    var au = {}.propertyIsEnumerable,\n        ou = Object.getOwnPropertyDescriptor,\n        To = ou && !au.call({\n      1: 2\n    }, 1);\n    lu.f = To ? function (n) {\n      var t = ou(this, n);\n      return !!t && t.enumerable;\n    } : au;\n  });\n  var sr = we((Rg, pu) => {\n    pu.exports = function (e, n) {\n      return {\n        enumerable: !(e & 1),\n        configurable: !(e & 2),\n        writable: !(e & 4),\n        value: n\n      };\n    };\n  });\n  var at = we((Vg, mu) => {\n    var fu = nr(),\n        Du = Function.prototype,\n        Bo = Du.bind,\n        Or = Du.call,\n        No = fu && Bo.bind(Or, Or);\n    mu.exports = fu ? function (e) {\n      return e && No(e);\n    } : function (e) {\n      return e && function () {\n        return Or.apply(e, arguments);\n      };\n    };\n  });\n  var ir = we((Wg, gu) => {\n    var du = at(),\n        wo = du({}.toString),\n        _o = du(\"\".slice);\n\n    gu.exports = function (e) {\n      return _o(wo(e), 8, -1);\n    };\n  });\n  var hu = we(($g, yu) => {\n    var Po = Ye(),\n        ko = at(),\n        Io = Dt(),\n        Lo = ir(),\n        qr = Po.Object,\n        jo = ko(\"\".split);\n    yu.exports = Io(function () {\n      return !qr(\"z\").propertyIsEnumerable(0);\n    }) ? function (e) {\n      return Lo(e) == \"String\" ? jo(e, \"\") : qr(e);\n    } : qr;\n  });\n  var Mr = we((Hg, vu) => {\n    var Oo = Ye(),\n        qo = Oo.TypeError;\n\n    vu.exports = function (e) {\n      if (e == null) throw qo(\"Can't call method on \" + e);\n      return e;\n    };\n  });\n  var ar = we((Gg, Cu) => {\n    var Mo = hu(),\n        Ro = Mr();\n\n    Cu.exports = function (e) {\n      return Mo(Ro(e));\n    };\n  });\n  var ot = we((Jg, Eu) => {\n    Eu.exports = function (e) {\n      return typeof e == \"function\";\n    };\n  });\n  var Ft = we((Ug, Fu) => {\n    var Vo = ot();\n\n    Fu.exports = function (e) {\n      return typeof e == \"object\" ? e !== null : Vo(e);\n    };\n  });\n  var Rt = we((zg, Au) => {\n    var Rr = Ye(),\n        Wo = ot(),\n        $o = function (e) {\n      return Wo(e) ? e : void 0;\n    };\n\n    Au.exports = function (e, n) {\n      return arguments.length < 2 ? $o(Rr[e]) : Rr[e] && Rr[e][n];\n    };\n  });\n  var Vr = we((Xg, Su) => {\n    var Ho = at();\n    Su.exports = Ho({}.isPrototypeOf);\n  });\n  var bu = we((Kg, xu) => {\n    var Go = Rt();\n    xu.exports = Go(\"navigator\", \"userAgent\") || \"\";\n  });\n  var ku = we((Yg, Pu) => {\n    var _u = Ye(),\n        Wr = bu(),\n        Tu = _u.process,\n        Bu = _u.Deno,\n        Nu = Tu && Tu.versions || Bu && Bu.version,\n        wu = Nu && Nu.v8,\n        ft,\n        or;\n\n    wu && (ft = wu.split(\".\"), or = ft[0] > 0 && ft[0] < 4 ? 1 : +(ft[0] + ft[1]));\n    !or && Wr && (ft = Wr.match(/Edge\\/(\\d+)/), (!ft || ft[1] >= 74) && (ft = Wr.match(/Chrome\\/(\\d+)/), ft && (or = +ft[1])));\n    Pu.exports = or;\n  });\n  var $r = we((Qg, Lu) => {\n    var Iu = ku(),\n        Jo = Dt();\n    Lu.exports = !!Object.getOwnPropertySymbols && !Jo(function () {\n      var e = Symbol();\n      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;\n    });\n  });\n  var Hr = we((Zg, ju) => {\n    var Uo = $r();\n    ju.exports = Uo && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n  });\n  var Gr = we((e0, Ou) => {\n    var zo = Ye(),\n        Xo = Rt(),\n        Ko = ot(),\n        Yo = Vr(),\n        Qo = Hr(),\n        Zo = zo.Object;\n    Ou.exports = Qo ? function (e) {\n      return typeof e == \"symbol\";\n    } : function (e) {\n      var n = Xo(\"Symbol\");\n      return Ko(n) && Yo(n.prototype, Zo(e));\n    };\n  });\n  var lr = we((t0, qu) => {\n    var el = Ye(),\n        tl = el.String;\n\n    qu.exports = function (e) {\n      try {\n        return tl(e);\n      } catch {\n        return \"Object\";\n      }\n    };\n  });\n  var Vt = we((r0, Mu) => {\n    var rl = Ye(),\n        nl = ot(),\n        ul = lr(),\n        sl = rl.TypeError;\n\n    Mu.exports = function (e) {\n      if (nl(e)) return e;\n      throw sl(ul(e) + \" is not a function\");\n    };\n  });\n  var cr = we((n0, Ru) => {\n    var il = Vt();\n\n    Ru.exports = function (e, n) {\n      var t = e[n];\n      return t == null ? void 0 : il(t);\n    };\n  });\n  var Wu = we((u0, Vu) => {\n    var al = Ye(),\n        Jr = Et(),\n        Ur = ot(),\n        zr = Ft(),\n        ol = al.TypeError;\n\n    Vu.exports = function (e, n) {\n      var t, s;\n      if (n === \"string\" && Ur(t = e.toString) && !zr(s = Jr(t, e)) || Ur(t = e.valueOf) && !zr(s = Jr(t, e)) || n !== \"string\" && Ur(t = e.toString) && !zr(s = Jr(t, e))) return s;\n      throw ol(\"Can't convert object to primitive value\");\n    };\n  });\n  var Hu = we((s0, $u) => {\n    $u.exports = !1;\n  });\n  var pr = we((i0, Ju) => {\n    var Gu = Ye(),\n        ll = Object.defineProperty;\n\n    Ju.exports = function (e, n) {\n      try {\n        ll(Gu, e, {\n          value: n,\n          configurable: !0,\n          writable: !0\n        });\n      } catch {\n        Gu[e] = n;\n      }\n\n      return n;\n    };\n  });\n  var fr = we((a0, zu) => {\n    var cl = Ye(),\n        pl = pr(),\n        Uu = \"__core-js_shared__\",\n        fl = cl[Uu] || pl(Uu, {});\n    zu.exports = fl;\n  });\n  var Xr = we((o0, Ku) => {\n    var Dl = Hu(),\n        Xu = fr();\n    (Ku.exports = function (e, n) {\n      return Xu[e] || (Xu[e] = n !== void 0 ? n : {});\n    })(\"versions\", []).push({\n      version: \"3.22.2\",\n      mode: Dl ? \"pure\" : \"global\",\n      copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n      license: \"https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE\",\n      source: \"https://github.com/zloirock/core-js\"\n    });\n  });\n  var Dr = we((l0, Yu) => {\n    var ml = Ye(),\n        dl = Mr(),\n        gl = ml.Object;\n\n    Yu.exports = function (e) {\n      return gl(dl(e));\n    };\n  });\n  var gt = we((c0, Qu) => {\n    var yl = at(),\n        hl = Dr(),\n        vl = yl({}.hasOwnProperty);\n\n    Qu.exports = Object.hasOwn || function (n, t) {\n      return vl(hl(n), t);\n    };\n  });\n  var Kr = we((p0, Zu) => {\n    var Cl = at(),\n        El = 0,\n        Fl = Math.random(),\n        Al = Cl(1 .toString);\n\n    Zu.exports = function (e) {\n      return \"Symbol(\" + (e === void 0 ? \"\" : e) + \")_\" + Al(++El + Fl, 36);\n    };\n  });\n  var St = we((f0, us) => {\n    var Sl = Ye(),\n        xl = Xr(),\n        es = gt(),\n        bl = Kr(),\n        ts = $r(),\n        ns = Hr(),\n        Nt = xl(\"wks\"),\n        At = Sl.Symbol,\n        rs = At && At.for,\n        Tl = ns ? At : At && At.withoutSetter || bl;\n\n    us.exports = function (e) {\n      if (!es(Nt, e) || !(ts || typeof Nt[e] == \"string\")) {\n        var n = \"Symbol.\" + e;\n        ts && es(At, e) ? Nt[e] = At[e] : ns && rs ? Nt[e] = rs(n) : Nt[e] = Tl(n);\n      }\n\n      return Nt[e];\n    };\n  });\n  var os = we((D0, as) => {\n    var Bl = Ye(),\n        Nl = Et(),\n        ss = Ft(),\n        is = Gr(),\n        wl = cr(),\n        _l = Wu(),\n        Pl = St(),\n        kl = Bl.TypeError,\n        Il = Pl(\"toPrimitive\");\n\n    as.exports = function (e, n) {\n      if (!ss(e) || is(e)) return e;\n      var t = wl(e, Il),\n          s;\n\n      if (t) {\n        if (n === void 0 && (n = \"default\"), s = Nl(t, e, n), !ss(s) || is(s)) return s;\n        throw kl(\"Can't convert object to primitive value\");\n      }\n\n      return n === void 0 && (n = \"number\"), _l(e, n);\n    };\n  });\n  var mr = we((m0, ls) => {\n    var Ll = os(),\n        jl = Gr();\n\n    ls.exports = function (e) {\n      var n = Ll(e, \"string\");\n      return jl(n) ? n : n + \"\";\n    };\n  });\n  var fs = we((d0, ps) => {\n    var Ol = Ye(),\n        cs = Ft(),\n        Yr = Ol.document,\n        ql = cs(Yr) && cs(Yr.createElement);\n\n    ps.exports = function (e) {\n      return ql ? Yr.createElement(e) : {};\n    };\n  });\n  var Qr = we((g0, Ds) => {\n    var Ml = Ct(),\n        Rl = Dt(),\n        Vl = fs();\n    Ds.exports = !Ml && !Rl(function () {\n      return Object.defineProperty(Vl(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a != 7;\n    });\n  });\n  var Zr = we(ds => {\n    var Wl = Ct(),\n        $l = Et(),\n        Hl = cu(),\n        Gl = sr(),\n        Jl = ar(),\n        Ul = mr(),\n        zl = gt(),\n        Xl = Qr(),\n        ms = Object.getOwnPropertyDescriptor;\n    ds.f = Wl ? ms : function (n, t) {\n      if (n = Jl(n), t = Ul(t), Xl) try {\n        return ms(n, t);\n      } catch {}\n      if (zl(n, t)) return Gl(!$l(Hl.f, n, t), n[t]);\n    };\n  });\n  var ys = we((h0, gs) => {\n    var Kl = Ct(),\n        Yl = Dt();\n    gs.exports = Kl && Yl(function () {\n      return Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype != 42;\n    });\n  });\n  var wt = we((v0, vs) => {\n    var hs = Ye(),\n        Ql = Ft(),\n        Zl = hs.String,\n        ec = hs.TypeError;\n\n    vs.exports = function (e) {\n      if (Ql(e)) return e;\n      throw ec(Zl(e) + \" is not an object\");\n    };\n  });\n  var gr = we(Es => {\n    var tc = Ye(),\n        rc = Ct(),\n        nc = Qr(),\n        uc = ys(),\n        dr = wt(),\n        Cs = mr(),\n        sc = tc.TypeError,\n        en = Object.defineProperty,\n        ic = Object.getOwnPropertyDescriptor,\n        tn = \"enumerable\",\n        rn = \"configurable\",\n        nn = \"writable\";\n    Es.f = rc ? uc ? function (n, t, s) {\n      if (dr(n), t = Cs(t), dr(s), typeof n == \"function\" && t === \"prototype\" && \"value\" in s && nn in s && !s[nn]) {\n        var a = ic(n, t);\n        a && a[nn] && (n[t] = s.value, s = {\n          configurable: rn in s ? s[rn] : a[rn],\n          enumerable: tn in s ? s[tn] : a[tn],\n          writable: !1\n        });\n      }\n\n      return en(n, t, s);\n    } : en : function (n, t, s) {\n      if (dr(n), t = Cs(t), dr(s), nc) try {\n        return en(n, t, s);\n      } catch {}\n      if (\"get\" in s || \"set\" in s) throw sc(\"Accessors not supported\");\n      return \"value\" in s && (n[t] = s.value), n;\n    };\n  });\n  var yr = we((E0, Fs) => {\n    var ac = Ct(),\n        oc = gr(),\n        lc = sr();\n    Fs.exports = ac ? function (e, n, t) {\n      return oc.f(e, n, lc(1, t));\n    } : function (e, n, t) {\n      return e[n] = t, e;\n    };\n  });\n  var hr = we((F0, As) => {\n    var cc = at(),\n        pc = ot(),\n        un = fr(),\n        fc = cc(Function.toString);\n    pc(un.inspectSource) || (un.inspectSource = function (e) {\n      return fc(e);\n    });\n    As.exports = un.inspectSource;\n  });\n  var bs = we((A0, xs) => {\n    var Dc = Ye(),\n        mc = ot(),\n        dc = hr(),\n        Ss = Dc.WeakMap;\n    xs.exports = mc(Ss) && /native code/.test(dc(Ss));\n  });\n  var Ns = we((S0, Bs) => {\n    var gc = Xr(),\n        yc = Kr(),\n        Ts = gc(\"keys\");\n\n    Bs.exports = function (e) {\n      return Ts[e] || (Ts[e] = yc(e));\n    };\n  });\n  var sn = we((x0, ws) => {\n    ws.exports = {};\n  });\n  var js = we((b0, Ls) => {\n    var hc = bs(),\n        Is = Ye(),\n        an = at(),\n        vc = Ft(),\n        Cc = yr(),\n        on = gt(),\n        ln = fr(),\n        Ec = Ns(),\n        Fc = sn(),\n        _s = \"Object already initialized\",\n        pn = Is.TypeError,\n        Ac = Is.WeakMap,\n        vr,\n        Wt,\n        Cr,\n        Sc = function (e) {\n      return Cr(e) ? Wt(e) : vr(e, {});\n    },\n        xc = function (e) {\n      return function (n) {\n        var t;\n        if (!vc(n) || (t = Wt(n)).type !== e) throw pn(\"Incompatible receiver, \" + e + \" required\");\n        return t;\n      };\n    };\n\n    hc || ln.state ? (yt = ln.state || (ln.state = new Ac()), Ps = an(yt.get), cn = an(yt.has), ks = an(yt.set), vr = function (e, n) {\n      if (cn(yt, e)) throw new pn(_s);\n      return n.facade = e, ks(yt, e, n), n;\n    }, Wt = function (e) {\n      return Ps(yt, e) || {};\n    }, Cr = function (e) {\n      return cn(yt, e);\n    }) : (xt = Ec(\"state\"), Fc[xt] = !0, vr = function (e, n) {\n      if (on(e, xt)) throw new pn(_s);\n      return n.facade = e, Cc(e, xt, n), n;\n    }, Wt = function (e) {\n      return on(e, xt) ? e[xt] : {};\n    }, Cr = function (e) {\n      return on(e, xt);\n    });\n    var yt, Ps, cn, ks, xt;\n    Ls.exports = {\n      set: vr,\n      get: Wt,\n      has: Cr,\n      enforce: Sc,\n      getterFor: xc\n    };\n  });\n  var Ms = we((T0, qs) => {\n    var fn = Ct(),\n        bc = gt(),\n        Os = Function.prototype,\n        Tc = fn && Object.getOwnPropertyDescriptor,\n        Dn = bc(Os, \"name\"),\n        Bc = Dn && function () {}.name === \"something\",\n        Nc = Dn && (!fn || fn && Tc(Os, \"name\").configurable);\n\n    qs.exports = {\n      EXISTS: Dn,\n      PROPER: Bc,\n      CONFIGURABLE: Nc\n    };\n  });\n  var Hs = we((B0, $s) => {\n    var wc = Ye(),\n        Rs = ot(),\n        _c = gt(),\n        Vs = yr(),\n        Pc = pr(),\n        kc = hr(),\n        Ws = js(),\n        Ic = Ms().CONFIGURABLE,\n        Lc = Ws.get,\n        jc = Ws.enforce,\n        Oc = String(String).split(\"String\");\n\n    ($s.exports = function (e, n, t, s) {\n      var a = s ? !!s.unsafe : !1,\n          r = s ? !!s.enumerable : !1,\n          u = s ? !!s.noTargetGet : !1,\n          i = s && s.name !== void 0 ? s.name : n,\n          o;\n\n      if (Rs(t) && (String(i).slice(0, 7) === \"Symbol(\" && (i = \"[\" + String(i).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\"), (!_c(t, \"name\") || Ic && t.name !== i) && Vs(t, \"name\", i), o = jc(t), o.source || (o.source = Oc.join(typeof i == \"string\" ? i : \"\"))), e === wc) {\n        r ? e[n] = t : Pc(n, t);\n        return;\n      } else a ? !u && e[n] && (r = !0) : delete e[n];\n\n      r ? e[n] = t : Vs(e, n, t);\n    })(Function.prototype, \"toString\", function () {\n      return Rs(this) && Lc(this).source || kc(this);\n    });\n  });\n  var Er = we((N0, Gs) => {\n    var qc = Math.ceil,\n        Mc = Math.floor;\n\n    Gs.exports = function (e) {\n      var n = +e;\n      return n !== n || n === 0 ? 0 : (n > 0 ? Mc : qc)(n);\n    };\n  });\n  var Us = we((w0, Js) => {\n    var Rc = Er(),\n        Vc = Math.max,\n        Wc = Math.min;\n\n    Js.exports = function (e, n) {\n      var t = Rc(e);\n      return t < 0 ? Vc(t + n, 0) : Wc(t, n);\n    };\n  });\n  var Xs = we((_0, zs) => {\n    var $c = Er(),\n        Hc = Math.min;\n\n    zs.exports = function (e) {\n      return e > 0 ? Hc($c(e), 9007199254740991) : 0;\n    };\n  });\n\n  var _t = we((P0, Ks) => {\n    var Gc = Xs();\n\n    Ks.exports = function (e) {\n      return Gc(e.length);\n    };\n  });\n\n  var Zs = we((k0, Qs) => {\n    var Jc = ar(),\n        Uc = Us(),\n        zc = _t(),\n        Ys = function (e) {\n      return function (n, t, s) {\n        var a = Jc(n),\n            r = zc(a),\n            u = Uc(s, r),\n            i;\n\n        if (e && t != t) {\n          for (; r > u;) if (i = a[u++], i != i) return !0;\n        } else for (; r > u; u++) if ((e || u in a) && a[u] === t) return e || u || 0;\n\n        return !e && -1;\n      };\n    };\n\n    Qs.exports = {\n      includes: Ys(!0),\n      indexOf: Ys(!1)\n    };\n  });\n  var ri = we((I0, ti) => {\n    var Xc = at(),\n        mn = gt(),\n        Kc = ar(),\n        Yc = Zs().indexOf,\n        Qc = sn(),\n        ei = Xc([].push);\n\n    ti.exports = function (e, n) {\n      var t = Kc(e),\n          s = 0,\n          a = [],\n          r;\n\n      for (r in t) !mn(Qc, r) && mn(t, r) && ei(a, r);\n\n      for (; n.length > s;) mn(t, r = n[s++]) && (~Yc(a, r) || ei(a, r));\n\n      return a;\n    };\n  });\n  var ui = we((L0, ni) => {\n    ni.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n  });\n  var ii = we(si => {\n    var Zc = ri(),\n        ep = ui(),\n        tp = ep.concat(\"length\", \"prototype\");\n\n    si.f = Object.getOwnPropertyNames || function (n) {\n      return Zc(n, tp);\n    };\n  });\n  var oi = we(ai => {\n    ai.f = Object.getOwnPropertySymbols;\n  });\n  var ci = we((q0, li) => {\n    var rp = Rt(),\n        np = at(),\n        up = ii(),\n        sp = oi(),\n        ip = wt(),\n        ap = np([].concat);\n\n    li.exports = rp(\"Reflect\", \"ownKeys\") || function (n) {\n      var t = up.f(ip(n)),\n          s = sp.f;\n      return s ? ap(t, s(n)) : t;\n    };\n  });\n  var Di = we((M0, fi) => {\n    var pi = gt(),\n        op = ci(),\n        lp = Zr(),\n        cp = gr();\n\n    fi.exports = function (e, n, t) {\n      for (var s = op(n), a = cp.f, r = lp.f, u = 0; u < s.length; u++) {\n        var i = s[u];\n        !pi(e, i) && !(t && pi(t, i)) && a(e, i, r(n, i));\n      }\n    };\n  });\n  var di = we((R0, mi) => {\n    var pp = Dt(),\n        fp = ot(),\n        Dp = /#|\\.prototype\\./,\n        $t = function (e, n) {\n      var t = dp[mp(e)];\n      return t == yp ? !0 : t == gp ? !1 : fp(n) ? pp(n) : !!n;\n    },\n        mp = $t.normalize = function (e) {\n      return String(e).replace(Dp, \".\").toLowerCase();\n    },\n        dp = $t.data = {},\n        gp = $t.NATIVE = \"N\",\n        yp = $t.POLYFILL = \"P\";\n\n    mi.exports = $t;\n  });\n  var Ht = we((V0, gi) => {\n    var dn = Ye(),\n        hp = Zr().f,\n        vp = yr(),\n        Cp = Hs(),\n        Ep = pr(),\n        Fp = Di(),\n        Ap = di();\n\n    gi.exports = function (e, n) {\n      var t = e.target,\n          s = e.global,\n          a = e.stat,\n          r,\n          u,\n          i,\n          o,\n          c,\n          v;\n      if (s ? u = dn : a ? u = dn[t] || Ep(t, {}) : u = (dn[t] || {}).prototype, u) for (i in n) {\n        if (c = n[i], e.noTargetGet ? (v = hp(u, i), o = v && v.value) : o = u[i], r = Ap(s ? i : t + (a ? \".\" : \"#\") + i, e.forced), !r && o !== void 0) {\n          if (typeof c == typeof o) continue;\n          Fp(c, o);\n        }\n\n        (e.sham || o && o.sham) && vp(c, \"sham\", !0), Cp(u, i, c, e);\n      }\n    };\n  });\n  var gn = we((W0, yi) => {\n    var Sp = ir();\n\n    yi.exports = Array.isArray || function (n) {\n      return Sp(n) == \"Array\";\n    };\n  });\n  var yn = we(($0, vi) => {\n    var hi = at(),\n        xp = Vt(),\n        bp = nr(),\n        Tp = hi(hi.bind);\n\n    vi.exports = function (e, n) {\n      return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function () {\n        return e.apply(n, arguments);\n      };\n    };\n  });\n  var hn = we((H0, Ei) => {\n    \"use strict\";\n\n    var Bp = Ye(),\n        Np = gn(),\n        wp = _t(),\n        _p = yn(),\n        Pp = Bp.TypeError,\n        Ci = function (e, n, t, s, a, r, u, i) {\n      for (var o = a, c = 0, v = u ? _p(u, i) : !1, m, d; c < s;) {\n        if (c in t) {\n          if (m = v ? v(t[c], c, n) : t[c], r > 0 && Np(m)) d = wp(m), o = Ci(e, n, m, d, o, r - 1) - 1;else {\n            if (o >= 9007199254740991) throw Pp(\"Exceed the acceptable array length\");\n            e[o] = m;\n          }\n          o++;\n        }\n\n        c++;\n      }\n\n      return o;\n    };\n\n    Ei.exports = Ci;\n  });\n  var Si = we((G0, Ai) => {\n    var kp = St(),\n        Ip = kp(\"toStringTag\"),\n        Fi = {};\n    Fi[Ip] = \"z\";\n    Ai.exports = String(Fi) === \"[object z]\";\n  });\n  var vn = we((J0, xi) => {\n    var Lp = Ye(),\n        jp = Si(),\n        Op = ot(),\n        Fr = ir(),\n        qp = St(),\n        Mp = qp(\"toStringTag\"),\n        Rp = Lp.Object,\n        Vp = Fr(function () {\n      return arguments;\n    }()) == \"Arguments\",\n        Wp = function (e, n) {\n      try {\n        return e[n];\n      } catch {}\n    };\n\n    xi.exports = jp ? Fr : function (e) {\n      var n, t, s;\n      return e === void 0 ? \"Undefined\" : e === null ? \"Null\" : typeof (t = Wp(n = Rp(e), Mp)) == \"string\" ? t : Vp ? Fr(n) : (s = Fr(n)) == \"Object\" && Op(n.callee) ? \"Arguments\" : s;\n    };\n  });\n\n  var _i = we((U0, wi) => {\n    var $p = at(),\n        Hp = Dt(),\n        bi = ot(),\n        Gp = vn(),\n        Jp = Rt(),\n        Up = hr(),\n        Ti = function () {},\n        zp = [],\n        Bi = Jp(\"Reflect\", \"construct\"),\n        Cn = /^\\s*(?:class|function)\\b/,\n        Xp = $p(Cn.exec),\n        Kp = !Cn.exec(Ti),\n        Gt = function (n) {\n      if (!bi(n)) return !1;\n\n      try {\n        return Bi(Ti, zp, n), !0;\n      } catch {\n        return !1;\n      }\n    },\n        Ni = function (n) {\n      if (!bi(n)) return !1;\n\n      switch (Gp(n)) {\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n          return !1;\n      }\n\n      try {\n        return Kp || !!Xp(Cn, Up(n));\n      } catch {\n        return !0;\n      }\n    };\n\n    Ni.sham = !0;\n    wi.exports = !Bi || Hp(function () {\n      var e;\n      return Gt(Gt.call) || !Gt(Object) || !Gt(function () {\n        e = !0;\n      }) || e;\n    }) ? Ni : Gt;\n  });\n\n  var Li = we((z0, Ii) => {\n    var Yp = Ye(),\n        Pi = gn(),\n        Qp = _i(),\n        Zp = Ft(),\n        ef = St(),\n        tf = ef(\"species\"),\n        ki = Yp.Array;\n\n    Ii.exports = function (e) {\n      var n;\n      return Pi(e) && (n = e.constructor, Qp(n) && (n === ki || Pi(n.prototype)) ? n = void 0 : Zp(n) && (n = n[tf], n === null && (n = void 0))), n === void 0 ? ki : n;\n    };\n  });\n  var En = we((X0, ji) => {\n    var rf = Li();\n\n    ji.exports = function (e, n) {\n      return new (rf(e))(n === 0 ? 0 : n);\n    };\n  });\n  var Oi = we(() => {\n    \"use strict\";\n\n    var nf = Ht(),\n        uf = hn(),\n        sf = Vt(),\n        af = Dr(),\n        of = _t(),\n        lf = En();\n\n    nf({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flatMap: function (n) {\n        var t = af(this),\n            s = of(t),\n            a;\n        return sf(n), a = lf(t, 0), a.length = uf(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;\n      }\n    });\n  });\n  var Fn = we((Q0, qi) => {\n    qi.exports = {};\n  });\n  var Ri = we((Z0, Mi) => {\n    var cf = St(),\n        pf = Fn(),\n        ff = cf(\"iterator\"),\n        Df = Array.prototype;\n\n    Mi.exports = function (e) {\n      return e !== void 0 && (pf.Array === e || Df[ff] === e);\n    };\n  });\n  var An = we((ey, Wi) => {\n    var mf = vn(),\n        Vi = cr(),\n        df = Fn(),\n        gf = St(),\n        yf = gf(\"iterator\");\n\n    Wi.exports = function (e) {\n      if (e != null) return Vi(e, yf) || Vi(e, \"@@iterator\") || df[mf(e)];\n    };\n  });\n  var Hi = we((ty, $i) => {\n    var hf = Ye(),\n        vf = Et(),\n        Cf = Vt(),\n        Ef = wt(),\n        Ff = lr(),\n        Af = An(),\n        Sf = hf.TypeError;\n\n    $i.exports = function (e, n) {\n      var t = arguments.length < 2 ? Af(e) : n;\n      if (Cf(t)) return Ef(vf(t, e));\n      throw Sf(Ff(e) + \" is not iterable\");\n    };\n  });\n  var Ui = we((ry, Ji) => {\n    var xf = Et(),\n        Gi = wt(),\n        bf = cr();\n\n    Ji.exports = function (e, n, t) {\n      var s, a;\n      Gi(e);\n\n      try {\n        if (s = bf(e, \"return\"), !s) {\n          if (n === \"throw\") throw t;\n          return t;\n        }\n\n        s = xf(s, e);\n      } catch (r) {\n        a = !0, s = r;\n      }\n\n      if (n === \"throw\") throw t;\n      if (a) throw s;\n      return Gi(s), t;\n    };\n  });\n  var Qi = we((ny, Yi) => {\n    var Tf = Ye(),\n        Bf = yn(),\n        Nf = Et(),\n        wf = wt(),\n        _f = lr(),\n        Pf = Ri(),\n        kf = _t(),\n        zi = Vr(),\n        If = Hi(),\n        Lf = An(),\n        Xi = Ui(),\n        jf = Tf.TypeError,\n        Ar = function (e, n) {\n      this.stopped = e, this.result = n;\n    },\n        Ki = Ar.prototype;\n\n    Yi.exports = function (e, n, t) {\n      var s = t && t.that,\n          a = !!(t && t.AS_ENTRIES),\n          r = !!(t && t.IS_ITERATOR),\n          u = !!(t && t.INTERRUPTED),\n          i = Bf(n, s),\n          o,\n          c,\n          v,\n          m,\n          d,\n          p,\n          f,\n          h = function (T) {\n        return o && Xi(o, \"normal\", T), new Ar(!0, T);\n      },\n          w = function (T) {\n        return a ? (wf(T), u ? i(T[0], T[1], h) : i(T[0], T[1])) : u ? i(T, h) : i(T);\n      };\n\n      if (r) o = e;else {\n        if (c = Lf(e), !c) throw jf(_f(e) + \" is not iterable\");\n\n        if (Pf(c)) {\n          for (v = 0, m = kf(e); m > v; v++) if (d = w(e[v]), d && zi(Ki, d)) return d;\n\n          return new Ar(!1);\n        }\n\n        o = If(e, c);\n      }\n\n      for (p = o.next; !(f = Nf(p, o)).done;) {\n        try {\n          d = w(f.value);\n        } catch (T) {\n          Xi(o, \"throw\", T);\n        }\n\n        if (typeof d == \"object\" && d && zi(Ki, d)) return d;\n      }\n\n      return new Ar(!1);\n    };\n  });\n  var ea = we((uy, Zi) => {\n    \"use strict\";\n\n    var Of = mr(),\n        qf = gr(),\n        Mf = sr();\n\n    Zi.exports = function (e, n, t) {\n      var s = Of(n);\n      s in e ? qf.f(e, s, Mf(0, t)) : e[s] = t;\n    };\n  });\n  var ta = we(() => {\n    var Rf = Ht(),\n        Vf = Qi(),\n        Wf = ea();\n    Rf({\n      target: \"Object\",\n      stat: !0\n    }, {\n      fromEntries: function (n) {\n        var t = {};\n        return Vf(n, function (s, a) {\n          Wf(t, s, a);\n        }, {\n          AS_ENTRIES: !0\n        }), t;\n      }\n    });\n  });\n  var ra = we(() => {\n    var $f = Ht(),\n        Hf = Ye();\n    $f({\n      global: !0\n    }, {\n      globalThis: Hf\n    });\n  });\n  var na = we(() => {\n    ra();\n  });\n  var ua = we(() => {\n    \"use strict\";\n\n    var Gf = Ht(),\n        Jf = hn(),\n        Uf = Dr(),\n        zf = _t(),\n        Xf = Er(),\n        Kf = En();\n\n    Gf({\n      target: \"Array\",\n      proto: !0\n    }, {\n      flat: function () {\n        var n = arguments.length ? arguments[0] : void 0,\n            t = Uf(this),\n            s = zf(t),\n            a = Kf(t, 0);\n        return a.length = Jf(a, t, t, s, 0, n === void 0 ? 1 : Xf(n)), a;\n      }\n    });\n  });\n  var Pg = we((my, Co) => {\n    var Yf = [\"cliName\", \"cliCategory\", \"cliDescription\"],\n        Qf = [\"_\"],\n        Zf = [\"languageId\"],\n        sa,\n        ia,\n        aa,\n        oa,\n        la,\n        ca;\n\n    function kn(e, n) {\n      if (e == null) return {};\n      var t = eD(e, n),\n          s,\n          a;\n\n      if (Object.getOwnPropertySymbols) {\n        var r = Object.getOwnPropertySymbols(e);\n\n        for (a = 0; a < r.length; a++) s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));\n      }\n\n      return t;\n    }\n\n    function eD(e, n) {\n      if (e == null) return {};\n      var t = {},\n          s = Object.keys(e),\n          a,\n          r;\n\n      for (r = 0; r < s.length; r++) a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);\n\n      return t;\n    }\n\n    Oi();\n    ta();\n    na();\n    ua();\n\n    function Pt(e, n) {\n      return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, {\n        raw: {\n          value: Object.freeze(n)\n        }\n      }));\n    }\n\n    var tD = Object.create,\n        Br = Object.defineProperty,\n        rD = Object.getOwnPropertyDescriptor,\n        In = Object.getOwnPropertyNames,\n        nD = Object.getPrototypeOf,\n        uD = Object.prototype.hasOwnProperty,\n        mt = (e, n) => function () {\n      return e && (n = (0, e[In(e)[0]])(e = 0)), n;\n    },\n        Z = (e, n) => function () {\n      return n || (0, e[In(e)[0]])((n = {\n        exports: {}\n      }).exports, n), n.exports;\n    },\n        Ut = (e, n) => {\n      for (var t in n) Br(e, t, {\n        get: n[t],\n        enumerable: !0\n      });\n    },\n        ga = (e, n, t, s) => {\n      if (n && typeof n == \"object\" || typeof n == \"function\") for (let a of In(n)) !uD.call(e, a) && a !== t && Br(e, a, {\n        get: () => n[a],\n        enumerable: !(s = rD(n, a)) || s.enumerable\n      });\n      return e;\n    },\n        sD = (e, n, t) => (t = e != null ? tD(nD(e)) : {}, ga(n || !e || !e.__esModule ? Br(t, \"default\", {\n      value: e,\n      enumerable: !0\n    }) : t, e)),\n        lt = e => ga(Br({}, \"__esModule\", {\n      value: !0\n    }), e),\n        pa,\n        fa,\n        Tt,\n        re = mt({\n      \"<define:process>\"() {\n        pa = {}, fa = [], Tt = {\n          env: pa,\n          argv: fa\n        };\n      }\n\n    }),\n        ya = Z({\n      \"package.json\"(e, n) {\n        n.exports = {\n          version: \"2.7.1\"\n        };\n      }\n\n    }),\n        iD = Z({\n      \"node_modules/diff/lib/diff/base.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.default = n;\n\n        function n() {}\n\n        n.prototype = {\n          diff: function (r, u) {\n            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n                o = i.callback;\n            typeof i == \"function\" && (o = i, i = {}), this.options = i;\n            var c = this;\n\n            function v(S) {\n              return o ? (setTimeout(function () {\n                o(void 0, S);\n              }, 0), !0) : S;\n            }\n\n            r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));\n            var m = u.length,\n                d = r.length,\n                p = 1,\n                f = m + d,\n                h = [{\n              newPos: -1,\n              components: []\n            }],\n                w = this.extractCommon(h[0], u, r, 0);\n            if (h[0].newPos + 1 >= m && w + 1 >= d) return v([{\n              value: this.join(u),\n              count: u.length\n            }]);\n\n            function T() {\n              for (var S = -1 * p; S <= p; S += 2) {\n                var B = void 0,\n                    I = h[S - 1],\n                    k = h[S + 1],\n                    P = (k ? k.newPos : 0) - S;\n                I && (h[S - 1] = void 0);\n                var C = I && I.newPos + 1 < m,\n                    D = k && 0 <= P && P < d;\n\n                if (!C && !D) {\n                  h[S] = void 0;\n                  continue;\n                }\n\n                if (!C || D && I.newPos < k.newPos ? (B = s(k), c.pushComponent(B.components, void 0, !0)) : (B = I, B.newPos++, c.pushComponent(B.components, !0, void 0)), P = c.extractCommon(B, u, r, S), B.newPos + 1 >= m && P + 1 >= d) return v(t(c, B.components, u, r, c.useLongestToken));\n                h[S] = B;\n              }\n\n              p++;\n            }\n\n            if (o) (function S() {\n              setTimeout(function () {\n                if (p > f) return o();\n                T() || S();\n              }, 0);\n            })();else for (; p <= f;) {\n              var A = T();\n              if (A) return A;\n            }\n          },\n          pushComponent: function (r, u, i) {\n            var o = r[r.length - 1];\n            o && o.added === u && o.removed === i ? r[r.length - 1] = {\n              count: o.count + 1,\n              added: u,\n              removed: i\n            } : r.push({\n              count: 1,\n              added: u,\n              removed: i\n            });\n          },\n          extractCommon: function (r, u, i, o) {\n            for (var c = u.length, v = i.length, m = r.newPos, d = m - o, p = 0; m + 1 < c && d + 1 < v && this.equals(u[m + 1], i[d + 1]);) m++, d++, p++;\n\n            return p && r.components.push({\n              count: p\n            }), r.newPos = m, d;\n          },\n          equals: function (r, u) {\n            return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();\n          },\n          removeEmpty: function (r) {\n            for (var u = [], i = 0; i < r.length; i++) r[i] && u.push(r[i]);\n\n            return u;\n          },\n          castInput: function (r) {\n            return r;\n          },\n          tokenize: function (r) {\n            return r.split(\"\");\n          },\n          join: function (r) {\n            return r.join(\"\");\n          }\n        };\n\n        function t(a, r, u, i, o) {\n          for (var c = 0, v = r.length, m = 0, d = 0; c < v; c++) {\n            var p = r[c];\n\n            if (p.removed) {\n              if (p.value = a.join(i.slice(d, d + p.count)), d += p.count, c && r[c - 1].added) {\n                var h = r[c - 1];\n                r[c - 1] = r[c], r[c] = h;\n              }\n            } else {\n              if (!p.added && o) {\n                var f = u.slice(m, m + p.count);\n                f = f.map(function (T, A) {\n                  var S = i[d + A];\n                  return S.length > T.length ? S : T;\n                }), p.value = a.join(f);\n              } else p.value = a.join(u.slice(m, m + p.count));\n\n              m += p.count, p.added || (d += p.count);\n            }\n          }\n\n          var w = r[v - 1];\n          return v > 1 && typeof w.value == \"string\" && (w.added || w.removed) && a.equals(\"\", w.value) && (r[v - 2].value += w.value, r.pop()), r;\n        }\n\n        function s(a) {\n          return {\n            newPos: a.newPos,\n            components: a.components.slice(0)\n          };\n        }\n      }\n\n    }),\n        aD = Z({\n      \"node_modules/diff/lib/diff/array.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.diffArrays = a, e.arrayDiff = void 0;\n        var n = t(iD());\n\n        function t(r) {\n          return r && r.__esModule ? r : {\n            default: r\n          };\n        }\n\n        var s = new n.default();\n        e.arrayDiff = s, s.tokenize = function (r) {\n          return r.slice();\n        }, s.join = s.removeEmpty = function (r) {\n          return r;\n        };\n\n        function a(r, u, i) {\n          return s.diff(r, u, i);\n        }\n      }\n\n    }),\n        Ln = Z({\n      \"src/document/doc-builders.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(F) {\n          return {\n            type: \"concat\",\n            parts: F\n          };\n        }\n\n        function s(F) {\n          return {\n            type: \"indent\",\n            contents: F\n          };\n        }\n\n        function a(F, l) {\n          return {\n            type: \"align\",\n            contents: l,\n            n: F\n          };\n        }\n\n        function r(F) {\n          let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n          return {\n            type: \"group\",\n            id: l.id,\n            contents: F,\n            break: Boolean(l.shouldBreak),\n            expandedStates: l.expandedStates\n          };\n        }\n\n        function u(F) {\n          return a(Number.NEGATIVE_INFINITY, F);\n        }\n\n        function i(F) {\n          return a({\n            type: \"root\"\n          }, F);\n        }\n\n        function o(F) {\n          return a(-1, F);\n        }\n\n        function c(F, l) {\n          return r(F[0], Object.assign(Object.assign({}, l), {}, {\n            expandedStates: F\n          }));\n        }\n\n        function v(F) {\n          return {\n            type: \"fill\",\n            parts: F\n          };\n        }\n\n        function m(F, l) {\n          let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n          return {\n            type: \"if-break\",\n            breakContents: F,\n            flatContents: l,\n            groupId: E.groupId\n          };\n        }\n\n        function d(F, l) {\n          return {\n            type: \"indent-if-break\",\n            contents: F,\n            groupId: l.groupId,\n            negate: l.negate\n          };\n        }\n\n        function p(F) {\n          return {\n            type: \"line-suffix\",\n            contents: F\n          };\n        }\n\n        var f = {\n          type: \"line-suffix-boundary\"\n        },\n            h = {\n          type: \"break-parent\"\n        },\n            w = {\n          type: \"trim\"\n        },\n            T = {\n          type: \"line\",\n          hard: !0\n        },\n            A = {\n          type: \"line\",\n          hard: !0,\n          literal: !0\n        },\n            S = {\n          type: \"line\"\n        },\n            B = {\n          type: \"line\",\n          soft: !0\n        },\n            I = t([T, h]),\n            k = t([A, h]),\n            P = {\n          type: \"cursor\",\n          placeholder: Symbol(\"cursor\")\n        };\n\n        function C(F, l) {\n          let E = [];\n\n          for (let y = 0; y < l.length; y++) y !== 0 && E.push(F), E.push(l[y]);\n\n          return t(E);\n        }\n\n        function D(F, l, E) {\n          let y = F;\n\n          if (l > 0) {\n            for (let N = 0; N < Math.floor(l / E); ++N) y = s(y);\n\n            y = a(l % E, y), y = a(Number.NEGATIVE_INFINITY, y);\n          }\n\n          return y;\n        }\n\n        function g(F, l) {\n          return {\n            type: \"label\",\n            label: F,\n            contents: l\n          };\n        }\n\n        n.exports = {\n          concat: t,\n          join: C,\n          line: S,\n          softline: B,\n          hardline: I,\n          literalline: k,\n          group: r,\n          conditionalGroup: c,\n          fill: v,\n          lineSuffix: p,\n          lineSuffixBoundary: f,\n          cursor: P,\n          breakParent: h,\n          ifBreak: m,\n          trim: w,\n          indent: s,\n          indentIfBreak: d,\n          align: a,\n          addAlignmentToDoc: D,\n          markAsRoot: i,\n          dedentToRoot: u,\n          dedent: o,\n          hardlineWithoutBreakParent: T,\n          literallineWithoutBreakParent: A,\n          label: g\n        };\n      }\n\n    }),\n        jn = Z({\n      \"src/common/end-of-line.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(u) {\n          let i = u.indexOf(\"\\r\");\n          return i >= 0 ? u.charAt(i + 1) === \"\\n\" ? \"crlf\" : \"cr\" : \"lf\";\n        }\n\n        function s(u) {\n          switch (u) {\n            case \"cr\":\n              return \"\\r\";\n\n            case \"crlf\":\n              return \"\\r\\n\";\n\n            default:\n              return \"\\n\";\n          }\n        }\n\n        function a(u, i) {\n          let o;\n\n          switch (i) {\n            case \"\\n\":\n              o = /\\n/g;\n              break;\n\n            case \"\\r\":\n              o = /\\r/g;\n              break;\n\n            case \"\\r\\n\":\n              o = /\\r\\n/g;\n              break;\n\n            default:\n              throw new Error('Unexpected \"eol\" '.concat(JSON.stringify(i), \".\"));\n          }\n\n          let c = u.match(o);\n          return c ? c.length : 0;\n        }\n\n        function r(u) {\n          return u.replace(/\\r\\n?/g, \"\\n\");\n        }\n\n        n.exports = {\n          guessEndOfLine: t,\n          convertEndOfLineToChars: s,\n          countEndOfLineChars: a,\n          normalizeEndOfLine: r\n        };\n      }\n\n    }),\n        it = Z({\n      \"src/utils/get-last.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = s => s[s.length - 1];\n\n        n.exports = t;\n      }\n\n    });\n\n    function oD() {\n      let _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n          _ref$onlyFirst = _ref.onlyFirst,\n          e = _ref$onlyFirst === void 0 ? !1 : _ref$onlyFirst,\n          n = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n\n      return new RegExp(n, e ? void 0 : \"g\");\n    }\n\n    var lD = mt({\n      \"node_modules/strip-ansi/node_modules/ansi-regex/index.js\"() {\n        re();\n      }\n\n    });\n\n    function cD(e) {\n      if (typeof e != \"string\") throw new TypeError(\"Expected a `string`, got `\".concat(typeof e, \"`\"));\n      return e.replace(oD(), \"\");\n    }\n\n    var pD = mt({\n      \"node_modules/strip-ansi/index.js\"() {\n        re(), lD();\n      }\n\n    });\n\n    function fD(e) {\n      return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : !1;\n    }\n\n    var DD = mt({\n      \"node_modules/is-fullwidth-code-point/index.js\"() {\n        re();\n      }\n\n    }),\n        mD = Z({\n      \"node_modules/emoji-regex/index.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = function () {\n          return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n        };\n      }\n\n    }),\n        ha = {};\n    Ut(ha, {\n      default: () => dD\n    });\n\n    function dD(e) {\n      if (typeof e != \"string\" || e.length === 0 || (e = cD(e), e.length === 0)) return 0;\n      e = e.replace((0, va.default)(), \"  \");\n      let n = 0;\n\n      for (let t = 0; t < e.length; t++) {\n        let s = e.codePointAt(t);\n        s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += fD(s) ? 2 : 1);\n      }\n\n      return n;\n    }\n\n    var va,\n        gD = mt({\n      \"node_modules/string-width/index.js\"() {\n        re(), pD(), DD(), va = sD(mD());\n      }\n\n    }),\n        Ca = Z({\n      \"src/utils/get-string-width.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = (gD(), lt(ha)).default,\n            s = /[^\\x20-\\x7F]/;\n\n        function a(r) {\n          return r ? s.test(r) ? t(r) : r.length : 0;\n        }\n\n        n.exports = a;\n      }\n\n    }),\n        On = Z({\n      \"src/document/doc-utils.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = it(),\n            _Ln = Ln(),\n            s = _Ln.literalline,\n            a = _Ln.join,\n            r = l => Array.isArray(l) || l && l.type === \"concat\",\n            u = l => {\n          if (Array.isArray(l)) return l;\n          if (l.type !== \"concat\" && l.type !== \"fill\") throw new Error(\"Expect doc type to be `concat` or `fill`.\");\n          return l.parts;\n        },\n            i = {};\n\n        function o(l, E, y, N) {\n          let x = [l];\n\n          for (; x.length > 0;) {\n            let b = x.pop();\n\n            if (b === i) {\n              y(x.pop());\n              continue;\n            }\n\n            if (y && x.push(b, i), !E || E(b) !== !1) if (r(b) || b.type === \"fill\") {\n              let L = u(b);\n\n              for (let M = L.length, j = M - 1; j >= 0; --j) x.push(L[j]);\n            } else if (b.type === \"if-break\") b.flatContents && x.push(b.flatContents), b.breakContents && x.push(b.breakContents);else if (b.type === \"group\" && b.expandedStates) {\n              if (N) for (let L = b.expandedStates.length, M = L - 1; M >= 0; --M) x.push(b.expandedStates[M]);else x.push(b.contents);\n            } else b.contents && x.push(b.contents);\n          }\n        }\n\n        function c(l, E) {\n          let y = new Map();\n          return N(l);\n\n          function N(b) {\n            if (y.has(b)) return y.get(b);\n            let L = x(b);\n            return y.set(b, L), L;\n          }\n\n          function x(b) {\n            if (Array.isArray(b)) return E(b.map(N));\n\n            if (b.type === \"concat\" || b.type === \"fill\") {\n              let L = b.parts.map(N);\n              return E(Object.assign(Object.assign({}, b), {}, {\n                parts: L\n              }));\n            }\n\n            if (b.type === \"if-break\") {\n              let L = b.breakContents && N(b.breakContents),\n                  M = b.flatContents && N(b.flatContents);\n              return E(Object.assign(Object.assign({}, b), {}, {\n                breakContents: L,\n                flatContents: M\n              }));\n            }\n\n            if (b.type === \"group\" && b.expandedStates) {\n              let L = b.expandedStates.map(N),\n                  M = L[0];\n              return E(Object.assign(Object.assign({}, b), {}, {\n                contents: M,\n                expandedStates: L\n              }));\n            }\n\n            if (b.contents) {\n              let L = N(b.contents);\n              return E(Object.assign(Object.assign({}, b), {}, {\n                contents: L\n              }));\n            }\n\n            return E(b);\n          }\n        }\n\n        function v(l, E, y) {\n          let N = y,\n              x = !1;\n\n          function b(L) {\n            let M = E(L);\n            if (M !== void 0 && (x = !0, N = M), x) return !1;\n          }\n\n          return o(l, b), N;\n        }\n\n        function m(l) {\n          if (l.type === \"group\" && l.break || l.type === \"line\" && l.hard || l.type === \"break-parent\") return !0;\n        }\n\n        function d(l) {\n          return v(l, m, !1);\n        }\n\n        function p(l) {\n          if (l.length > 0) {\n            let E = t(l);\n            !E.expandedStates && !E.break && (E.break = \"propagated\");\n          }\n\n          return null;\n        }\n\n        function f(l) {\n          let E = new Set(),\n              y = [];\n\n          function N(b) {\n            if (b.type === \"break-parent\" && p(y), b.type === \"group\") {\n              if (y.push(b), E.has(b)) return !1;\n              E.add(b);\n            }\n          }\n\n          function x(b) {\n            b.type === \"group\" && y.pop().break && p(y);\n          }\n\n          o(l, N, x, !0);\n        }\n\n        function h(l) {\n          return l.type === \"line\" && !l.hard ? l.soft ? \"\" : \" \" : l.type === \"if-break\" ? l.flatContents || \"\" : l;\n        }\n\n        function w(l) {\n          return c(l, h);\n        }\n\n        var T = (l, E) => l && l.type === \"line\" && l.hard && E && E.type === \"break-parent\";\n\n        function A(l) {\n          if (!l) return l;\n\n          if (r(l) || l.type === \"fill\") {\n            let E = u(l);\n\n            for (; E.length > 1 && T(...E.slice(-2));) E.length -= 2;\n\n            if (E.length > 0) {\n              let y = A(t(E));\n              E[E.length - 1] = y;\n            }\n\n            return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {\n              parts: E\n            });\n          }\n\n          switch (l.type) {\n            case \"align\":\n            case \"indent\":\n            case \"indent-if-break\":\n            case \"group\":\n            case \"line-suffix\":\n            case \"label\":\n              {\n                let E = A(l.contents);\n                return Object.assign(Object.assign({}, l), {}, {\n                  contents: E\n                });\n              }\n\n            case \"if-break\":\n              {\n                let E = A(l.breakContents),\n                    y = A(l.flatContents);\n                return Object.assign(Object.assign({}, l), {}, {\n                  breakContents: E,\n                  flatContents: y\n                });\n              }\n          }\n\n          return l;\n        }\n\n        function S(l) {\n          return A(I(l));\n        }\n\n        function B(l) {\n          switch (l.type) {\n            case \"fill\":\n              if (l.parts.every(y => y === \"\")) return \"\";\n              break;\n\n            case \"group\":\n              if (!l.contents && !l.id && !l.break && !l.expandedStates) return \"\";\n              if (l.contents.type === \"group\" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates) return l.contents;\n              break;\n\n            case \"align\":\n            case \"indent\":\n            case \"indent-if-break\":\n            case \"line-suffix\":\n              if (!l.contents) return \"\";\n              break;\n\n            case \"if-break\":\n              if (!l.flatContents && !l.breakContents) return \"\";\n              break;\n          }\n\n          if (!r(l)) return l;\n          let E = [];\n\n          for (let y of u(l)) {\n            if (!y) continue;\n\n            let _ref2 = r(y) ? u(y) : [y],\n                _ref3 = _toArray(_ref2),\n                N = _ref3[0],\n                x = _ref3.slice(1);\n\n            typeof N == \"string\" && typeof t(E) == \"string\" ? E[E.length - 1] += N : E.push(N), E.push(...x);\n          }\n\n          return E.length === 0 ? \"\" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, {\n            parts: E\n          });\n        }\n\n        function I(l) {\n          return c(l, E => B(E));\n        }\n\n        function k(l) {\n          let E = [],\n              y = l.filter(Boolean);\n\n          for (; y.length > 0;) {\n            let N = y.shift();\n\n            if (!!N) {\n              if (r(N)) {\n                y.unshift(...u(N));\n                continue;\n              }\n\n              if (E.length > 0 && typeof t(E) == \"string\" && typeof N == \"string\") {\n                E[E.length - 1] += N;\n                continue;\n              }\n\n              E.push(N);\n            }\n          }\n\n          return E;\n        }\n\n        function P(l) {\n          return c(l, E => Array.isArray(E) ? k(E) : E.parts ? Object.assign(Object.assign({}, E), {}, {\n            parts: k(E.parts)\n          }) : E);\n        }\n\n        function C(l) {\n          return c(l, E => typeof E == \"string\" && E.includes(\"\\n\") ? D(E) : E);\n        }\n\n        function D(l) {\n          let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;\n          return a(E, l.split(\"\\n\")).parts;\n        }\n\n        function g(l) {\n          if (l.type === \"line\") return !0;\n        }\n\n        function F(l) {\n          return v(l, g, !1);\n        }\n\n        n.exports = {\n          isConcat: r,\n          getDocParts: u,\n          willBreak: d,\n          traverseDoc: o,\n          findInDoc: v,\n          mapDoc: c,\n          propagateBreaks: f,\n          removeLines: w,\n          stripTrailingHardline: S,\n          normalizeParts: k,\n          normalizeDoc: P,\n          cleanDoc: I,\n          replaceTextEndOfLine: D,\n          replaceEndOfLine: C,\n          canBreak: F\n        };\n      }\n\n    }),\n        yD = Z({\n      \"src/document/doc-printer.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _jn = jn(),\n            t = _jn.convertEndOfLineToChars,\n            s = it(),\n            a = Ca(),\n            _Ln2 = Ln(),\n            r = _Ln2.fill,\n            u = _Ln2.cursor,\n            i = _Ln2.indent,\n            _On = On(),\n            o = _On.isConcat,\n            c = _On.getDocParts,\n            v,\n            m = 1,\n            d = 2;\n\n        function p() {\n          return {\n            value: \"\",\n            length: 0,\n            queue: []\n          };\n        }\n\n        function f(B, I) {\n          return w(B, {\n            type: \"indent\"\n          }, I);\n        }\n\n        function h(B, I, k) {\n          return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, {\n            type: \"dedent\"\n          }, k) : I ? I.type === \"root\" ? Object.assign(Object.assign({}, B), {}, {\n            root: B\n          }) : w(B, {\n            type: typeof I == \"string\" ? \"stringAlign\" : \"numberAlign\",\n            n: I\n          }, k) : B;\n        }\n\n        function w(B, I, k) {\n          let P = I.type === \"dedent\" ? B.queue.slice(0, -1) : [...B.queue, I],\n              C = \"\",\n              D = 0,\n              g = 0,\n              F = 0;\n\n          for (let L of P) switch (L.type) {\n            case \"indent\":\n              y(), k.useTabs ? l(1) : E(k.tabWidth);\n              break;\n\n            case \"stringAlign\":\n              y(), C += L.n, D += L.n.length;\n              break;\n\n            case \"numberAlign\":\n              g += 1, F += L.n;\n              break;\n\n            default:\n              throw new Error(\"Unexpected type '\".concat(L.type, \"'\"));\n          }\n\n          return x(), Object.assign(Object.assign({}, B), {}, {\n            value: C,\n            length: D,\n            queue: P\n          });\n\n          function l(L) {\n            C += \"\t\".repeat(L), D += k.tabWidth * L;\n          }\n\n          function E(L) {\n            C += \" \".repeat(L), D += L;\n          }\n\n          function y() {\n            k.useTabs ? N() : x();\n          }\n\n          function N() {\n            g > 0 && l(g), b();\n          }\n\n          function x() {\n            F > 0 && E(F), b();\n          }\n\n          function b() {\n            g = 0, F = 0;\n          }\n        }\n\n        function T(B) {\n          if (B.length === 0) return 0;\n          let I = 0;\n\n          for (; B.length > 0 && typeof s(B) == \"string\" && /^[\\t ]*$/.test(s(B));) I += B.pop().length;\n\n          if (B.length > 0 && typeof s(B) == \"string\") {\n            let k = s(B).replace(/[\\t ]*$/, \"\");\n            I += s(B).length - k.length, B[B.length - 1] = k;\n          }\n\n          return I;\n        }\n\n        function A(B, I, k, P, C, D) {\n          let g = I.length,\n              F = [B],\n              l = [];\n\n          for (; k >= 0;) {\n            if (F.length === 0) {\n              if (g === 0) return !0;\n              F.push(I[g - 1]), g--;\n              continue;\n            }\n\n            let _F$pop = F.pop(),\n                _F$pop2 = _slicedToArray(_F$pop, 3),\n                E = _F$pop2[0],\n                y = _F$pop2[1],\n                N = _F$pop2[2];\n\n            if (typeof N == \"string\") l.push(N), k -= a(N);else if (o(N)) {\n              let x = c(N);\n\n              for (let b = x.length - 1; b >= 0; b--) F.push([E, y, x[b]]);\n            } else switch (N.type) {\n              case \"indent\":\n                F.push([f(E, P), y, N.contents]);\n                break;\n\n              case \"align\":\n                F.push([h(E, N.n, P), y, N.contents]);\n                break;\n\n              case \"trim\":\n                k += T(l);\n                break;\n\n              case \"group\":\n                {\n                  if (D && N.break) return !1;\n                  let x = N.break ? m : y;\n                  F.push([E, x, N.expandedStates && x === m ? s(N.expandedStates) : N.contents]), N.id && (v[N.id] = x);\n                  break;\n                }\n\n              case \"fill\":\n                for (let x = N.parts.length - 1; x >= 0; x--) F.push([E, y, N.parts[x]]);\n\n                break;\n\n              case \"if-break\":\n              case \"indent-if-break\":\n                {\n                  let x = N.groupId ? v[N.groupId] : y;\n\n                  if (x === m) {\n                    let b = N.type === \"if-break\" ? N.breakContents : N.negate ? N.contents : i(N.contents);\n                    b && F.push([E, y, b]);\n                  }\n\n                  if (x === d) {\n                    let b = N.type === \"if-break\" ? N.flatContents : N.negate ? i(N.contents) : N.contents;\n                    b && F.push([E, y, b]);\n                  }\n\n                  break;\n                }\n\n              case \"line\":\n                switch (y) {\n                  case d:\n                    if (!N.hard) {\n                      N.soft || (l.push(\" \"), k -= 1);\n                      break;\n                    }\n\n                    return !0;\n\n                  case m:\n                    return !0;\n                }\n\n                break;\n\n              case \"line-suffix\":\n                C = !0;\n                break;\n\n              case \"line-suffix-boundary\":\n                if (C) return !1;\n                break;\n\n              case \"label\":\n                F.push([E, y, N.contents]);\n                break;\n            }\n          }\n\n          return !1;\n        }\n\n        function S(B, I) {\n          v = {};\n          let k = I.printWidth,\n              P = t(I.endOfLine),\n              C = 0,\n              D = [[p(), m, B]],\n              g = [],\n              F = !1,\n              l = [];\n\n          for (; D.length > 0;) {\n            let _D$pop = D.pop(),\n                _D$pop2 = _slicedToArray(_D$pop, 3),\n                y = _D$pop2[0],\n                N = _D$pop2[1],\n                x = _D$pop2[2];\n\n            if (typeof x == \"string\") {\n              let b = P !== \"\\n\" ? x.replace(/\\n/g, P) : x;\n              g.push(b), C += a(b);\n            } else if (o(x)) {\n              let b = c(x);\n\n              for (let L = b.length - 1; L >= 0; L--) D.push([y, N, b[L]]);\n            } else switch (x.type) {\n              case \"cursor\":\n                g.push(u.placeholder);\n                break;\n\n              case \"indent\":\n                D.push([f(y, I), N, x.contents]);\n                break;\n\n              case \"align\":\n                D.push([h(y, x.n, I), N, x.contents]);\n                break;\n\n              case \"trim\":\n                C -= T(g);\n                break;\n\n              case \"group\":\n                switch (N) {\n                  case d:\n                    if (!F) {\n                      D.push([y, x.break ? m : d, x.contents]);\n                      break;\n                    }\n\n                  case m:\n                    {\n                      F = !1;\n                      let b = [y, d, x.contents],\n                          L = k - C,\n                          M = l.length > 0;\n                      if (!x.break && A(b, D, L, I, M)) D.push(b);else if (x.expandedStates) {\n                        let j = s(x.expandedStates);\n\n                        if (x.break) {\n                          D.push([y, m, j]);\n                          break;\n                        } else for (let $ = 1; $ < x.expandedStates.length + 1; $++) if ($ >= x.expandedStates.length) {\n                          D.push([y, m, j]);\n                          break;\n                        } else {\n                          let V = x.expandedStates[$],\n                              q = [y, d, V];\n\n                          if (A(q, D, L, I, M)) {\n                            D.push(q);\n                            break;\n                          }\n                        }\n                      } else D.push([y, m, x.contents]);\n                      break;\n                    }\n                }\n\n                x.id && (v[x.id] = s(D)[1]);\n                break;\n\n              case \"fill\":\n                {\n                  let b = k - C,\n                      L = x.parts;\n                  if (L.length === 0) break;\n\n                  let _L = _slicedToArray(L, 2),\n                      M = _L[0],\n                      j = _L[1],\n                      $ = [y, d, M],\n                      V = [y, m, M],\n                      q = A($, [], b, I, l.length > 0, !0);\n\n                  if (L.length === 1) {\n                    q ? D.push($) : D.push(V);\n                    break;\n                  }\n\n                  let Y = [y, d, j],\n                      H = [y, m, j];\n\n                  if (L.length === 2) {\n                    q ? D.push(Y, $) : D.push(H, V);\n                    break;\n                  }\n\n                  L.splice(0, 2);\n                  let R = [y, N, r(L)],\n                      Q = L[0];\n                  A([y, d, [M, j, Q]], [], b, I, l.length > 0, !0) ? D.push(R, Y, $) : q ? D.push(R, H, $) : D.push(R, H, V);\n                  break;\n                }\n\n              case \"if-break\":\n              case \"indent-if-break\":\n                {\n                  let b = x.groupId ? v[x.groupId] : N;\n\n                  if (b === m) {\n                    let L = x.type === \"if-break\" ? x.breakContents : x.negate ? x.contents : i(x.contents);\n                    L && D.push([y, N, L]);\n                  }\n\n                  if (b === d) {\n                    let L = x.type === \"if-break\" ? x.flatContents : x.negate ? i(x.contents) : x.contents;\n                    L && D.push([y, N, L]);\n                  }\n\n                  break;\n                }\n\n              case \"line-suffix\":\n                l.push([y, N, x.contents]);\n                break;\n\n              case \"line-suffix-boundary\":\n                l.length > 0 && D.push([y, N, {\n                  type: \"line\",\n                  hard: !0\n                }]);\n                break;\n\n              case \"line\":\n                switch (N) {\n                  case d:\n                    if (x.hard) F = !0;else {\n                      x.soft || (g.push(\" \"), C += 1);\n                      break;\n                    }\n\n                  case m:\n                    if (l.length > 0) {\n                      D.push([y, N, x], ...l.reverse()), l = [];\n                      break;\n                    }\n\n                    x.literal ? y.root ? (g.push(P, y.root.value), C = y.root.length) : (g.push(P), C = 0) : (C -= T(g), g.push(P + y.value), C = y.length);\n                    break;\n                }\n\n                break;\n\n              case \"label\":\n                D.push([y, N, x.contents]);\n                break;\n\n              default:\n            }\n\n            D.length === 0 && l.length > 0 && (D.push(...l.reverse()), l = []);\n          }\n\n          let E = g.indexOf(u.placeholder);\n\n          if (E !== -1) {\n            let y = g.indexOf(u.placeholder, E + 1),\n                N = g.slice(0, E).join(\"\"),\n                x = g.slice(E + 1, y).join(\"\"),\n                b = g.slice(y + 1).join(\"\");\n            return {\n              formatted: N + x + b,\n              cursorNodeStart: N.length,\n              cursorNodeText: x\n            };\n          }\n\n          return {\n            formatted: g.join(\"\")\n          };\n        }\n\n        n.exports = {\n          printDocToString: S\n        };\n      }\n\n    }),\n        hD = Z({\n      \"src/document/doc-debug.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _On2 = On(),\n            t = _On2.isConcat,\n            s = _On2.getDocParts;\n\n        function a(u) {\n          if (!u) return \"\";\n\n          if (t(u)) {\n            let i = [];\n\n            for (let o of s(u)) if (t(o)) i.push(...a(o).parts);else {\n              let c = a(o);\n              c !== \"\" && i.push(c);\n            }\n\n            return {\n              type: \"concat\",\n              parts: i\n            };\n          }\n\n          return u.type === \"if-break\" ? Object.assign(Object.assign({}, u), {}, {\n            breakContents: a(u.breakContents),\n            flatContents: a(u.flatContents)\n          }) : u.type === \"group\" ? Object.assign(Object.assign({}, u), {}, {\n            contents: a(u.contents),\n            expandedStates: u.expandedStates && u.expandedStates.map(a)\n          }) : u.type === \"fill\" ? {\n            type: \"fill\",\n            parts: u.parts.map(a)\n          } : u.contents ? Object.assign(Object.assign({}, u), {}, {\n            contents: a(u.contents)\n          }) : u;\n        }\n\n        function r(u) {\n          let i = Object.create(null),\n              o = new Set();\n          return c(a(u));\n\n          function c(m, d, p) {\n            if (typeof m == \"string\") return JSON.stringify(m);\n\n            if (t(m)) {\n              let f = s(m).map(c).filter(Boolean);\n              return f.length === 1 ? f[0] : \"[\".concat(f.join(\", \"), \"]\");\n            }\n\n            if (m.type === \"line\") {\n              let f = Array.isArray(p) && p[d + 1] && p[d + 1].type === \"break-parent\";\n              return m.literal ? f ? \"literalline\" : \"literallineWithoutBreakParent\" : m.hard ? f ? \"hardline\" : \"hardlineWithoutBreakParent\" : m.soft ? \"softline\" : \"line\";\n            }\n\n            if (m.type === \"break-parent\") return Array.isArray(p) && p[d - 1] && p[d - 1].type === \"line\" && p[d - 1].hard ? void 0 : \"breakParent\";\n            if (m.type === \"trim\") return \"trim\";\n            if (m.type === \"indent\") return \"indent(\" + c(m.contents) + \")\";\n            if (m.type === \"align\") return m.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + c(m.contents) + \")\" : m.n < 0 ? \"dedent(\" + c(m.contents) + \")\" : m.n.type === \"root\" ? \"markAsRoot(\" + c(m.contents) + \")\" : \"align(\" + JSON.stringify(m.n) + \", \" + c(m.contents) + \")\";\n            if (m.type === \"if-break\") return \"ifBreak(\" + c(m.breakContents) + (m.flatContents ? \", \" + c(m.flatContents) : \"\") + (m.groupId ? (m.flatContents ? \"\" : ', \"\"') + \", { groupId: \".concat(v(m.groupId), \" }\") : \"\") + \")\";\n\n            if (m.type === \"indent-if-break\") {\n              let f = [];\n              m.negate && f.push(\"negate: true\"), m.groupId && f.push(\"groupId: \".concat(v(m.groupId)));\n              let h = f.length > 0 ? \", { \".concat(f.join(\", \"), \" }\") : \"\";\n              return \"indentIfBreak(\".concat(c(m.contents)).concat(h, \")\");\n            }\n\n            if (m.type === \"group\") {\n              let f = [];\n              m.break && m.break !== \"propagated\" && f.push(\"shouldBreak: true\"), m.id && f.push(\"id: \".concat(v(m.id)));\n              let h = f.length > 0 ? \", { \".concat(f.join(\", \"), \" }\") : \"\";\n              return m.expandedStates ? \"conditionalGroup([\".concat(m.expandedStates.map(w => c(w)).join(\",\"), \"]\").concat(h, \")\") : \"group(\".concat(c(m.contents)).concat(h, \")\");\n            }\n\n            if (m.type === \"fill\") return \"fill([\".concat(m.parts.map(f => c(f)).join(\", \"), \"])\");\n            if (m.type === \"line-suffix\") return \"lineSuffix(\" + c(m.contents) + \")\";\n            if (m.type === \"line-suffix-boundary\") return \"lineSuffixBoundary\";\n            if (m.type === \"label\") return \"label(\".concat(JSON.stringify(m.label), \", \").concat(c(m.contents), \")\");\n            throw new Error(\"Unknown doc type \" + m.type);\n          }\n\n          function v(m) {\n            if (typeof m != \"symbol\") return JSON.stringify(String(m));\n            if (m in i) return i[m];\n            let d = String(m).slice(7, -1) || \"symbol\";\n\n            for (let p = 0;; p++) {\n              let f = d + (p > 0 ? \" #\".concat(p) : \"\");\n              if (!o.has(f)) return o.add(f), i[m] = \"Symbol.for(\".concat(JSON.stringify(f), \")\");\n            }\n          }\n        }\n\n        n.exports = {\n          printDocToDebug: r\n        };\n      }\n\n    }),\n        Oe = Z({\n      \"src/document/index.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = {\n          builders: Ln(),\n          printer: yD(),\n          utils: On(),\n          debug: hD()\n        };\n      }\n\n    }),\n        Ea = {};\n    Ut(Ea, {\n      default: () => vD\n    });\n\n    function vD(e) {\n      if (typeof e != \"string\") throw new TypeError(\"Expected a string\");\n      return e.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n    }\n\n    var CD = mt({\n      \"node_modules/escape-string-regexp/index.js\"() {\n        re();\n      }\n\n    }),\n        Fa = Z({\n      \"node_modules/semver/internal/debug.js\"(e, n) {\n        re();\n        var t = typeof Tt == \"object\" && Tt.env && Tt.env.NODE_DEBUG && /\\bsemver\\b/i.test(Tt.env.NODE_DEBUG) ? function () {\n          for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++) a[r] = arguments[r];\n\n          return console.error(\"SEMVER\", ...a);\n        } : () => {};\n        n.exports = t;\n      }\n\n    }),\n        Aa = Z({\n      \"node_modules/semver/internal/constants.js\"(e, n) {\n        re();\n        var t = \"2.0.0\",\n            s = 256,\n            a = Number.MAX_SAFE_INTEGER || 9007199254740991,\n            r = 16;\n        n.exports = {\n          SEMVER_SPEC_VERSION: t,\n          MAX_LENGTH: s,\n          MAX_SAFE_INTEGER: a,\n          MAX_SAFE_COMPONENT_LENGTH: r\n        };\n      }\n\n    }),\n        ED = Z({\n      \"node_modules/semver/internal/re.js\"(e, n) {\n        re();\n\n        var _Aa = Aa(),\n            t = _Aa.MAX_SAFE_COMPONENT_LENGTH,\n            s = Fa();\n\n        e = n.exports = {};\n\n        var a = e.re = [],\n            r = e.src = [],\n            u = e.t = {},\n            i = 0,\n            o = (c, v, m) => {\n          let d = i++;\n          s(c, d, v), u[c] = d, r[d] = v, a[d] = new RegExp(v, m ? \"g\" : void 0);\n        };\n\n        o(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\"), o(\"NUMERICIDENTIFIERLOOSE\", \"[0-9]+\"), o(\"NONNUMERICIDENTIFIER\", \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"), o(\"MAINVERSION\", \"(\".concat(r[u.NUMERICIDENTIFIER], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIER], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIER], \")\")), o(\"MAINVERSIONLOOSE\", \"(\".concat(r[u.NUMERICIDENTIFIERLOOSE], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIERLOOSE], \")\\\\.(\").concat(r[u.NUMERICIDENTIFIERLOOSE], \")\")), o(\"PRERELEASEIDENTIFIER\", \"(?:\".concat(r[u.NUMERICIDENTIFIER], \"|\").concat(r[u.NONNUMERICIDENTIFIER], \")\")), o(\"PRERELEASEIDENTIFIERLOOSE\", \"(?:\".concat(r[u.NUMERICIDENTIFIERLOOSE], \"|\").concat(r[u.NONNUMERICIDENTIFIER], \")\")), o(\"PRERELEASE\", \"(?:-(\".concat(r[u.PRERELEASEIDENTIFIER], \"(?:\\\\.\").concat(r[u.PRERELEASEIDENTIFIER], \")*))\")), o(\"PRERELEASELOOSE\", \"(?:-?(\".concat(r[u.PRERELEASEIDENTIFIERLOOSE], \"(?:\\\\.\").concat(r[u.PRERELEASEIDENTIFIERLOOSE], \")*))\")), o(\"BUILDIDENTIFIER\", \"[0-9A-Za-z-]+\"), o(\"BUILD\", \"(?:\\\\+(\".concat(r[u.BUILDIDENTIFIER], \"(?:\\\\.\").concat(r[u.BUILDIDENTIFIER], \")*))\")), o(\"FULLPLAIN\", \"v?\".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], \"?\").concat(r[u.BUILD], \"?\")), o(\"FULL\", \"^\".concat(r[u.FULLPLAIN], \"$\")), o(\"LOOSEPLAIN\", \"[v=\\\\s]*\".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], \"?\").concat(r[u.BUILD], \"?\")), o(\"LOOSE\", \"^\".concat(r[u.LOOSEPLAIN], \"$\")), o(\"GTLT\", \"((?:<|>)?=?)\"), o(\"XRANGEIDENTIFIERLOOSE\", \"\".concat(r[u.NUMERICIDENTIFIERLOOSE], \"|x|X|\\\\*\")), o(\"XRANGEIDENTIFIER\", \"\".concat(r[u.NUMERICIDENTIFIER], \"|x|X|\\\\*\")), o(\"XRANGEPLAIN\", \"[v=\\\\s]*(\".concat(r[u.XRANGEIDENTIFIER], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIER], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIER], \")(?:\").concat(r[u.PRERELEASE], \")?\").concat(r[u.BUILD], \"?)?)?\")), o(\"XRANGEPLAINLOOSE\", \"[v=\\\\s]*(\".concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\\\\.(\").concat(r[u.XRANGEIDENTIFIERLOOSE], \")(?:\").concat(r[u.PRERELEASELOOSE], \")?\").concat(r[u.BUILD], \"?)?)?\")), o(\"XRANGE\", \"^\".concat(r[u.GTLT], \"\\\\s*\").concat(r[u.XRANGEPLAIN], \"$\")), o(\"XRANGELOOSE\", \"^\".concat(r[u.GTLT], \"\\\\s*\").concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"COERCE\", \"(^|[^\\\\d])(\\\\d{1,\".concat(t, \"})(?:\\\\.(\\\\d{1,\").concat(t, \"}))?(?:\\\\.(\\\\d{1,\").concat(t, \"}))?(?:$|[^\\\\d])\")), o(\"COERCERTL\", r[u.COERCE], !0), o(\"LONETILDE\", \"(?:~>?)\"), o(\"TILDETRIM\", \"(\\\\s*)\".concat(r[u.LONETILDE], \"\\\\s+\"), !0), e.tildeTrimReplace = \"$1~\", o(\"TILDE\", \"^\".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], \"$\")), o(\"TILDELOOSE\", \"^\".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"LONECARET\", \"(?:\\\\^)\"), o(\"CARETTRIM\", \"(\\\\s*)\".concat(r[u.LONECARET], \"\\\\s+\"), !0), e.caretTrimReplace = \"$1^\", o(\"CARET\", \"^\".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], \"$\")), o(\"CARETLOOSE\", \"^\".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], \"$\")), o(\"COMPARATORLOOSE\", \"^\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.LOOSEPLAIN], \")$|^$\")), o(\"COMPARATOR\", \"^\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.FULLPLAIN], \")$|^$\")), o(\"COMPARATORTRIM\", \"(\\\\s*)\".concat(r[u.GTLT], \"\\\\s*(\").concat(r[u.LOOSEPLAIN], \"|\").concat(r[u.XRANGEPLAIN], \")\"), !0), e.comparatorTrimReplace = \"$1$2$3\", o(\"HYPHENRANGE\", \"^\\\\s*(\".concat(r[u.XRANGEPLAIN], \")\\\\s+-\\\\s+(\").concat(r[u.XRANGEPLAIN], \")\\\\s*$\")), o(\"HYPHENRANGELOOSE\", \"^\\\\s*(\".concat(r[u.XRANGEPLAINLOOSE], \")\\\\s+-\\\\s+(\").concat(r[u.XRANGEPLAINLOOSE], \")\\\\s*$\")), o(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\"), o(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\"), o(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n      }\n\n    }),\n        FD = Z({\n      \"node_modules/semver/internal/parse-options.js\"(e, n) {\n        re();\n\n        var t = [\"includePrerelease\", \"loose\", \"rtl\"],\n            s = a => a ? typeof a != \"object\" ? {\n          loose: !0\n        } : t.filter(r => a[r]).reduce((r, u) => (r[u] = !0, r), {}) : {};\n\n        n.exports = s;\n      }\n\n    }),\n        AD = Z({\n      \"node_modules/semver/internal/identifiers.js\"(e, n) {\n        re();\n\n        var t = /^[0-9]+$/,\n            s = (r, u) => {\n          let i = t.test(r),\n              o = t.test(u);\n          return i && o && (r = +r, u = +u), r === u ? 0 : i && !o ? -1 : o && !i ? 1 : r < u ? -1 : 1;\n        },\n            a = (r, u) => s(u, r);\n\n        n.exports = {\n          compareIdentifiers: s,\n          rcompareIdentifiers: a\n        };\n      }\n\n    }),\n        SD = Z({\n      \"node_modules/semver/classes/semver.js\"(e, n) {\n        re();\n\n        var t = Fa(),\n            _Aa2 = Aa(),\n            s = _Aa2.MAX_LENGTH,\n            a = _Aa2.MAX_SAFE_INTEGER,\n            _ED = ED(),\n            r = _ED.re,\n            u = _ED.t,\n            i = FD(),\n            _AD = AD(),\n            o = _AD.compareIdentifiers,\n            c = class {\n          constructor(v, m) {\n            if (m = i(m), v instanceof c) {\n              if (v.loose === !!m.loose && v.includePrerelease === !!m.includePrerelease) return v;\n              v = v.version;\n            } else if (typeof v != \"string\") throw new TypeError(\"Invalid Version: \".concat(v));\n\n            if (v.length > s) throw new TypeError(\"version is longer than \".concat(s, \" characters\"));\n            t(\"SemVer\", v, m), this.options = m, this.loose = !!m.loose, this.includePrerelease = !!m.includePrerelease;\n            let d = v.trim().match(m.loose ? r[u.LOOSE] : r[u.FULL]);\n            if (!d) throw new TypeError(\"Invalid Version: \".concat(v));\n            if (this.raw = v, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0) throw new TypeError(\"Invalid major version\");\n            if (this.minor > a || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n            if (this.patch > a || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n            d[4] ? this.prerelease = d[4].split(\".\").map(p => {\n              if (/^[0-9]+$/.test(p)) {\n                let f = +p;\n                if (f >= 0 && f < a) return f;\n              }\n\n              return p;\n            }) : this.prerelease = [], this.build = d[5] ? d[5].split(\".\") : [], this.format();\n          }\n\n          format() {\n            return this.version = \"\".concat(this.major, \".\").concat(this.minor, \".\").concat(this.patch), this.prerelease.length && (this.version += \"-\".concat(this.prerelease.join(\".\"))), this.version;\n          }\n\n          toString() {\n            return this.version;\n          }\n\n          compare(v) {\n            if (t(\"SemVer.compare\", this.version, this.options, v), !(v instanceof c)) {\n              if (typeof v == \"string\" && v === this.version) return 0;\n              v = new c(v, this.options);\n            }\n\n            return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);\n          }\n\n          compareMain(v) {\n            return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);\n          }\n\n          comparePre(v) {\n            if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length) return -1;\n            if (!this.prerelease.length && v.prerelease.length) return 1;\n            if (!this.prerelease.length && !v.prerelease.length) return 0;\n            let m = 0;\n\n            do {\n              let d = this.prerelease[m],\n                  p = v.prerelease[m];\n              if (t(\"prerelease compare\", m, d, p), d === void 0 && p === void 0) return 0;\n              if (p === void 0) return 1;\n              if (d === void 0) return -1;\n              if (d === p) continue;\n              return o(d, p);\n            } while (++m);\n          }\n\n          compareBuild(v) {\n            v instanceof c || (v = new c(v, this.options));\n            let m = 0;\n\n            do {\n              let d = this.build[m],\n                  p = v.build[m];\n              if (t(\"prerelease compare\", m, d, p), d === void 0 && p === void 0) return 0;\n              if (p === void 0) return 1;\n              if (d === void 0) return -1;\n              if (d === p) continue;\n              return o(d, p);\n            } while (++m);\n          }\n\n          inc(v, m) {\n            switch (v) {\n              case \"premajor\":\n                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc(\"pre\", m);\n                break;\n\n              case \"preminor\":\n                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc(\"pre\", m);\n                break;\n\n              case \"prepatch\":\n                this.prerelease.length = 0, this.inc(\"patch\", m), this.inc(\"pre\", m);\n                break;\n\n              case \"prerelease\":\n                this.prerelease.length === 0 && this.inc(\"patch\", m), this.inc(\"pre\", m);\n                break;\n\n              case \"major\":\n                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];\n                break;\n\n              case \"minor\":\n                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];\n                break;\n\n              case \"patch\":\n                this.prerelease.length === 0 && this.patch++, this.prerelease = [];\n                break;\n\n              case \"pre\":\n                if (this.prerelease.length === 0) this.prerelease = [0];else {\n                  let d = this.prerelease.length;\n\n                  for (; --d >= 0;) typeof this.prerelease[d] == \"number\" && (this.prerelease[d]++, d = -2);\n\n                  d === -1 && this.prerelease.push(0);\n                }\n                m && (o(this.prerelease[0], m) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m, 0]) : this.prerelease = [m, 0]);\n                break;\n\n              default:\n                throw new Error(\"invalid increment argument: \".concat(v));\n            }\n\n            return this.format(), this.raw = this.version, this;\n          }\n\n        };\n\n        n.exports = c;\n      }\n\n    }),\n        qn = Z({\n      \"node_modules/semver/functions/compare.js\"(e, n) {\n        re();\n\n        var t = SD(),\n            s = (a, r, u) => new t(a, u).compare(new t(r, u));\n\n        n.exports = s;\n      }\n\n    }),\n        xD = Z({\n      \"node_modules/semver/functions/lt.js\"(e, n) {\n        re();\n\n        var t = qn(),\n            s = (a, r, u) => t(a, r, u) < 0;\n\n        n.exports = s;\n      }\n\n    }),\n        bD = Z({\n      \"node_modules/semver/functions/gte.js\"(e, n) {\n        re();\n\n        var t = qn(),\n            s = (a, r, u) => t(a, r, u) >= 0;\n\n        n.exports = s;\n      }\n\n    }),\n        TD = Z({\n      \"src/utils/arrayify.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = (t, s) => Object.entries(t).map(a => {\n          let _a2 = _slicedToArray(a, 2),\n              r = _a2[0],\n              u = _a2[1];\n\n          return Object.assign({\n            [s]: r\n          }, u);\n        });\n      }\n\n    }),\n        BD = Z({\n      \"node_modules/outdent/lib/index.js\"(e, n) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.outdent = void 0;\n\n        function t() {\n          for (var A = [], S = 0; S < arguments.length; S++) A[S] = arguments[S];\n        }\n\n        function s() {\n          return typeof WeakMap < \"u\" ? new WeakMap() : a();\n        }\n\n        function a() {\n          return {\n            add: t,\n            delete: t,\n            get: t,\n            set: t,\n            has: function (A) {\n              return !1;\n            }\n          };\n        }\n\n        var r = Object.prototype.hasOwnProperty,\n            u = function (A, S) {\n          return r.call(A, S);\n        };\n\n        function i(A, S) {\n          for (var B in S) u(S, B) && (A[B] = S[B]);\n\n          return A;\n        }\n\n        var o = /^[ \\t]*(?:\\r\\n|\\r|\\n)/,\n            c = /(?:\\r\\n|\\r|\\n)[ \\t]*$/,\n            v = /^(?:[\\r\\n]|$)/,\n            m = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/,\n            d = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n\n        function p(A, S, B) {\n          var I = 0,\n              k = A[0].match(m);\n          k && (I = k[1].length);\n          var P = \"(\\\\r\\\\n|\\\\r|\\\\n).{0,\" + I + \"}\",\n              C = new RegExp(P, \"g\");\n          S && (A = A.slice(1));\n          var D = B.newline,\n              g = B.trimLeadingNewline,\n              F = B.trimTrailingNewline,\n              l = typeof D == \"string\",\n              E = A.length,\n              y = A.map(function (N, x) {\n            return N = N.replace(C, \"$1\"), x === 0 && g && (N = N.replace(o, \"\")), x === E - 1 && F && (N = N.replace(c, \"\")), l && (N = N.replace(/\\r\\n|\\n|\\r/g, function (b) {\n              return D;\n            })), N;\n          });\n          return y;\n        }\n\n        function f(A, S) {\n          for (var B = \"\", I = 0, k = A.length; I < k; I++) B += A[I], I < k - 1 && (B += S[I]);\n\n          return B;\n        }\n\n        function h(A) {\n          return u(A, \"raw\") && u(A, \"length\");\n        }\n\n        function w(A) {\n          var S = s(),\n              B = s();\n\n          function I(P) {\n            for (var C = [], D = 1; D < arguments.length; D++) C[D - 1] = arguments[D];\n\n            if (h(P)) {\n              var g = P,\n                  F = (C[0] === I || C[0] === T) && d.test(g[0]) && v.test(g[1]),\n                  l = F ? B : S,\n                  E = l.get(g);\n              if (E || (E = p(g, F, A), l.set(g, E)), C.length === 0) return E[0];\n              var y = f(E, F ? C.slice(1) : C);\n              return y;\n            } else return w(i(i({}, A), P || {}));\n          }\n\n          var k = i(I, {\n            string: function (P) {\n              return p([P], !1, A)[0];\n            }\n          });\n          return k;\n        }\n\n        var T = w({\n          trimLeadingNewline: !0,\n          trimTrailingNewline: !0\n        });\n        if (e.outdent = T, e.default = T, typeof n < \"u\") try {\n          n.exports = T, Object.defineProperty(T, \"__esModule\", {\n            value: !0\n          }), T.default = T, T.outdent = T;\n        } catch {}\n      }\n\n    }),\n        ND = Z({\n      \"src/main/core-options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _BD = BD(),\n            t = _BD.outdent,\n            s = \"Config\",\n            a = \"Editor\",\n            r = \"Format\",\n            u = \"Other\",\n            i = \"Output\",\n            o = \"Global\",\n            c = \"Special\",\n            v = {\n          cursorOffset: {\n            since: \"1.4.0\",\n            category: c,\n            type: \"int\",\n            default: -1,\n            range: {\n              start: -1,\n              end: Number.POSITIVE_INFINITY,\n              step: 1\n            },\n            description: t(sa || (sa = Pt([\"\\n      Print (to stderr) where a cursor at the given position would move to after formatting.\\n      This option cannot be used with --range-start and --range-end.\\n    \"]))),\n            cliCategory: a\n          },\n          endOfLine: {\n            since: \"1.15.0\",\n            category: o,\n            type: \"choice\",\n            default: [{\n              since: \"1.15.0\",\n              value: \"auto\"\n            }, {\n              since: \"2.0.0\",\n              value: \"lf\"\n            }],\n            description: \"Which end of line characters to apply.\",\n            choices: [{\n              value: \"lf\",\n              description: \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"\n            }, {\n              value: \"crlf\",\n              description: \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"\n            }, {\n              value: \"cr\",\n              description: \"Carriage Return character only (\\\\r), used very rarely\"\n            }, {\n              value: \"auto\",\n              description: t(ia || (ia = Pt([\"\\n          Maintain existing\\n          (mixed values within one file are normalised by looking at what's used after the first line)\\n        \"])))\n            }]\n          },\n          filepath: {\n            since: \"1.4.0\",\n            category: c,\n            type: \"path\",\n            description: \"Specify the input filepath. This will be used to do parser inference.\",\n            cliName: \"stdin-filepath\",\n            cliCategory: u,\n            cliDescription: \"Path to the file to pretend that stdin comes from.\"\n          },\n          insertPragma: {\n            since: \"1.8.0\",\n            category: c,\n            type: \"boolean\",\n            default: !1,\n            description: \"Insert @format pragma into file's first docblock comment.\",\n            cliCategory: u\n          },\n          parser: {\n            since: \"0.0.10\",\n            category: o,\n            type: \"choice\",\n            default: [{\n              since: \"0.0.10\",\n              value: \"babylon\"\n            }, {\n              since: \"1.13.0\",\n              value: void 0\n            }],\n            description: \"Which parser to use.\",\n            exception: m => typeof m == \"string\" || typeof m == \"function\",\n            choices: [{\n              value: \"flow\",\n              description: \"Flow\"\n            }, {\n              value: \"babel\",\n              since: \"1.16.0\",\n              description: \"JavaScript\"\n            }, {\n              value: \"babel-flow\",\n              since: \"1.16.0\",\n              description: \"Flow\"\n            }, {\n              value: \"babel-ts\",\n              since: \"2.0.0\",\n              description: \"TypeScript\"\n            }, {\n              value: \"typescript\",\n              since: \"1.4.0\",\n              description: \"TypeScript\"\n            }, {\n              value: \"acorn\",\n              since: \"2.6.0\",\n              description: \"JavaScript\"\n            }, {\n              value: \"espree\",\n              since: \"2.2.0\",\n              description: \"JavaScript\"\n            }, {\n              value: \"meriyah\",\n              since: \"2.2.0\",\n              description: \"JavaScript\"\n            }, {\n              value: \"css\",\n              since: \"1.7.1\",\n              description: \"CSS\"\n            }, {\n              value: \"less\",\n              since: \"1.7.1\",\n              description: \"Less\"\n            }, {\n              value: \"scss\",\n              since: \"1.7.1\",\n              description: \"SCSS\"\n            }, {\n              value: \"json\",\n              since: \"1.5.0\",\n              description: \"JSON\"\n            }, {\n              value: \"json5\",\n              since: \"1.13.0\",\n              description: \"JSON5\"\n            }, {\n              value: \"json-stringify\",\n              since: \"1.13.0\",\n              description: \"JSON.stringify\"\n            }, {\n              value: \"graphql\",\n              since: \"1.5.0\",\n              description: \"GraphQL\"\n            }, {\n              value: \"markdown\",\n              since: \"1.8.0\",\n              description: \"Markdown\"\n            }, {\n              value: \"mdx\",\n              since: \"1.15.0\",\n              description: \"MDX\"\n            }, {\n              value: \"vue\",\n              since: \"1.10.0\",\n              description: \"Vue\"\n            }, {\n              value: \"yaml\",\n              since: \"1.14.0\",\n              description: \"YAML\"\n            }, {\n              value: \"glimmer\",\n              since: \"2.3.0\",\n              description: \"Ember / Handlebars\"\n            }, {\n              value: \"html\",\n              since: \"1.15.0\",\n              description: \"HTML\"\n            }, {\n              value: \"angular\",\n              since: \"1.15.0\",\n              description: \"Angular\"\n            }, {\n              value: \"lwc\",\n              since: \"1.17.0\",\n              description: \"Lightning Web Components\"\n            }]\n          },\n          plugins: {\n            since: \"1.10.0\",\n            type: \"path\",\n            array: !0,\n            default: [{\n              value: []\n            }],\n            category: o,\n            description: \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",\n            exception: m => typeof m == \"string\" || typeof m == \"object\",\n            cliName: \"plugin\",\n            cliCategory: s\n          },\n          pluginSearchDirs: {\n            since: \"1.13.0\",\n            type: \"path\",\n            array: !0,\n            default: [{\n              value: []\n            }],\n            category: o,\n            description: t(aa || (aa = Pt([\"\\n      Custom directory that contains prettier plugins in node_modules subdirectory.\\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\\n      Multiple values are accepted.\\n    \"]))),\n            exception: m => typeof m == \"string\" || typeof m == \"object\",\n            cliName: \"plugin-search-dir\",\n            cliCategory: s\n          },\n          printWidth: {\n            since: \"0.0.0\",\n            category: o,\n            type: \"int\",\n            default: 80,\n            description: \"The line length where Prettier will try wrap.\",\n            range: {\n              start: 0,\n              end: Number.POSITIVE_INFINITY,\n              step: 1\n            }\n          },\n          rangeEnd: {\n            since: \"1.4.0\",\n            category: c,\n            type: \"int\",\n            default: Number.POSITIVE_INFINITY,\n            range: {\n              start: 0,\n              end: Number.POSITIVE_INFINITY,\n              step: 1\n            },\n            description: t(oa || (oa = Pt([\"\\n      Format code ending at a given character offset (exclusive).\\n      The range will extend forwards to the end of the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]))),\n            cliCategory: a\n          },\n          rangeStart: {\n            since: \"1.4.0\",\n            category: c,\n            type: \"int\",\n            default: 0,\n            range: {\n              start: 0,\n              end: Number.POSITIVE_INFINITY,\n              step: 1\n            },\n            description: t(la || (la = Pt([\"\\n      Format code starting at a given character offset.\\n      The range will extend backwards to the start of the first line containing the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]))),\n            cliCategory: a\n          },\n          requirePragma: {\n            since: \"1.7.0\",\n            category: c,\n            type: \"boolean\",\n            default: !1,\n            description: t(ca || (ca = Pt([\"\\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\\n      in order for it to be formatted.\\n    \"]))),\n            cliCategory: u\n          },\n          tabWidth: {\n            type: \"int\",\n            category: o,\n            default: 2,\n            description: \"Number of spaces per indentation level.\",\n            range: {\n              start: 0,\n              end: Number.POSITIVE_INFINITY,\n              step: 1\n            }\n          },\n          useTabs: {\n            since: \"1.0.0\",\n            category: o,\n            type: \"boolean\",\n            default: !1,\n            description: \"Indent with tabs instead of spaces.\"\n          },\n          embeddedLanguageFormatting: {\n            since: \"2.1.0\",\n            category: o,\n            type: \"choice\",\n            default: [{\n              since: \"2.1.0\",\n              value: \"auto\"\n            }],\n            description: \"Control how Prettier formats quoted code embedded in the file.\",\n            choices: [{\n              value: \"auto\",\n              description: \"Format embedded code if Prettier can automatically identify it.\"\n            }, {\n              value: \"off\",\n              description: \"Never automatically format embedded code.\"\n            }]\n          }\n        };\n\n        n.exports = {\n          CATEGORY_CONFIG: s,\n          CATEGORY_EDITOR: a,\n          CATEGORY_FORMAT: r,\n          CATEGORY_OTHER: u,\n          CATEGORY_OUTPUT: i,\n          CATEGORY_GLOBAL: o,\n          CATEGORY_SPECIAL: c,\n          options: v\n        };\n      }\n\n    }),\n        Mn = Z({\n      \"src/main/support.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = {\n          compare: qn(),\n          lt: xD(),\n          gte: bD()\n        },\n            s = TD(),\n            a = ya().version,\n            r = ND().options;\n\n        function u() {\n          let _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n              _ref4$plugins = _ref4.plugins,\n              o = _ref4$plugins === void 0 ? [] : _ref4$plugins,\n              _ref4$showUnreleased = _ref4.showUnreleased,\n              c = _ref4$showUnreleased === void 0 ? !1 : _ref4$showUnreleased,\n              _ref4$showDeprecated = _ref4.showDeprecated,\n              v = _ref4$showDeprecated === void 0 ? !1 : _ref4$showDeprecated,\n              _ref4$showInternal = _ref4.showInternal,\n              m = _ref4$showInternal === void 0 ? !1 : _ref4$showInternal,\n              d = a.split(\"-\", 1)[0],\n              p = o.flatMap(A => A.languages || []).filter(h),\n              f = s(Object.assign({}, ...o.map(A => {\n            let S = A.options;\n            return S;\n          }), r), \"name\").filter(A => h(A) && w(A)).sort((A, S) => A.name === S.name ? 0 : A.name < S.name ? -1 : 1).map(T).map(A => {\n            A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter(B => h(B) && w(B)), A.name === \"parser\" && i(A, p, o));\n            let S = Object.fromEntries(o.filter(B => B.defaultOptions && B.defaultOptions[A.name] !== void 0).map(B => [B.name, B.defaultOptions[A.name]]));\n            return Object.assign(Object.assign({}, A), {}, {\n              pluginDefaults: S\n            });\n          });\n\n          return {\n            languages: p,\n            options: f\n          };\n\n          function h(A) {\n            return c || !(\"since\" in A) || A.since && t.gte(d, A.since);\n          }\n\n          function w(A) {\n            return v || !(\"deprecated\" in A) || A.deprecated && t.lt(d, A.deprecated);\n          }\n\n          function T(A) {\n            if (m) return A;\n            let S = A.cliName,\n                B = A.cliCategory,\n                I = A.cliDescription;\n            return kn(A, Yf);\n          }\n        }\n\n        function i(o, c, v) {\n          let m = new Set(o.choices.map(d => d.value));\n\n          for (let d of c) if (d.parsers) {\n            for (let p of d.parsers) if (!m.has(p)) {\n              m.add(p);\n              let f = v.find(w => w.parsers && w.parsers[p]),\n                  h = d.name;\n              f && f.name && (h += \" (plugin: \".concat(f.name, \")\")), o.choices.push({\n                value: p,\n                description: h\n              });\n            }\n          }\n        }\n\n        n.exports = {\n          getSupportInfo: u\n        };\n      }\n\n    }),\n        Rn = Z({\n      \"src/utils/is-non-empty-array.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s) {\n          return Array.isArray(s) && s.length > 0;\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        Nr = Z({\n      \"src/utils/text/skip.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(i) {\n          return (o, c, v) => {\n            let m = v && v.backwards;\n            if (c === !1) return !1;\n            let d = o.length,\n                p = c;\n\n            for (; p >= 0 && p < d;) {\n              let f = o.charAt(p);\n\n              if (i instanceof RegExp) {\n                if (!i.test(f)) return p;\n              } else if (!i.includes(f)) return p;\n\n              m ? p-- : p++;\n            }\n\n            return p === -1 || p === d ? p : !1;\n          };\n        }\n\n        var s = t(/\\s/),\n            a = t(\" \t\"),\n            r = t(\",; \t\"),\n            u = t(/[^\\n\\r]/);\n        n.exports = {\n          skipWhitespace: s,\n          skipSpaces: a,\n          skipToLineEnd: r,\n          skipEverythingButNewLine: u\n        };\n      }\n\n    }),\n        Sa = Z({\n      \"src/utils/text/skip-inline-comment.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a) {\n          if (a === !1) return !1;\n\n          if (s.charAt(a) === \"/\" && s.charAt(a + 1) === \"*\") {\n            for (let r = a + 2; r < s.length; ++r) if (s.charAt(r) === \"*\" && s.charAt(r + 1) === \"/\") return r + 2;\n          }\n\n          return a;\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        xa = Z({\n      \"src/utils/text/skip-trailing-comment.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Nr = Nr(),\n            t = _Nr.skipEverythingButNewLine;\n\n        function s(a, r) {\n          return r === !1 ? !1 : a.charAt(r) === \"/\" && a.charAt(r + 1) === \"/\" ? t(a, r) : r;\n        }\n\n        n.exports = s;\n      }\n\n    }),\n        ba = Z({\n      \"src/utils/text/skip-newline.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a, r) {\n          let u = r && r.backwards;\n          if (a === !1) return !1;\n          let i = s.charAt(a);\n\n          if (u) {\n            if (s.charAt(a - 1) === \"\\r\" && i === \"\\n\") return a - 2;\n            if (i === \"\\n\" || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a - 1;\n          } else {\n            if (i === \"\\r\" && s.charAt(a + 1) === \"\\n\") return a + 2;\n            if (i === \"\\n\" || i === \"\\r\" || i === \"\\u2028\" || i === \"\\u2029\") return a + 1;\n          }\n\n          return a;\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        wD = Z({\n      \"src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Sa(),\n            s = ba(),\n            a = xa(),\n            _Nr2 = Nr(),\n            r = _Nr2.skipSpaces;\n\n        function u(i, o) {\n          let c = null,\n              v = o;\n\n          for (; v !== c;) c = v, v = r(i, v), v = t(i, v), v = a(i, v), v = s(i, v);\n\n          return v;\n        }\n\n        n.exports = u;\n      }\n\n    }),\n        Ue = Z({\n      \"src/common/util.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _ref5 = (CD(), lt(Ea)),\n            t = _ref5.default,\n            s = it(),\n            _Mn = Mn(),\n            a = _Mn.getSupportInfo,\n            r = Rn(),\n            u = Ca(),\n            _Nr3 = Nr(),\n            i = _Nr3.skipWhitespace,\n            o = _Nr3.skipSpaces,\n            c = _Nr3.skipToLineEnd,\n            v = _Nr3.skipEverythingButNewLine,\n            m = Sa(),\n            d = xa(),\n            p = ba(),\n            f = wD(),\n            h = H => H[H.length - 2];\n\n        function w(H) {\n          return (R, Q, ee) => {\n            let te = ee && ee.backwards;\n            if (Q === !1) return !1;\n            let oe = R.length,\n                W = Q;\n\n            for (; W >= 0 && W < oe;) {\n              let X = R.charAt(W);\n\n              if (H instanceof RegExp) {\n                if (!H.test(X)) return W;\n              } else if (!H.includes(X)) return W;\n\n              te ? W-- : W++;\n            }\n\n            return W === -1 || W === oe ? W : !1;\n          };\n        }\n\n        function T(H, R) {\n          let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              ee = o(H, Q.backwards ? R - 1 : R, Q),\n              te = p(H, ee, Q);\n          return ee !== te;\n        }\n\n        function A(H, R, Q) {\n          for (let ee = R; ee < Q; ++ee) if (H.charAt(ee) === \"\\n\") return !0;\n\n          return !1;\n        }\n\n        function S(H, R, Q) {\n          let ee = Q(R) - 1;\n          ee = o(H, ee, {\n            backwards: !0\n          }), ee = p(H, ee, {\n            backwards: !0\n          }), ee = o(H, ee, {\n            backwards: !0\n          });\n          let te = p(H, ee, {\n            backwards: !0\n          });\n          return ee !== te;\n        }\n\n        function B(H, R) {\n          let Q = null,\n              ee = R;\n\n          for (; ee !== Q;) Q = ee, ee = c(H, ee), ee = m(H, ee), ee = o(H, ee);\n\n          return ee = d(H, ee), ee = p(H, ee), ee !== !1 && T(H, ee);\n        }\n\n        function I(H, R, Q) {\n          return B(H, Q(R));\n        }\n\n        function k(H, R, Q) {\n          return f(H, Q(R));\n        }\n\n        function P(H, R, Q) {\n          return H.charAt(k(H, R, Q));\n        }\n\n        function C(H, R) {\n          let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n          return o(H, Q.backwards ? R - 1 : R, Q) !== R;\n        }\n\n        function D(H, R) {\n          let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              ee = 0;\n\n          for (let te = Q; te < H.length; ++te) H[te] === \"\t\" ? ee = ee + R - ee % R : ee++;\n\n          return ee;\n        }\n\n        function g(H, R) {\n          let Q = H.lastIndexOf(\"\\n\");\n          return Q === -1 ? 0 : D(H.slice(Q + 1).match(/^[\\t ]*/)[0], R);\n        }\n\n        function F(H, R) {\n          let Q = {\n            quote: '\"',\n            regex: /\"/g,\n            escaped: \"&quot;\"\n          },\n              ee = {\n            quote: \"'\",\n            regex: /'/g,\n            escaped: \"&apos;\"\n          },\n              te = R === \"'\" ? ee : Q,\n              oe = te === ee ? Q : ee,\n              W = te;\n\n          if (H.includes(te.quote) || H.includes(oe.quote)) {\n            let X = (H.match(te.regex) || []).length,\n                ue = (H.match(oe.regex) || []).length;\n            W = X > ue ? oe : te;\n          }\n\n          return W;\n        }\n\n        function l(H, R) {\n          let Q = H.slice(1, -1),\n              ee = R.parser === \"json\" || R.parser === \"json5\" && R.quoteProps === \"preserve\" && !R.singleQuote ? '\"' : R.__isInHtmlAttribute ? \"'\" : F(Q, R.singleQuote ? \"'\" : '\"').quote;\n          return E(Q, ee, !(R.parser === \"css\" || R.parser === \"less\" || R.parser === \"scss\" || R.__embeddedInHtml));\n        }\n\n        function E(H, R, Q) {\n          let ee = R === '\"' ? \"'\" : '\"',\n              te = /\\\\(.)|([\"'])/gs,\n              oe = H.replace(te, (W, X, ue) => X === ee ? X : ue === R ? \"\\\\\" + ue : ue || (Q && /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(X) ? X : \"\\\\\" + X));\n          return R + oe + R;\n        }\n\n        function y(H) {\n          return H.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\").replace(/^([+-])?\\./, \"$10.\").replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\").replace(/\\.(?=e|$)/, \"\");\n        }\n\n        function N(H, R) {\n          let Q = H.match(new RegExp(\"(\".concat(t(R), \")+\"), \"g\"));\n          return Q === null ? 0 : Q.reduce((ee, te) => Math.max(ee, te.length / R.length), 0);\n        }\n\n        function x(H, R) {\n          let Q = H.match(new RegExp(\"(\".concat(t(R), \")+\"), \"g\"));\n          if (Q === null) return 0;\n          let ee = new Map(),\n              te = 0;\n\n          for (let oe of Q) {\n            let W = oe.length / R.length;\n            ee.set(W, !0), W > te && (te = W);\n          }\n\n          for (let oe = 1; oe < te; oe++) if (!ee.get(oe)) return oe;\n\n          return te + 1;\n        }\n\n        function b(H, R) {\n          (H.comments || (H.comments = [])).push(R), R.printed = !1, R.nodeDescription = Y(H);\n        }\n\n        function L(H, R) {\n          R.leading = !0, R.trailing = !1, b(H, R);\n        }\n\n        function M(H, R, Q) {\n          R.leading = !1, R.trailing = !1, Q && (R.marker = Q), b(H, R);\n        }\n\n        function j(H, R) {\n          R.leading = !1, R.trailing = !0, b(H, R);\n        }\n\n        function $(H, R) {\n          let _a3 = a({\n            plugins: R.plugins\n          }),\n              Q = _a3.languages,\n              ee = Q.find(te => {\n            let oe = te.name;\n            return oe.toLowerCase() === H;\n          }) || Q.find(te => {\n            let oe = te.aliases;\n            return Array.isArray(oe) && oe.includes(H);\n          }) || Q.find(te => {\n            let oe = te.extensions;\n            return Array.isArray(oe) && oe.includes(\".\".concat(H));\n          });\n\n          return ee && ee.parsers[0];\n        }\n\n        function V(H) {\n          return H && H.type === \"front-matter\";\n        }\n\n        function q(H) {\n          let R = new WeakMap();\n          return function (Q) {\n            return R.has(Q) || R.set(Q, Symbol(H)), R.get(Q);\n          };\n        }\n\n        function Y(H) {\n          let R = H.type || H.kind || \"(unknown type)\",\n              Q = String(H.name || H.id && (typeof H.id == \"object\" ? H.id.name : H.id) || H.key && (typeof H.key == \"object\" ? H.key.name : H.key) || H.value && (typeof H.value == \"object\" ? \"\" : String(H.value)) || H.operator || \"\");\n          return Q.length > 20 && (Q = Q.slice(0, 19) + \"\\u2026\"), R + (Q ? \" \" + Q : \"\");\n        }\n\n        n.exports = {\n          inferParserByLanguage: $,\n          getStringWidth: u,\n          getMaxContinuousCount: N,\n          getMinNotPresentContinuousCount: x,\n          getPenultimate: h,\n          getLast: s,\n          getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f,\n          getNextNonSpaceNonCommentCharacterIndex: k,\n          getNextNonSpaceNonCommentCharacter: P,\n          skip: w,\n          skipWhitespace: i,\n          skipSpaces: o,\n          skipToLineEnd: c,\n          skipEverythingButNewLine: v,\n          skipInlineComment: m,\n          skipTrailingComment: d,\n          skipNewline: p,\n          isNextLineEmptyAfterIndex: B,\n          isNextLineEmpty: I,\n          isPreviousLineEmpty: S,\n          hasNewline: T,\n          hasNewlineInRange: A,\n          hasSpaces: C,\n          getAlignmentSize: D,\n          getIndentSize: g,\n          getPreferredQuote: F,\n          printString: l,\n          printNumber: y,\n          makeString: E,\n          addLeadingComment: L,\n          addDanglingComment: M,\n          addTrailingComment: j,\n          isFrontMatterNode: V,\n          isNonEmptyArray: r,\n          createGroupIdMapper: q\n        };\n      }\n\n    }),\n        Ta = {};\n    Ut(Ta, {\n      basename: () => Pa,\n      default: () => Ia,\n      delimiter: () => Bn,\n      dirname: () => _a,\n      extname: () => ka,\n      isAbsolute: () => Wn,\n      join: () => Na,\n      normalize: () => Vn,\n      relative: () => wa,\n      resolve: () => Tr,\n      sep: () => Tn\n    });\n\n    function Ba(e, n) {\n      for (var t = 0, s = e.length - 1; s >= 0; s--) {\n        var a = e[s];\n        a === \".\" ? e.splice(s, 1) : a === \"..\" ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);\n      }\n\n      if (n) for (; t--; t) e.unshift(\"..\");\n      return e;\n    }\n\n    function Tr() {\n      for (var e = \"\", n = !1, t = arguments.length - 1; t >= -1 && !n; t--) {\n        var s = t >= 0 ? arguments[t] : \"/\";\n        if (typeof s != \"string\") throw new TypeError(\"Arguments to path.resolve must be strings\");\n        if (!s) continue;\n        e = s + \"/\" + e, n = s.charAt(0) === \"/\";\n      }\n\n      return e = Ba($n(e.split(\"/\"), function (a) {\n        return !!a;\n      }), !n).join(\"/\"), (n ? \"/\" : \"\") + e || \".\";\n    }\n\n    function Vn(e) {\n      var n = Wn(e),\n          t = La(e, -1) === \"/\";\n      return e = Ba($n(e.split(\"/\"), function (s) {\n        return !!s;\n      }), !n).join(\"/\"), !e && !n && (e = \".\"), e && t && (e += \"/\"), (n ? \"/\" : \"\") + e;\n    }\n\n    function Wn(e) {\n      return e.charAt(0) === \"/\";\n    }\n\n    function Na() {\n      var e = Array.prototype.slice.call(arguments, 0);\n      return Vn($n(e, function (n, t) {\n        if (typeof n != \"string\") throw new TypeError(\"Arguments to path.join must be strings\");\n        return n;\n      }).join(\"/\"));\n    }\n\n    function wa(e, n) {\n      e = Tr(e).substr(1), n = Tr(n).substr(1);\n\n      function t(c) {\n        for (var v = 0; v < c.length && c[v] === \"\"; v++);\n\n        for (var m = c.length - 1; m >= 0 && c[m] === \"\"; m--);\n\n        return v > m ? [] : c.slice(v, m - v + 1);\n      }\n\n      for (var s = t(e.split(\"/\")), a = t(n.split(\"/\")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++) if (s[i] !== a[i]) {\n        u = i;\n        break;\n      }\n\n      for (var o = [], i = u; i < s.length; i++) o.push(\"..\");\n\n      return o = o.concat(a.slice(u)), o.join(\"/\");\n    }\n\n    function _a(e) {\n      var n = wr(e),\n          t = n[0],\n          s = n[1];\n      return !t && !s ? \".\" : (s && (s = s.substr(0, s.length - 1)), t + s);\n    }\n\n    function Pa(e, n) {\n      var t = wr(e)[2];\n      return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;\n    }\n\n    function ka(e) {\n      return wr(e)[3];\n    }\n\n    function $n(e, n) {\n      if (e.filter) return e.filter(n);\n\n      for (var t = [], s = 0; s < e.length; s++) n(e[s], s, e) && t.push(e[s]);\n\n      return t;\n    }\n\n    var Da,\n        wr,\n        Tn,\n        Bn,\n        Ia,\n        La,\n        _D = mt({\n      \"node-modules-polyfills:path\"() {\n        re(), Da = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/, wr = function (e) {\n          return Da.exec(e).slice(1);\n        }, Tn = \"/\", Bn = \":\", Ia = {\n          extname: ka,\n          basename: Pa,\n          dirname: _a,\n          sep: Tn,\n          delimiter: Bn,\n          relative: wa,\n          join: Na,\n          isAbsolute: Wn,\n          normalize: Vn,\n          resolve: Tr\n        }, La = \"ab\".substr(-1) === \"b\" ? function (e, n, t) {\n          return e.substr(n, t);\n        } : function (e, n, t) {\n          return n < 0 && (n = e.length + n), e.substr(n, t);\n        };\n      }\n\n    }),\n        PD = Z({\n      \"node-modules-polyfills-commonjs:path\"(e, n) {\n        re();\n        var t = (_D(), lt(Ta));\n\n        if (t && t.default) {\n          n.exports = t.default;\n\n          for (let s in t) n.exports[s] = t[s];\n        } else t && (n.exports = t);\n      }\n\n    }),\n        zt = Z({\n      \"src/common/errors.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = class extends Error {},\n            s = class extends Error {},\n            a = class extends Error {},\n            r = class extends Error {};\n        n.exports = {\n          ConfigError: t,\n          DebugError: s,\n          UndefinedParserError: a,\n          ArgExpansionBailout: r\n        };\n      }\n\n    }),\n        dt = {};\n\n    Ut(dt, {\n      __assign: () => br,\n      __asyncDelegator: () => GD,\n      __asyncGenerator: () => HD,\n      __asyncValues: () => JD,\n      __await: () => Jt,\n      __awaiter: () => qD,\n      __classPrivateFieldGet: () => KD,\n      __classPrivateFieldSet: () => YD,\n      __createBinding: () => RD,\n      __decorate: () => LD,\n      __exportStar: () => VD,\n      __extends: () => kD,\n      __generator: () => MD,\n      __importDefault: () => XD,\n      __importStar: () => zD,\n      __makeTemplateObject: () => UD,\n      __metadata: () => OD,\n      __param: () => jD,\n      __read: () => ja,\n      __rest: () => ID,\n      __spread: () => WD,\n      __spreadArrays: () => $D,\n      __values: () => Nn\n    });\n\n    function kD(e, n) {\n      xr(e, n);\n\n      function t() {\n        this.constructor = e;\n      }\n\n      e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());\n    }\n\n    function ID(e, n) {\n      var t = {};\n\n      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);\n\n      if (e != null && typeof Object.getOwnPropertySymbols == \"function\") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);\n      return t;\n    }\n\n    function LD(e, n, t, s) {\n      var a = arguments.length,\n          r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s,\n          u;\n      if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\") r = Reflect.decorate(e, n, t, s);else for (var i = e.length - 1; i >= 0; i--) (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);\n      return a > 3 && r && Object.defineProperty(n, t, r), r;\n    }\n\n    function jD(e, n) {\n      return function (t, s) {\n        n(t, s, e);\n      };\n    }\n\n    function OD(e, n) {\n      if (typeof Reflect == \"object\" && typeof Reflect.metadata == \"function\") return Reflect.metadata(e, n);\n    }\n\n    function qD(e, n, t, s) {\n      function a(r) {\n        return r instanceof t ? r : new t(function (u) {\n          u(r);\n        });\n      }\n\n      return new (t || (t = Promise))(function (r, u) {\n        function i(v) {\n          try {\n            c(s.next(v));\n          } catch (m) {\n            u(m);\n          }\n        }\n\n        function o(v) {\n          try {\n            c(s.throw(v));\n          } catch (m) {\n            u(m);\n          }\n        }\n\n        function c(v) {\n          v.done ? r(v.value) : a(v.value).then(i, o);\n        }\n\n        c((s = s.apply(e, n || [])).next());\n      });\n    }\n\n    function MD(e, n) {\n      var t = {\n        label: 0,\n        sent: function () {\n          if (r[0] & 1) throw r[1];\n          return r[1];\n        },\n        trys: [],\n        ops: []\n      },\n          s,\n          a,\n          r,\n          u;\n      return u = {\n        next: i(0),\n        throw: i(1),\n        return: i(2)\n      }, typeof Symbol == \"function\" && (u[Symbol.iterator] = function () {\n        return this;\n      }), u;\n\n      function i(c) {\n        return function (v) {\n          return o([c, v]);\n        };\n      }\n\n      function o(c) {\n        if (s) throw new TypeError(\"Generator is already executing.\");\n\n        for (; t;) try {\n          if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done) return r;\n\n          switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {\n            case 0:\n            case 1:\n              r = c;\n              break;\n\n            case 4:\n              return t.label++, {\n                value: c[1],\n                done: !1\n              };\n\n            case 5:\n              t.label++, a = c[1], c = [0];\n              continue;\n\n            case 7:\n              c = t.ops.pop(), t.trys.pop();\n              continue;\n\n            default:\n              if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {\n                t = 0;\n                continue;\n              }\n\n              if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {\n                t.label = c[1];\n                break;\n              }\n\n              if (c[0] === 6 && t.label < r[1]) {\n                t.label = r[1], r = c;\n                break;\n              }\n\n              if (r && t.label < r[2]) {\n                t.label = r[2], t.ops.push(c);\n                break;\n              }\n\n              r[2] && t.ops.pop(), t.trys.pop();\n              continue;\n          }\n\n          c = n.call(e, t);\n        } catch (v) {\n          c = [6, v], a = 0;\n        } finally {\n          s = r = 0;\n        }\n\n        if (c[0] & 5) throw c[1];\n        return {\n          value: c[0] ? c[1] : void 0,\n          done: !0\n        };\n      }\n    }\n\n    function RD(e, n, t, s) {\n      s === void 0 && (s = t), e[s] = n[t];\n    }\n\n    function VD(e, n) {\n      for (var t in e) t !== \"default\" && !n.hasOwnProperty(t) && (n[t] = e[t]);\n    }\n\n    function Nn(e) {\n      var n = typeof Symbol == \"function\" && Symbol.iterator,\n          t = n && e[n],\n          s = 0;\n      if (t) return t.call(e);\n      if (e && typeof e.length == \"number\") return {\n        next: function () {\n          return e && s >= e.length && (e = void 0), {\n            value: e && e[s++],\n            done: !e\n          };\n        }\n      };\n      throw new TypeError(n ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    }\n\n    function ja(e, n) {\n      var t = typeof Symbol == \"function\" && e[Symbol.iterator];\n      if (!t) return e;\n      var s = t.call(e),\n          a,\n          r = [],\n          u;\n\n      try {\n        for (; (n === void 0 || n-- > 0) && !(a = s.next()).done;) r.push(a.value);\n      } catch (i) {\n        u = {\n          error: i\n        };\n      } finally {\n        try {\n          a && !a.done && (t = s.return) && t.call(s);\n        } finally {\n          if (u) throw u.error;\n        }\n      }\n\n      return r;\n    }\n\n    function WD() {\n      for (var e = [], n = 0; n < arguments.length; n++) e = e.concat(ja(arguments[n]));\n\n      return e;\n    }\n\n    function $D() {\n      for (var e = 0, n = 0, t = arguments.length; n < t; n++) e += arguments[n].length;\n\n      for (var s = Array(e), a = 0, n = 0; n < t; n++) for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++) s[a] = r[u];\n\n      return s;\n    }\n\n    function Jt(e) {\n      return this instanceof Jt ? (this.v = e, this) : new Jt(e);\n    }\n\n    function HD(e, n, t) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var s = t.apply(e, n || []),\n          a,\n          r = [];\n      return a = {}, u(\"next\"), u(\"throw\"), u(\"return\"), a[Symbol.asyncIterator] = function () {\n        return this;\n      }, a;\n\n      function u(d) {\n        s[d] && (a[d] = function (p) {\n          return new Promise(function (f, h) {\n            r.push([d, p, f, h]) > 1 || i(d, p);\n          });\n        });\n      }\n\n      function i(d, p) {\n        try {\n          o(s[d](p));\n        } catch (f) {\n          m(r[0][3], f);\n        }\n      }\n\n      function o(d) {\n        d.value instanceof Jt ? Promise.resolve(d.value.v).then(c, v) : m(r[0][2], d);\n      }\n\n      function c(d) {\n        i(\"next\", d);\n      }\n\n      function v(d) {\n        i(\"throw\", d);\n      }\n\n      function m(d, p) {\n        d(p), r.shift(), r.length && i(r[0][0], r[0][1]);\n      }\n    }\n\n    function GD(e) {\n      var n, t;\n      return n = {}, s(\"next\"), s(\"throw\", function (a) {\n        throw a;\n      }), s(\"return\"), n[Symbol.iterator] = function () {\n        return this;\n      }, n;\n\n      function s(a, r) {\n        n[a] = e[a] ? function (u) {\n          return (t = !t) ? {\n            value: Jt(e[a](u)),\n            done: a === \"return\"\n          } : r ? r(u) : u;\n        } : r;\n      }\n    }\n\n    function JD(e) {\n      if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n      var n = e[Symbol.asyncIterator],\n          t;\n      return n ? n.call(e) : (e = typeof Nn == \"function\" ? Nn(e) : e[Symbol.iterator](), t = {}, s(\"next\"), s(\"throw\"), s(\"return\"), t[Symbol.asyncIterator] = function () {\n        return this;\n      }, t);\n\n      function s(r) {\n        t[r] = e[r] && function (u) {\n          return new Promise(function (i, o) {\n            u = e[r](u), a(i, o, u.done, u.value);\n          });\n        };\n      }\n\n      function a(r, u, i, o) {\n        Promise.resolve(o).then(function (c) {\n          r({\n            value: c,\n            done: i\n          });\n        }, u);\n      }\n    }\n\n    function UD(e, n) {\n      return Object.defineProperty ? Object.defineProperty(e, \"raw\", {\n        value: n\n      }) : e.raw = n, e;\n    }\n\n    function zD(e) {\n      if (e && e.__esModule) return e;\n      var n = {};\n      if (e != null) for (var t in e) Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);\n      return n.default = e, n;\n    }\n\n    function XD(e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }\n\n    function KD(e, n) {\n      if (!n.has(e)) throw new TypeError(\"attempted to get private field on non-instance\");\n      return n.get(e);\n    }\n\n    function YD(e, n, t) {\n      if (!n.has(e)) throw new TypeError(\"attempted to set private field on non-instance\");\n      return n.set(e, t), t;\n    }\n\n    var xr,\n        br,\n        ht = mt({\n      \"node_modules/tslib/tslib.es6.js\"() {\n        re(), xr = function (e, n) {\n          return xr = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (t, s) {\n            t.__proto__ = s;\n          } || function (t, s) {\n            for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);\n          }, xr(e, n);\n        }, br = function () {\n          return br = Object.assign || function (n) {\n            for (var t, s = 1, a = arguments.length; s < a; s++) {\n              t = arguments[s];\n\n              for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);\n            }\n\n            return n;\n          }, br.apply(this, arguments);\n        };\n      }\n\n    }),\n        Oa = Z({\n      \"node_modules/vnopts/lib/descriptors/api.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.apiDescriptor = {\n          key: n => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n),\n\n          value(n) {\n            if (n === null || typeof n != \"object\") return JSON.stringify(n);\n            if (Array.isArray(n)) return \"[\".concat(n.map(s => e.apiDescriptor.value(s)).join(\", \"), \"]\");\n            let t = Object.keys(n);\n            return t.length === 0 ? \"{}\" : \"{ \".concat(t.map(s => \"\".concat(e.apiDescriptor.key(s), \": \").concat(e.apiDescriptor.value(n[s]))).join(\", \"), \" }\");\n          },\n\n          pair: n => {\n            let t = n.key,\n                s = n.value;\n            return e.apiDescriptor.value({\n              [t]: s\n            });\n          }\n        };\n      }\n\n    }),\n        QD = Z({\n      \"node_modules/vnopts/lib/descriptors/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n\n        n.__exportStar(Oa(), e);\n      }\n\n    }),\n        _r = Z({\n      \"scripts/build/shims/chalk.cjs\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = s => s;\n\n        t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;\n      }\n\n    }),\n        qa = Z({\n      \"node_modules/vnopts/lib/handlers/deprecated/common.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n\n        var n = _r();\n\n        e.commonDeprecatedHandler = (t, s, a) => {\n          let r = a.descriptor,\n              u = [\"\".concat(n.default.yellow(typeof t == \"string\" ? r.key(t) : r.pair(t)), \" is deprecated\")];\n          return s && u.push(\"we now treat it as \".concat(n.default.blue(typeof s == \"string\" ? r.key(s) : r.pair(s)))), u.join(\"; \") + \".\";\n        };\n      }\n\n    }),\n        ZD = Z({\n      \"node_modules/vnopts/lib/handlers/deprecated/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n\n        n.__exportStar(qa(), e);\n      }\n\n    }),\n        em = Z({\n      \"node_modules/vnopts/lib/handlers/invalid/common.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n\n        var n = _r();\n\n        e.commonInvalidHandler = (t, s, a) => [\"Invalid \".concat(n.default.red(a.descriptor.key(t)), \" value.\"), \"Expected \".concat(n.default.blue(a.schemas[t].expected(a)), \",\"), \"but received \".concat(n.default.red(a.descriptor.value(s)), \".\")].join(\" \");\n      }\n\n    }),\n        Ma = Z({\n      \"node_modules/vnopts/lib/handlers/invalid/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n\n        n.__exportStar(em(), e);\n      }\n\n    }),\n        tm = Z({\n      \"node_modules/vnopts/node_modules/leven/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = [],\n            s = [];\n\n        n.exports = function (a, r) {\n          if (a === r) return 0;\n          var u = a;\n          a.length > r.length && (a = r, r = u);\n          var i = a.length,\n              o = r.length;\n          if (i === 0) return o;\n          if (o === 0) return i;\n\n          for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-o);) i--, o--;\n\n          if (i === 0) return o;\n\n          for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c);) c++;\n\n          if (i -= c, o -= c, i === 0) return o;\n\n          for (var v, m, d, p, f = 0, h = 0; f < i;) s[c + f] = a.charCodeAt(c + f), t[f] = ++f;\n\n          for (; h < o;) for (v = r.charCodeAt(c + h), d = h++, m = h, f = 0; f < i; f++) p = v === s[c + f] ? d : d + 1, d = t[f], m = t[f] = d > m ? p > m ? m + 1 : p : p > d ? d + 1 : p;\n\n          return m;\n        };\n      }\n\n    }),\n        Ra = Z({\n      \"node_modules/vnopts/lib/handlers/unknown/leven.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n\n        var n = _r(),\n            t = tm();\n\n        e.levenUnknownHandler = (s, a, r) => {\n          let u = r.descriptor,\n              i = r.logger,\n              o = r.schemas,\n              c = [\"Ignored unknown option \".concat(n.default.yellow(u.pair({\n            key: s,\n            value: a\n          })), \".\")],\n              v = Object.keys(o).sort().find(m => t(s, m) < 3);\n          v && c.push(\"Did you mean \".concat(n.default.blue(u.key(v)), \"?\")), i.warn(c.join(\" \"));\n        };\n      }\n\n    }),\n        rm = Z({\n      \"node_modules/vnopts/lib/handlers/unknown/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n\n        n.__exportStar(Ra(), e);\n      }\n\n    }),\n        nm = Z({\n      \"node_modules/vnopts/lib/handlers/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n        n.__exportStar(ZD(), e), n.__exportStar(Ma(), e), n.__exportStar(rm(), e);\n      }\n\n    }),\n        vt = Z({\n      \"node_modules/vnopts/lib/schema.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = [\"default\", \"expected\", \"validate\", \"deprecated\", \"forward\", \"redirect\", \"overlap\", \"preprocess\", \"postprocess\"];\n\n        function t(r, u) {\n          let i = new r(u),\n              o = Object.create(i);\n\n          for (let c of n) c in u && (o[c] = a(u[c], i, s.prototype[c].length));\n\n          return o;\n        }\n\n        e.createSchema = t;\n        var s = class {\n          constructor(r) {\n            this.name = r.name;\n          }\n\n          static create(r) {\n            return t(this, r);\n          }\n\n          default(r) {}\n\n          expected(r) {\n            return \"nothing\";\n          }\n\n          validate(r, u) {\n            return !1;\n          }\n\n          deprecated(r, u) {\n            return !1;\n          }\n\n          forward(r, u) {}\n\n          redirect(r, u) {}\n\n          overlap(r, u, i) {\n            return r;\n          }\n\n          preprocess(r, u) {\n            return r;\n          }\n\n          postprocess(r, u) {\n            return r;\n          }\n\n        };\n        e.Schema = s;\n\n        function a(r, u, i) {\n          return typeof r == \"function\" ? function () {\n            for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++) c[v] = arguments[v];\n\n            return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));\n          } : () => r;\n        }\n      }\n\n    }),\n        um = Z({\n      \"node_modules/vnopts/lib/schemas/alias.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = class extends n.Schema {\n          constructor(s) {\n            super(s), this._sourceName = s.sourceName;\n          }\n\n          expected(s) {\n            return s.schemas[this._sourceName].expected(s);\n          }\n\n          validate(s, a) {\n            return a.schemas[this._sourceName].validate(s, a);\n          }\n\n          redirect(s, a) {\n            return this._sourceName;\n          }\n\n        };\n        e.AliasSchema = t;\n      }\n\n    }),\n        sm = Z({\n      \"node_modules/vnopts/lib/schemas/any.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = class extends n.Schema {\n          expected() {\n            return \"anything\";\n          }\n\n          validate() {\n            return !0;\n          }\n\n        };\n        e.AnySchema = t;\n      }\n\n    }),\n        im = Z({\n      \"node_modules/vnopts/lib/schemas/array.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt)),\n            t = vt(),\n            s = class extends t.Schema {\n          constructor(r) {\n            var u = r.valueSchema,\n                _r$name = r.name,\n                i = _r$name === void 0 ? u.name : _r$name,\n                o = n.__rest(r, [\"valueSchema\", \"name\"]);\n\n            super(Object.assign({}, o, {\n              name: i\n            })), this._valueSchema = u;\n          }\n\n          expected(r) {\n            return \"an array of \".concat(this._valueSchema.expected(r));\n          }\n\n          validate(r, u) {\n            if (!Array.isArray(r)) return !1;\n            let i = [];\n\n            for (let o of r) {\n              let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);\n              c !== !0 && i.push(c.value);\n            }\n\n            return i.length === 0 ? !0 : {\n              value: i\n            };\n          }\n\n          deprecated(r, u) {\n            let i = [];\n\n            for (let o of r) {\n              let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);\n              c !== !1 && i.push(...c.map(v => {\n                let m = v.value;\n                return {\n                  value: [m]\n                };\n              }));\n            }\n\n            return i;\n          }\n\n          forward(r, u) {\n            let i = [];\n\n            for (let o of r) {\n              let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);\n              i.push(...c.map(a));\n            }\n\n            return i;\n          }\n\n          redirect(r, u) {\n            let i = [],\n                o = [];\n\n            for (let c of r) {\n              let v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);\n              \"remain\" in v && i.push(v.remain), o.push(...v.redirect.map(a));\n            }\n\n            return i.length === 0 ? {\n              redirect: o\n            } : {\n              redirect: o,\n              remain: i\n            };\n          }\n\n          overlap(r, u) {\n            return r.concat(u);\n          }\n\n        };\n        e.ArraySchema = s;\n\n        function a(r) {\n          let u = r.from,\n              i = r.to;\n          return {\n            from: [u],\n            to: i\n          };\n        }\n      }\n\n    }),\n        am = Z({\n      \"node_modules/vnopts/lib/schemas/boolean.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = class extends n.Schema {\n          expected() {\n            return \"true or false\";\n          }\n\n          validate(s) {\n            return typeof s == \"boolean\";\n          }\n\n        };\n        e.BooleanSchema = t;\n      }\n\n    }),\n        Hn = Z({\n      \"node_modules/vnopts/lib/utils.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n\n        function n(p, f) {\n          let h = Object.create(null);\n\n          for (let w of p) {\n            let T = w[f];\n            if (h[T]) throw new Error(\"Duplicate \".concat(f, \" \").concat(JSON.stringify(T)));\n            h[T] = w;\n          }\n\n          return h;\n        }\n\n        e.recordFromArray = n;\n\n        function t(p, f) {\n          let h = new Map();\n\n          for (let w of p) {\n            let T = w[f];\n            if (h.has(T)) throw new Error(\"Duplicate \".concat(f, \" \").concat(JSON.stringify(T)));\n            h.set(T, w);\n          }\n\n          return h;\n        }\n\n        e.mapFromArray = t;\n\n        function s() {\n          let p = Object.create(null);\n          return f => {\n            let h = JSON.stringify(f);\n            return p[h] ? !0 : (p[h] = !0, !1);\n          };\n        }\n\n        e.createAutoChecklist = s;\n\n        function a(p, f) {\n          let h = [],\n              w = [];\n\n          for (let T of p) f(T) ? h.push(T) : w.push(T);\n\n          return [h, w];\n        }\n\n        e.partition = a;\n\n        function r(p) {\n          return p === Math.floor(p);\n        }\n\n        e.isInt = r;\n\n        function u(p, f) {\n          if (p === f) return 0;\n          let h = typeof p,\n              w = typeof f,\n              T = [\"undefined\", \"object\", \"boolean\", \"number\", \"string\"];\n          return h !== w ? T.indexOf(h) - T.indexOf(w) : h !== \"string\" ? Number(p) - Number(f) : p.localeCompare(f);\n        }\n\n        e.comparePrimitive = u;\n\n        function i(p) {\n          return p === void 0 ? {} : p;\n        }\n\n        e.normalizeDefaultResult = i;\n\n        function o(p, f) {\n          return p === !0 ? !0 : p === !1 ? {\n            value: f\n          } : p;\n        }\n\n        e.normalizeValidateResult = o;\n\n        function c(p, f) {\n          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n          return p === !1 ? !1 : p === !0 ? h ? !0 : [{\n            value: f\n          }] : \"value\" in p ? [p] : p.length === 0 ? !1 : p;\n        }\n\n        e.normalizeDeprecatedResult = c;\n\n        function v(p, f) {\n          return typeof p == \"string\" || \"key\" in p ? {\n            from: f,\n            to: p\n          } : \"from\" in p ? {\n            from: p.from,\n            to: p.to\n          } : {\n            from: f,\n            to: p.to\n          };\n        }\n\n        e.normalizeTransferResult = v;\n\n        function m(p, f) {\n          return p === void 0 ? [] : Array.isArray(p) ? p.map(h => v(h, f)) : [v(p, f)];\n        }\n\n        e.normalizeForwardResult = m;\n\n        function d(p, f) {\n          let h = m(typeof p == \"object\" && \"redirect\" in p ? p.redirect : p, f);\n          return h.length === 0 ? {\n            remain: f,\n            redirect: h\n          } : typeof p == \"object\" && \"remain\" in p ? {\n            remain: p.remain,\n            redirect: h\n          } : {\n            redirect: h\n          };\n        }\n\n        e.normalizeRedirectResult = d;\n      }\n\n    }),\n        om = Z({\n      \"node_modules/vnopts/lib/schemas/choice.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = Hn(),\n            s = class extends n.Schema {\n          constructor(a) {\n            super(a), this._choices = t.mapFromArray(a.choices.map(r => r && typeof r == \"object\" ? r : {\n              value: r\n            }), \"value\");\n          }\n\n          expected(a) {\n            let r = a.descriptor,\n                u = Array.from(this._choices.keys()).map(c => this._choices.get(c)).filter(c => !c.deprecated).map(c => c.value).sort(t.comparePrimitive).map(r.value),\n                i = u.slice(0, -2),\n                o = u.slice(-2);\n            return i.concat(o.join(\" or \")).join(\", \");\n          }\n\n          validate(a) {\n            return this._choices.has(a);\n          }\n\n          deprecated(a) {\n            let r = this._choices.get(a);\n\n            return r && r.deprecated ? {\n              value: a\n            } : !1;\n          }\n\n          forward(a) {\n            let r = this._choices.get(a);\n\n            return r ? r.forward : void 0;\n          }\n\n          redirect(a) {\n            let r = this._choices.get(a);\n\n            return r ? r.redirect : void 0;\n          }\n\n        };\n        e.ChoiceSchema = s;\n      }\n\n    }),\n        Va = Z({\n      \"node_modules/vnopts/lib/schemas/number.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = class extends n.Schema {\n          expected() {\n            return \"a number\";\n          }\n\n          validate(s, a) {\n            return typeof s == \"number\";\n          }\n\n        };\n        e.NumberSchema = t;\n      }\n\n    }),\n        lm = Z({\n      \"node_modules/vnopts/lib/schemas/integer.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = Hn(),\n            t = Va(),\n            s = class extends t.NumberSchema {\n          expected() {\n            return \"an integer\";\n          }\n\n          validate(a, r) {\n            return r.normalizeValidateResult(super.validate(a, r), a) === !0 && n.isInt(a);\n          }\n\n        };\n        e.IntegerSchema = s;\n      }\n\n    }),\n        cm = Z({\n      \"node_modules/vnopts/lib/schemas/string.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = vt(),\n            t = class extends n.Schema {\n          expected() {\n            return \"a string\";\n          }\n\n          validate(s) {\n            return typeof s == \"string\";\n          }\n\n        };\n        e.StringSchema = t;\n      }\n\n    }),\n        pm = Z({\n      \"node_modules/vnopts/lib/schemas/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n        n.__exportStar(um(), e), n.__exportStar(sm(), e), n.__exportStar(im(), e), n.__exportStar(am(), e), n.__exportStar(om(), e), n.__exportStar(lm(), e), n.__exportStar(Va(), e), n.__exportStar(cm(), e);\n      }\n\n    }),\n        fm = Z({\n      \"node_modules/vnopts/lib/defaults.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = Oa(),\n            t = qa(),\n            s = Ma(),\n            a = Ra();\n        e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;\n      }\n\n    }),\n        Dm = Z({\n      \"node_modules/vnopts/lib/normalize.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = fm(),\n            t = Hn();\n\n        e.normalize = (a, r, u) => new s(r, u).normalize(a);\n\n        var s = class {\n          constructor(a, r) {\n            let _ref6 = r || {},\n                _ref6$logger = _ref6.logger,\n                u = _ref6$logger === void 0 ? console : _ref6$logger,\n                _ref6$descriptor = _ref6.descriptor,\n                i = _ref6$descriptor === void 0 ? n.defaultDescriptor : _ref6$descriptor,\n                _ref6$unknown = _ref6.unknown,\n                o = _ref6$unknown === void 0 ? n.defaultUnknownHandler : _ref6$unknown,\n                _ref6$invalid = _ref6.invalid,\n                c = _ref6$invalid === void 0 ? n.defaultInvalidHandler : _ref6$invalid,\n                _ref6$deprecated = _ref6.deprecated,\n                v = _ref6$deprecated === void 0 ? n.defaultDeprecatedHandler : _ref6$deprecated;\n\n            this._utils = {\n              descriptor: i,\n              logger: u || {\n                warn: () => {}\n              },\n              schemas: t.recordFromArray(a, \"name\"),\n              normalizeDefaultResult: t.normalizeDefaultResult,\n              normalizeDeprecatedResult: t.normalizeDeprecatedResult,\n              normalizeForwardResult: t.normalizeForwardResult,\n              normalizeRedirectResult: t.normalizeRedirectResult,\n              normalizeValidateResult: t.normalizeValidateResult\n            }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();\n          }\n\n          cleanHistory() {\n            this._hasDeprecationWarned = t.createAutoChecklist();\n          }\n\n          normalize(a) {\n            let r = {},\n                u = [a],\n                i = () => {\n              for (; u.length !== 0;) {\n                let o = u.shift(),\n                    c = this._applyNormalization(o, r);\n\n                u.push(...c);\n              }\n            };\n\n            i();\n\n            for (let o of Object.keys(this._utils.schemas)) {\n              let c = this._utils.schemas[o];\n\n              if (!(o in r)) {\n                let v = t.normalizeDefaultResult(c.default(this._utils));\n                \"value\" in v && u.push({\n                  [o]: v.value\n                });\n              }\n            }\n\n            i();\n\n            for (let o of Object.keys(this._utils.schemas)) {\n              let c = this._utils.schemas[o];\n              o in r && (r[o] = c.postprocess(r[o], this._utils));\n            }\n\n            return r;\n          }\n\n          _applyNormalization(a, r) {\n            let u = [],\n                _t$partition = t.partition(Object.keys(a), c => c in this._utils.schemas),\n                _t$partition2 = _slicedToArray(_t$partition, 2),\n                i = _t$partition2[0],\n                o = _t$partition2[1];\n\n            for (let c of i) {\n              let v = this._utils.schemas[c],\n                  m = v.preprocess(a[c], this._utils),\n                  d = t.normalizeValidateResult(v.validate(m, this._utils), m);\n\n              if (d !== !0) {\n                let T = d.value,\n                    A = this._invalidHandler(c, T, this._utils);\n\n                throw typeof A == \"string\" ? new Error(A) : A;\n              }\n\n              let p = T => {\n                let A = T.from,\n                    S = T.to;\n                u.push(typeof S == \"string\" ? {\n                  [S]: A\n                } : {\n                  [S.key]: S.value\n                });\n              },\n                  f = T => {\n                let A = T.value,\n                    S = T.redirectTo,\n                    B = t.normalizeDeprecatedResult(v.deprecated(A, this._utils), m, !0);\n                if (B !== !1) if (B === !0) this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S, this._utils));else for (let _ref7 of B) {\n                  let I = _ref7.value;\n                  let k = {\n                    key: c,\n                    value: I\n                  };\n\n                  if (!this._hasDeprecationWarned(k)) {\n                    let P = typeof S == \"string\" ? {\n                      key: S,\n                      value: I\n                    } : S;\n\n                    this._utils.logger.warn(this._deprecatedHandler(k, P, this._utils));\n                  }\n                }\n              };\n\n              t.normalizeForwardResult(v.forward(m, this._utils), m).forEach(p);\n              let w = t.normalizeRedirectResult(v.redirect(m, this._utils), m);\n\n              if (w.redirect.forEach(p), \"remain\" in w) {\n                let T = w.remain;\n                r[c] = c in r ? v.overlap(r[c], T, this._utils) : T, f({\n                  value: T\n                });\n              }\n\n              for (let _ref8 of w.redirect) {\n                let T = _ref8.from;\n                let A = _ref8.to;\n                f({\n                  value: T,\n                  redirectTo: A\n                });\n              }\n            }\n\n            for (let c of o) {\n              let v = a[c],\n                  m = this._unknownHandler(c, v, this._utils);\n\n              if (m) for (let d of Object.keys(m)) {\n                let p = {\n                  [d]: m[d]\n                };\n                d in this._utils.schemas ? u.push(p) : Object.assign(r, p);\n              }\n            }\n\n            return u;\n          }\n\n        };\n        e.Normalizer = s;\n      }\n\n    }),\n        mm = Z({\n      \"node_modules/vnopts/lib/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = (ht(), lt(dt));\n        n.__exportStar(QD(), e), n.__exportStar(nm(), e), n.__exportStar(pm(), e), n.__exportStar(Dm(), e), n.__exportStar(vt(), e);\n      }\n\n    }),\n        dm = Z({\n      \"src/main/options-normalizer.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = mm(),\n            s = it(),\n            a = {\n          key: d => d.length === 1 ? \"-\".concat(d) : \"--\".concat(d),\n          value: d => t.apiDescriptor.value(d),\n          pair: d => {\n            let p = d.key,\n                f = d.value;\n            return f === !1 ? \"--no-\".concat(p) : f === !0 ? a.key(p) : f === \"\" ? \"\".concat(a.key(p), \" without an argument\") : \"\".concat(a.key(p), \"=\").concat(f);\n          }\n        },\n            r = d => {\n          let p = d.colorsModule,\n              f = d.levenshteinDistance;\n          return class extends t.ChoiceSchema {\n            constructor(w) {\n              let T = w.name,\n                  A = w.flags;\n              super({\n                name: T,\n                choices: A\n              }), this._flags = [...A].sort();\n            }\n\n            preprocess(w, T) {\n              if (typeof w == \"string\" && w.length > 0 && !this._flags.includes(w)) {\n                let A = this._flags.find(S => f(S, w) < 3);\n\n                if (A) return T.logger.warn([\"Unknown flag \".concat(p.yellow(T.descriptor.value(w)), \",\"), \"did you mean \".concat(p.blue(T.descriptor.value(A)), \"?\")].join(\" \")), A;\n              }\n\n              return w;\n            }\n\n            expected() {\n              return \"a flag\";\n            }\n\n          };\n        },\n            u;\n\n        function i(d, p) {\n          let _ref9 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              _ref9$logger = _ref9.logger,\n              f = _ref9$logger === void 0 ? !1 : _ref9$logger,\n              _ref9$isCLI = _ref9.isCLI,\n              h = _ref9$isCLI === void 0 ? !1 : _ref9$isCLI,\n              _ref9$passThrough = _ref9.passThrough,\n              w = _ref9$passThrough === void 0 ? !1 : _ref9$passThrough,\n              _ref9$colorsModule = _ref9.colorsModule,\n              T = _ref9$colorsModule === void 0 ? null : _ref9$colorsModule,\n              _ref9$levenshteinDist = _ref9.levenshteinDistance,\n              A = _ref9$levenshteinDist === void 0 ? null : _ref9$levenshteinDist,\n              S = w ? Array.isArray(w) ? (D, g) => w.includes(D) ? {\n            [D]: g\n          } : void 0 : (D, g) => ({\n            [D]: g\n          }) : (D, g, F) => {\n            let l = F.schemas,\n                E = l._,\n                y = kn(l, Qf);\n            return t.levenUnknownHandler(D, g, Object.assign(Object.assign({}, F), {}, {\n              schemas: y\n            }));\n          },\n              B = h ? a : t.apiDescriptor,\n              I = o(p, {\n            isCLI: h,\n            colorsModule: T,\n            levenshteinDistance: A\n          }),\n              k = new t.Normalizer(I, {\n            logger: f,\n            unknown: S,\n            descriptor: B\n          }),\n              P = f !== !1;\n\n          P && u && (k._hasDeprecationWarned = u);\n          let C = k.normalize(d);\n          return P && (u = k._hasDeprecationWarned), h && C[\"plugin-search\"] === !1 && (C[\"plugin-search-dir\"] = !1), C;\n        }\n\n        function o(d, p) {\n          let f = p.isCLI,\n              h = p.colorsModule,\n              w = p.levenshteinDistance,\n              T = [];\n          f && T.push(t.AnySchema.create({\n            name: \"_\"\n          }));\n\n          for (let A of d) T.push(c(A, {\n            isCLI: f,\n            optionInfos: d,\n            colorsModule: h,\n            levenshteinDistance: w\n          })), A.alias && f && T.push(t.AliasSchema.create({\n            name: A.alias,\n            sourceName: A.name\n          }));\n\n          return T;\n        }\n\n        function c(d, p) {\n          let f = p.isCLI,\n              h = p.optionInfos,\n              w = p.colorsModule,\n              T = p.levenshteinDistance,\n              A = d.name;\n          if (A === \"plugin-search-dir\" || A === \"pluginSearchDirs\") return t.AnySchema.create({\n            name: A,\n\n            preprocess(k) {\n              return k === !1 || (k = Array.isArray(k) ? k : [k]), k;\n            },\n\n            validate(k) {\n              return k === !1 ? !0 : k.every(P => typeof P == \"string\");\n            },\n\n            expected() {\n              return \"false or paths to plugin search dir\";\n            }\n\n          });\n          let S = {\n            name: A\n          },\n              B,\n              I = {};\n\n          switch (d.type) {\n            case \"int\":\n              B = t.IntegerSchema, f && (S.preprocess = Number);\n              break;\n\n            case \"string\":\n              B = t.StringSchema;\n              break;\n\n            case \"choice\":\n              B = t.ChoiceSchema, S.choices = d.choices.map(k => typeof k == \"object\" && k.redirect ? Object.assign(Object.assign({}, k), {}, {\n                redirect: {\n                  to: {\n                    key: d.name,\n                    value: k.redirect\n                  }\n                }\n              }) : k);\n              break;\n\n            case \"boolean\":\n              B = t.BooleanSchema;\n              break;\n\n            case \"flag\":\n              B = r({\n                colorsModule: w,\n                levenshteinDistance: T\n              }), S.flags = h.flatMap(k => [k.alias, k.description && k.name, k.oppositeDescription && \"no-\".concat(k.name)].filter(Boolean));\n              break;\n\n            case \"path\":\n              B = t.StringSchema;\n              break;\n\n            default:\n              throw new Error(\"Unexpected type \".concat(d.type));\n          }\n\n          if (d.exception ? S.validate = (k, P, C) => d.exception(k) || P.validate(k, C) : S.validate = (k, P, C) => k === void 0 || P.validate(k, C), d.redirect && (I.redirect = k => k ? {\n            to: {\n              key: d.redirect.option,\n              value: d.redirect.value\n            }\n          } : void 0), d.deprecated && (I.deprecated = !0), f && !d.array) {\n            let k = S.preprocess || (P => P);\n\n            S.preprocess = (P, C, D) => C.preprocess(k(Array.isArray(P) ? s(P) : P), D);\n          }\n\n          return d.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? {\n            preprocess: k => Array.isArray(k) ? k : [k]\n          } : {}), I), {}, {\n            valueSchema: B.create(S)\n          })) : B.create(Object.assign(Object.assign({}, S), I));\n        }\n\n        function v(d, p, f) {\n          return i(d, p, f);\n        }\n\n        function m(d, p, f) {\n          return i(d, p, Object.assign({\n            isCLI: !0\n          }, f));\n        }\n\n        n.exports = {\n          normalizeApiOptions: v,\n          normalizeCliOptions: m\n        };\n      }\n\n    }),\n        st = Z({\n      \"src/language-js/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Rn();\n\n        function s(o, c) {\n          let _ref10 = c || {},\n              v = _ref10.ignoreDecorators;\n\n          if (!v) {\n            let m = o.declaration && o.declaration.decorators || o.decorators;\n            if (t(m)) return s(m[0]);\n          }\n\n          return o.range ? o.range[0] : o.start;\n        }\n\n        function a(o) {\n          return o.range ? o.range[1] : o.end;\n        }\n\n        function r(o, c) {\n          let v = s(o);\n          return Number.isInteger(v) && v === s(c);\n        }\n\n        function u(o, c) {\n          let v = a(o);\n          return Number.isInteger(v) && v === a(c);\n        }\n\n        function i(o, c) {\n          return r(o, c) && u(o, c);\n        }\n\n        n.exports = {\n          locStart: s,\n          locEnd: a,\n          hasSameLocStart: r,\n          hasSameLoc: i\n        };\n      }\n\n    }),\n        gm = Z({\n      \"src/main/load-parser.js\"(e, n) {\n        re(), n.exports = () => {};\n      }\n\n    }),\n        ym = Z({\n      \"scripts/build/shims/babel-highlight.cjs\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = _r(),\n            s = {\n          shouldHighlight: () => !1,\n          getChalk: () => t\n        };\n\n        n.exports = s;\n      }\n\n    }),\n        hm = Z({\n      \"node_modules/@babel/code-frame/lib/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.codeFrameColumns = u, e.default = i;\n        var n = ym(),\n            t = !1;\n\n        function s(o) {\n          return {\n            gutter: o.grey,\n            marker: o.red.bold,\n            message: o.red.bold\n          };\n        }\n\n        var a = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n        function r(o, c, v) {\n          let m = Object.assign({\n            column: 0,\n            line: -1\n          }, o.start),\n              d = Object.assign({}, m, o.end),\n              _ref11 = v || {},\n              _ref11$linesAbove = _ref11.linesAbove,\n              p = _ref11$linesAbove === void 0 ? 2 : _ref11$linesAbove,\n              _ref11$linesBelow = _ref11.linesBelow,\n              f = _ref11$linesBelow === void 0 ? 3 : _ref11$linesBelow,\n              h = m.line,\n              w = m.column,\n              T = d.line,\n              A = d.column,\n              S = Math.max(h - (p + 1), 0),\n              B = Math.min(c.length, T + f);\n\n          h === -1 && (S = 0), T === -1 && (B = c.length);\n          let I = T - h,\n              k = {};\n          if (I) for (let P = 0; P <= I; P++) {\n            let C = P + h;\n            if (!w) k[C] = !0;else if (P === 0) {\n              let D = c[C - 1].length;\n              k[C] = [w, D - w + 1];\n            } else if (P === I) k[C] = [0, A];else {\n              let D = c[C - P].length;\n              k[C] = [0, D];\n            }\n          } else w === A ? w ? k[h] = [w, 0] : k[h] = !0 : k[h] = [w, A - w];\n          return {\n            start: S,\n            end: B,\n            markerLines: k\n          };\n        }\n\n        function u(o, c) {\n          let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},\n              m = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v),\n              d = (0, n.getChalk)(v),\n              p = s(d),\n              f = (P, C) => m ? P(C) : C,\n              h = o.split(a),\n              _r2 = r(c, h, v),\n              w = _r2.start,\n              T = _r2.end,\n              A = _r2.markerLines,\n              S = c.start && typeof c.start.column == \"number\",\n              B = String(T).length,\n              k = (m ? (0, n.default)(o, v) : o).split(a, T).slice(w, T).map((P, C) => {\n            let D = w + 1 + C,\n                g = \" \".concat(D).slice(-B),\n                F = \" \".concat(g, \" |\"),\n                l = A[D],\n                E = !A[D + 1];\n\n            if (l) {\n              let y = \"\";\n\n              if (Array.isArray(l)) {\n                let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\\t]/g, \" \"),\n                    x = l[1] || 1;\n                y = [\"\\n \", f(p.gutter, F.replace(/\\d/g, \" \")), \" \", N, f(p.marker, \"^\").repeat(x)].join(\"\"), E && v.message && (y += \" \" + f(p.message, v.message));\n              }\n\n              return [f(p.marker, \">\"), f(p.gutter, F), P.length > 0 ? \" \".concat(P) : \"\", y].join(\"\");\n            } else return \" \".concat(f(p.gutter, F)).concat(P.length > 0 ? \" \".concat(P) : \"\");\n          }).join(\"\\n\");\n\n          return v.message && !S && (k = \"\".concat(\" \".repeat(B + 1)).concat(v.message, \"\\n\").concat(k)), m ? d.reset(k) : k;\n        }\n\n        function i(o, c, v) {\n          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n\n          if (!t) {\n            t = !0;\n            let p = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n            if (Tt.emitWarning) Tt.emitWarning(p, \"DeprecationWarning\");else {\n              let f = new Error(p);\n              f.name = \"DeprecationWarning\", console.warn(new Error(p));\n            }\n          }\n\n          return v = Math.max(v, 0), u(o, {\n            start: {\n              column: v,\n              line: c\n            }\n          }, m);\n        }\n      }\n\n    }),\n        Gn = Z({\n      \"src/main/parser.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _zt = zt(),\n            t = _zt.ConfigError,\n            s = st(),\n            a = gm(),\n            r = s.locStart,\n            u = s.locEnd,\n            i = Object.getOwnPropertyNames,\n            o = Object.getOwnPropertyDescriptor;\n\n        function c(d) {\n          let p = {};\n\n          for (let f of d.plugins) if (!!f.parsers) for (let h of i(f.parsers)) Object.defineProperty(p, h, o(f.parsers, h));\n\n          return p;\n        }\n\n        function v(d) {\n          let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d);\n          if (typeof d.parser == \"function\") return {\n            parse: d.parser,\n            astFormat: \"estree\",\n            locStart: r,\n            locEnd: u\n          };\n\n          if (typeof d.parser == \"string\") {\n            if (Object.prototype.hasOwnProperty.call(p, d.parser)) return p[d.parser];\n            throw new t(\"Couldn't resolve parser \\\"\".concat(d.parser, '\". Parsers must be explicitly added to the standalone bundle.'));\n          }\n        }\n\n        function m(d, p) {\n          let f = c(p),\n              h = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map(T => [T, {\n            enumerable: !0,\n\n            get() {\n              return f[T].parse;\n            }\n\n          }]))),\n              w = v(p, f);\n\n          try {\n            return w.preprocess && (d = w.preprocess(d, p)), {\n              text: d,\n              ast: w.parse(d, h, p)\n            };\n          } catch (T) {\n            let A = T.loc;\n\n            if (A) {\n              let _hm = hm(),\n                  S = _hm.codeFrameColumns;\n\n              throw T.codeFrame = S(d, A, {\n                highlightCode: !0\n              }), T.message += \"\\n\" + T.codeFrame, T;\n            }\n\n            throw T.stack;\n          }\n        }\n\n        n.exports = {\n          parse: m,\n          resolveParser: v\n        };\n      }\n\n    }),\n        Wa = Z({\n      \"src/main/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = PD(),\n            _zt2 = zt(),\n            s = _zt2.UndefinedParserError,\n            _Mn2 = Mn(),\n            a = _Mn2.getSupportInfo,\n            r = dm(),\n            _Gn = Gn(),\n            u = _Gn.resolveParser,\n            i = {\n          astFormat: \"estree\",\n          printer: {},\n          originalText: void 0,\n          locStart: null,\n          locEnd: null\n        };\n\n        function o(m) {\n          let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},\n              p = Object.assign({}, m),\n              f = a({\n            plugins: m.plugins,\n            showUnreleased: !0,\n            showDeprecated: !0\n          }).options,\n              h = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter(B => B.default !== void 0).map(B => [B.name, B.default])));\n\n          if (!p.parser) {\n            if (!p.filepath) (d.logger || console).warn(\"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.\"), p.parser = \"babel\";else if (p.parser = v(p.filepath, p.plugins), !p.parser) throw new s(\"No parser could be inferred for file: \".concat(p.filepath));\n          }\n\n          let w = u(r.normalizeApiOptions(p, [f.find(B => B.name === \"parser\")], {\n            passThrough: !0,\n            logger: !1\n          }));\n          p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;\n          let T = c(p);\n          p.printer = T.printers[p.astFormat];\n          let A = Object.fromEntries(f.filter(B => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map(B => [B.name, B.pluginDefaults[T.name]])),\n              S = Object.assign(Object.assign({}, h), A);\n\n          for (let _ref12 of Object.entries(S)) {\n            var _ref13 = _slicedToArray(_ref12, 2);\n\n            let B = _ref13[0];\n            let I = _ref13[1];\n            (p[B] === null || p[B] === void 0) && (p[B] = I);\n          }\n\n          return p.parser === \"json\" && (p.trailingComma = \"none\"), r.normalizeApiOptions(p, f, Object.assign({\n            passThrough: Object.keys(i)\n          }, d));\n        }\n\n        function c(m) {\n          let d = m.astFormat;\n          if (!d) throw new Error(\"getPlugin() requires astFormat to be set\");\n          let p = m.plugins.find(f => f.printers && f.printers[d]);\n          if (!p) throw new Error(\"Couldn't find plugin for AST format \\\"\".concat(d, '\"'));\n          return p;\n        }\n\n        function v(m, d) {\n          let p = t.basename(m).toLowerCase(),\n              h = a({\n            plugins: d\n          }).languages.filter(w => w.since !== null).find(w => w.extensions && w.extensions.some(T => p.endsWith(T)) || w.filenames && w.filenames.some(T => T.toLowerCase() === p));\n          return h && h.parsers[0];\n        }\n\n        n.exports = {\n          normalize: o,\n          hiddenDefaults: i,\n          inferParser: v\n        };\n      }\n\n    }),\n        vm = Z({\n      \"src/main/massage-ast.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a, r) {\n          if (Array.isArray(s)) return s.map(c => t(c, a, r)).filter(Boolean);\n          if (!s || typeof s != \"object\") return s;\n          let u = a.printer.massageAstNode,\n              i;\n          u && u.ignoredProperties ? i = u.ignoredProperties : i = new Set();\n          let o = {};\n\n          for (let _ref14 of Object.entries(s)) {\n            var _ref15 = _slicedToArray(_ref14, 2);\n\n            let c = _ref15[0];\n            let v = _ref15[1];\n            !i.has(c) && typeof v != \"function\" && (o[c] = t(v, a, s));\n          }\n\n          if (u) {\n            let c = u(s, o, r);\n            if (c === null) return;\n            if (c) return c;\n          }\n\n          return o;\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        Xt = Z({\n      \"scripts/build/shims/assert.cjs\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = () => {};\n\n        t.ok = t, t.strictEqual = t, n.exports = t;\n      }\n\n    }),\n        et = Z({\n      \"src/main/comments.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Xt(),\n            _Oe = Oe(),\n            _Oe$builders = _Oe.builders,\n            s = _Oe$builders.line,\n            a = _Oe$builders.hardline,\n            r = _Oe$builders.breakParent,\n            u = _Oe$builders.indent,\n            i = _Oe$builders.lineSuffix,\n            o = _Oe$builders.join,\n            c = _Oe$builders.cursor,\n            _Ue = Ue(),\n            v = _Ue.hasNewline,\n            m = _Ue.skipNewline,\n            d = _Ue.skipSpaces,\n            p = _Ue.isPreviousLineEmpty,\n            f = _Ue.addLeadingComment,\n            h = _Ue.addDanglingComment,\n            w = _Ue.addTrailingComment,\n            T = new WeakMap();\n\n        function A(L, M, j) {\n          if (!L) return;\n          let $ = M.printer,\n              V = M.locStart,\n              q = M.locEnd;\n\n          if (j) {\n            if ($.canAttachComment && $.canAttachComment(L)) {\n              let H;\n\n              for (H = j.length - 1; H >= 0 && !(V(j[H]) <= V(L) && q(j[H]) <= q(L)); --H);\n\n              j.splice(H + 1, 0, L);\n              return;\n            }\n          } else if (T.has(L)) return T.get(L);\n\n          let Y = $.getCommentChildNodes && $.getCommentChildNodes(L, M) || typeof L == \"object\" && Object.entries(L).filter(H => {\n            let _H = _slicedToArray(H, 1),\n                R = _H[0];\n\n            return R !== \"enclosingNode\" && R !== \"precedingNode\" && R !== \"followingNode\" && R !== \"tokens\" && R !== \"comments\" && R !== \"parent\";\n          }).map(H => {\n            let _H2 = _slicedToArray(H, 2),\n                R = _H2[1];\n\n            return R;\n          });\n\n          if (!!Y) {\n            j || (j = [], T.set(L, j));\n\n            for (let H of Y) A(H, M, j);\n\n            return j;\n          }\n        }\n\n        function S(L, M, j, $) {\n          let V = j.locStart,\n              q = j.locEnd,\n              Y = V(M),\n              H = q(M),\n              R = A(L, j),\n              Q,\n              ee,\n              te = 0,\n              oe = R.length;\n\n          for (; te < oe;) {\n            let W = te + oe >> 1,\n                X = R[W],\n                ue = V(X),\n                De = q(X);\n            if (ue <= Y && H <= De) return S(X, M, j, X);\n\n            if (De <= Y) {\n              Q = X, te = W + 1;\n              continue;\n            }\n\n            if (H <= ue) {\n              ee = X, oe = W;\n              continue;\n            }\n\n            throw new Error(\"Comment location overlaps with node location\");\n          }\n\n          if ($ && $.type === \"TemplateLiteral\") {\n            let W = $.quasis,\n                X = F(W, M, j);\n            Q && F(W, Q, j) !== X && (Q = null), ee && F(W, ee, j) !== X && (ee = null);\n          }\n\n          return {\n            enclosingNode: $,\n            precedingNode: Q,\n            followingNode: ee\n          };\n        }\n\n        var B = () => !1;\n\n        function I(L, M, j, $) {\n          if (!Array.isArray(L)) return;\n          let V = [],\n              q = $.locStart,\n              Y = $.locEnd,\n              _$$printer$handleComm = $.printer.handleComments,\n              H = _$$printer$handleComm === void 0 ? {} : _$$printer$handleComm,\n              R = H.avoidAstMutation,\n              _H$ownLine = H.ownLine,\n              Q = _H$ownLine === void 0 ? B : _H$ownLine,\n              _H$endOfLine = H.endOfLine,\n              ee = _H$endOfLine === void 0 ? B : _H$endOfLine,\n              _H$remaining = H.remaining,\n              te = _H$remaining === void 0 ? B : _H$remaining,\n              oe = L.map((W, X) => Object.assign(Object.assign({}, S(M, W, $)), {}, {\n            comment: W,\n            text: j,\n            options: $,\n            ast: M,\n            isLastComment: L.length - 1 === X\n          }));\n\n          for (let _ref16 of oe.entries()) {\n            var _ref17 = _slicedToArray(_ref16, 2);\n\n            let W = _ref17[0];\n            let X = _ref17[1];\n            let ue = X.comment,\n                De = X.precedingNode,\n                ie = X.enclosingNode,\n                G = X.followingNode,\n                z = X.text,\n                U = X.options,\n                le = X.ast,\n                ge = X.isLastComment;\n\n            if (U.parser === \"json\" || U.parser === \"json5\" || U.parser === \"__js_expression\" || U.parser === \"__vue_expression\" || U.parser === \"__vue_ts_expression\") {\n              if (q(ue) - q(le) <= 0) {\n                f(le, ue);\n                continue;\n              }\n\n              if (Y(ue) - Y(le) >= 0) {\n                w(le, ue);\n                continue;\n              }\n            }\n\n            let Ae;\n            if (R ? Ae = [X] : (ue.enclosingNode = ie, ue.precedingNode = De, ue.followingNode = G, Ae = [ue, z, U, le, ge]), P(z, U, oe, W)) ue.placement = \"ownLine\", Q(...Ae) || (G ? f(G, ue) : De ? w(De, ue) : h(ie || le, ue));else if (C(z, U, oe, W)) ue.placement = \"endOfLine\", ee(...Ae) || (De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue));else if (ue.placement = \"remaining\", !te(...Ae)) if (De && G) {\n              let Ne = V.length;\n              Ne > 0 && V[Ne - 1].followingNode !== G && D(V, z, U), V.push(X);\n            } else De ? w(De, ue) : G ? f(G, ue) : h(ie || le, ue);\n          }\n\n          if (D(V, j, $), !R) for (let W of L) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;\n        }\n\n        var k = L => !/[\\S\\n\\u2028\\u2029]/.test(L);\n\n        function P(L, M, j, $) {\n          let _j$$ = j[$],\n              V = _j$$.comment,\n              q = _j$$.precedingNode,\n              Y = M.locStart,\n              H = M.locEnd,\n              R = Y(V);\n          if (q) for (let Q = $ - 1; Q >= 0; Q--) {\n            let _j$Q = j[Q],\n                ee = _j$Q.comment,\n                te = _j$Q.precedingNode;\n            if (te !== q || !k(L.slice(H(ee), R))) break;\n            R = Y(ee);\n          }\n          return v(L, R, {\n            backwards: !0\n          });\n        }\n\n        function C(L, M, j, $) {\n          let _j$$2 = j[$],\n              V = _j$$2.comment,\n              q = _j$$2.followingNode,\n              Y = M.locStart,\n              H = M.locEnd,\n              R = H(V);\n          if (q) for (let Q = $ + 1; Q < j.length; Q++) {\n            let _j$Q2 = j[Q],\n                ee = _j$Q2.comment,\n                te = _j$Q2.followingNode;\n            if (te !== q || !k(L.slice(R, Y(ee)))) break;\n            R = H(ee);\n          }\n          return v(L, R);\n        }\n\n        function D(L, M, j) {\n          let $ = L.length;\n          if ($ === 0) return;\n          let _L$ = L[0],\n              V = _L$.precedingNode,\n              q = _L$.followingNode,\n              Y = _L$.enclosingNode,\n              H = j.printer.getGapRegex && j.printer.getGapRegex(Y) || /^[\\s(]*$/,\n              R = j.locStart(q),\n              Q;\n\n          for (Q = $; Q > 0; --Q) {\n            let _L2 = L[Q - 1],\n                ee = _L2.comment,\n                te = _L2.precedingNode,\n                oe = _L2.followingNode;\n            t.strictEqual(te, V), t.strictEqual(oe, q);\n            let W = M.slice(j.locEnd(ee), R);\n            if (H.test(W)) R = j.locStart(ee);else break;\n          }\n\n          for (let _ref18 of L.entries()) {\n            var _ref19 = _slicedToArray(_ref18, 2);\n\n            let ee = _ref19[0];\n            let te = _ref19[1].comment;\n            ee < Q ? w(V, te) : f(q, te);\n          }\n\n          for (let ee of [V, q]) ee.comments && ee.comments.length > 1 && ee.comments.sort((te, oe) => j.locStart(te) - j.locStart(oe));\n\n          L.length = 0;\n        }\n\n        function g(L, M) {\n          let j = L.getValue();\n          return j.printed = !0, M.printer.printComment(L, M);\n        }\n\n        function F(L, M, j) {\n          let $ = j.locStart(M) - 1;\n\n          for (let V = 1; V < L.length; ++V) if ($ < j.locStart(L[V])) return V - 1;\n\n          return 0;\n        }\n\n        function l(L, M) {\n          let j = L.getValue(),\n              $ = [g(L, M)],\n              V = M.printer,\n              q = M.originalText,\n              Y = M.locStart,\n              H = M.locEnd;\n\n          if (V.isBlockComment && V.isBlockComment(j)) {\n            let ee = v(q, H(j)) ? v(q, Y(j), {\n              backwards: !0\n            }) ? a : s : \" \";\n            $.push(ee);\n          } else $.push(a);\n\n          let Q = m(q, d(q, H(j)));\n          return Q !== !1 && v(q, Q) && $.push(a), $;\n        }\n\n        function E(L, M) {\n          let j = L.getValue(),\n              $ = g(L, M),\n              V = M.printer,\n              q = M.originalText,\n              Y = M.locStart,\n              H = V.isBlockComment && V.isBlockComment(j);\n\n          if (v(q, Y(j), {\n            backwards: !0\n          })) {\n            let Q = p(q, j, Y);\n            return i([a, Q ? a : \"\", $]);\n          }\n\n          let R = [\" \", $];\n          return H || (R = [i(R), r]), R;\n        }\n\n        function y(L, M, j, $) {\n          let V = [],\n              q = L.getValue();\n          return !q || !q.comments || (L.each(() => {\n            let Y = L.getValue();\n            !Y.leading && !Y.trailing && (!$ || $(Y)) && V.push(g(L, M));\n          }, \"comments\"), V.length === 0) ? \"\" : j ? o(a, V) : u([a, o(a, V)]);\n        }\n\n        function N(L, M, j) {\n          let $ = L.getValue();\n          if (!$) return {};\n          let V = $.comments || [];\n          j && (V = V.filter(R => !j.has(R)));\n          let q = $ === M.cursorNode;\n\n          if (V.length === 0) {\n            let R = q ? c : \"\";\n            return {\n              leading: R,\n              trailing: R\n            };\n          }\n\n          let Y = [],\n              H = [];\n          return L.each(() => {\n            let R = L.getValue();\n            if (j && j.has(R)) return;\n            let Q = R.leading,\n                ee = R.trailing;\n            Q ? Y.push(l(L, M)) : ee && H.push(E(L, M));\n          }, \"comments\"), q && (Y.unshift(c), H.push(c)), {\n            leading: Y,\n            trailing: H\n          };\n        }\n\n        function x(L, M, j, $) {\n          let _N = N(L, j, $),\n              V = _N.leading,\n              q = _N.trailing;\n\n          return !V && !q ? M : [V, M, q];\n        }\n\n        function b(L) {\n          if (!!L) for (let M of L) {\n            if (!M.printed) throw new Error('Comment \"' + M.value.trim() + '\" was not printed. Please report this error!');\n            delete M.printed;\n          }\n        }\n\n        n.exports = {\n          attach: I,\n          printComments: x,\n          printCommentsSeparately: N,\n          printDanglingComments: y,\n          getSortedChildNodes: A,\n          ensureAllCommentsPrinted: b\n        };\n      }\n\n    }),\n        Cm = Z({\n      \"src/common/ast-path.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = it();\n\n        function s(u, i) {\n          let o = a(u.stack, i);\n          return o === -1 ? null : u.stack[o];\n        }\n\n        function a(u, i) {\n          for (let o = u.length - 1; o >= 0; o -= 2) {\n            let c = u[o];\n            if (c && !Array.isArray(c) && --i < 0) return o;\n          }\n\n          return -1;\n        }\n\n        var r = class {\n          constructor(u) {\n            this.stack = [u];\n          }\n\n          getName() {\n            let u = this.stack,\n                i = u.length;\n            return i > 1 ? u[i - 2] : null;\n          }\n\n          getValue() {\n            return t(this.stack);\n          }\n\n          getNode() {\n            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n            return s(this, u);\n          }\n\n          getParentNode() {\n            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n            return s(this, u + 1);\n          }\n\n          call(u) {\n            let i = this.stack,\n                o = i.length,\n                c = t(i);\n\n            for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) m[d - 1] = arguments[d];\n\n            for (let f of m) c = c[f], i.push(f, c);\n\n            let p = u(this);\n            return i.length = o, p;\n          }\n\n          callParent(u) {\n            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,\n                o = a(this.stack, i + 1),\n                c = this.stack.splice(o + 1),\n                v = u(this);\n            return this.stack.push(...c), v;\n          }\n\n          each(u) {\n            let i = this.stack,\n                o = i.length,\n                c = t(i);\n\n            for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++) m[d - 1] = arguments[d];\n\n            for (let p of m) c = c[p], i.push(p, c);\n\n            for (let p = 0; p < c.length; ++p) i.push(p, c[p]), u(this, p, c), i.length -= 2;\n\n            i.length = o;\n          }\n\n          map(u) {\n            let i = [];\n\n            for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++) c[v - 1] = arguments[v];\n\n            return this.each((m, d, p) => {\n              i[d] = u(m, d, p);\n            }, ...c), i;\n          }\n\n          try(u) {\n            let i = this.stack,\n                o = [...i];\n\n            try {\n              return u();\n            } finally {\n              i.length = 0, i.push(...o);\n            }\n          }\n\n          match() {\n            let u = this.stack.length - 1,\n                i = null,\n                o = this.stack[u--];\n\n            for (var c = arguments.length, v = new Array(c), m = 0; m < c; m++) v[m] = arguments[m];\n\n            for (let d of v) {\n              if (o === void 0) return !1;\n              let p = null;\n              if (typeof i == \"number\" && (p = i, i = this.stack[u--], o = this.stack[u--]), d && !d(o, i, p)) return !1;\n              i = this.stack[u--], o = this.stack[u--];\n            }\n\n            return !0;\n          }\n\n          findAncestor(u) {\n            let i = this.stack.length - 1,\n                o = null,\n                c = this.stack[i--];\n\n            for (; c;) {\n              let v = null;\n              if (typeof o == \"number\" && (v = o, o = this.stack[i--], c = this.stack[i--]), o !== null && u(c, o, v)) return c;\n              o = this.stack[i--], c = this.stack[i--];\n            }\n          }\n\n        };\n        n.exports = r;\n      }\n\n    }),\n        Em = Z({\n      \"src/main/multiparser.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe2 = Oe(),\n            t = _Oe2.utils.stripTrailingHardline,\n            _Wa = Wa(),\n            s = _Wa.normalize,\n            a = et();\n\n        function r(i, o, c, v) {\n          if (c.printer.embed && c.embeddedLanguageFormatting === \"auto\") return c.printer.embed(i, o, (m, d, p) => u(m, d, c, v, p), c);\n        }\n\n        function u(i, o, c, v) {\n          let _ref20 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},\n              _ref20$stripTrailingH = _ref20.stripTrailingHardline,\n              m = _ref20$stripTrailingH === void 0 ? !1 : _ref20$stripTrailingH,\n              d = s(Object.assign(Object.assign(Object.assign({}, c), o), {}, {\n            parentParser: c.parser,\n            originalText: i\n          }), {\n            passThrough: !0\n          }),\n              p = Gn().parse(i, d),\n              f = p.ast;\n\n          i = p.text;\n          let h = f.comments;\n          delete f.comments, a.attach(h, f, i, d), d[Symbol.for(\"comments\")] = h || [], d[Symbol.for(\"tokens\")] = f.tokens || [];\n          let w = v(f, d);\n          return a.ensureAllCommentsPrinted(h), m ? typeof w == \"string\" ? w.replace(/(?:\\r?\\n)*$/, \"\") : t(w) : w;\n        }\n\n        n.exports = {\n          printSubtree: r\n        };\n      }\n\n    }),\n        Fm = Z({\n      \"src/main/ast-to-doc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Cm(),\n            _Oe3 = Oe(),\n            _Oe3$builders = _Oe3.builders,\n            s = _Oe3$builders.hardline,\n            a = _Oe3$builders.addAlignmentToDoc,\n            r = _Oe3.utils.propagateBreaks,\n            _et = et(),\n            u = _et.printComments,\n            i = Em();\n\n        function o(m, d) {\n          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,\n              f = d.printer;\n          f.preprocess && (m = f.preprocess(m, d));\n          let h = new Map(),\n              w = new t(m),\n              T = A();\n          return p > 0 && (T = a([s, T], p, d.tabWidth)), r(T), T;\n\n          function A(B, I) {\n            return B === void 0 || B === w ? S(I) : Array.isArray(B) ? w.call(() => S(I), ...B) : w.call(() => S(I), B);\n          }\n\n          function S(B) {\n            let I = w.getValue(),\n                k = I && typeof I == \"object\" && B === void 0;\n            if (k && h.has(I)) return h.get(I);\n            let P = v(w, d, A, B);\n            return k && h.set(I, P), P;\n          }\n        }\n\n        function c(m, d) {\n          let p = d.originalText,\n              f = d[Symbol.for(\"comments\")],\n              h = d.locStart,\n              w = d.locEnd,\n              T = h(m),\n              A = w(m),\n              S = new Set();\n\n          for (let B of f) h(B) >= T && w(B) <= A && (B.printed = !0, S.add(B));\n\n          return {\n            doc: p.slice(T, A),\n            printedComments: S\n          };\n        }\n\n        function v(m, d, p, f) {\n          let h = m.getValue(),\n              w = d.printer,\n              T,\n              A;\n\n          if (w.hasPrettierIgnore && w.hasPrettierIgnore(m)) {\n            var _c2 = c(h, d);\n\n            T = _c2.doc;\n            A = _c2.printedComments;\n          } else {\n            if (h) try {\n              T = i.printSubtree(m, p, d, o);\n            } catch (S) {\n              if (globalThis.PRETTIER_DEBUG) throw S;\n            }\n            T || (T = w.print(m, d, p, f));\n          }\n\n          return (!w.willPrintOwnComments || !w.willPrintOwnComments(m, d)) && (T = u(m, T, d, A)), T;\n        }\n\n        n.exports = o;\n      }\n\n    }),\n        Am = Z({\n      \"src/main/range-util.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Xt(),\n            s = et(),\n            a = f => {\n          let h = f.parser;\n          return h === \"json\" || h === \"json5\" || h === \"json-stringify\";\n        };\n\n        function r(f, h) {\n          let w = [f.node, ...f.parentNodes],\n              T = new Set([h.node, ...h.parentNodes]);\n          return w.find(A => v.has(A.type) && T.has(A));\n        }\n\n        function u(f) {\n          let h = f.length - 1;\n\n          for (;;) {\n            let w = f[h];\n            if (w && (w.type === \"Program\" || w.type === \"File\")) h--;else break;\n          }\n\n          return f.slice(0, h + 1);\n        }\n\n        function i(f, h, w) {\n          let T = w.locStart,\n              A = w.locEnd,\n              S = f.node,\n              B = h.node;\n          if (S === B) return {\n            startNode: S,\n            endNode: B\n          };\n          let I = T(f.node);\n\n          for (let P of u(h.parentNodes)) if (T(P) >= I) B = P;else break;\n\n          let k = A(h.node);\n\n          for (let P of u(f.parentNodes)) if (A(P) <= k) S = P;else break;\n\n          return {\n            startNode: S,\n            endNode: B\n          };\n        }\n\n        function o(f, h, w, T) {\n          let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],\n              S = arguments.length > 5 ? arguments[5] : void 0,\n              B = w.locStart,\n              I = w.locEnd,\n              k = B(f),\n              P = I(f);\n\n          if (!(h > P || h < k || S === \"rangeEnd\" && h === k || S === \"rangeStart\" && h === P)) {\n            for (let C of s.getSortedChildNodes(f, w)) {\n              let D = o(C, h, w, T, [f, ...A], S);\n              if (D) return D;\n            }\n\n            if (!T || T(f, A[0])) return {\n              node: f,\n              parentNodes: A\n            };\n          }\n        }\n\n        function c(f, h) {\n          return h !== \"DeclareExportDeclaration\" && f !== \"TypeParameterDeclaration\" && (f === \"Directive\" || f === \"TypeAlias\" || f === \"TSExportAssignment\" || f.startsWith(\"Declare\") || f.startsWith(\"TSDeclare\") || f.endsWith(\"Statement\") || f.endsWith(\"Declaration\"));\n        }\n\n        var v = new Set([\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\", \"UnaryExpression\", \"TemplateLiteral\"]),\n            m = new Set([\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"]);\n\n        function d(f, h, w) {\n          if (!h) return !1;\n\n          switch (f.parser) {\n            case \"flow\":\n            case \"babel\":\n            case \"babel-flow\":\n            case \"babel-ts\":\n            case \"typescript\":\n            case \"acorn\":\n            case \"espree\":\n            case \"meriyah\":\n            case \"__babel_estree\":\n              return c(h.type, w && w.type);\n\n            case \"json\":\n            case \"json5\":\n            case \"json-stringify\":\n              return v.has(h.type);\n\n            case \"graphql\":\n              return m.has(h.kind);\n\n            case \"vue\":\n              return h.tag !== \"root\";\n          }\n\n          return !1;\n        }\n\n        function p(f, h, w) {\n          let T = h.rangeStart,\n              A = h.rangeEnd,\n              S = h.locStart,\n              B = h.locEnd;\n          t.ok(A > T);\n          let I = f.slice(T, A).search(/\\S/),\n              k = I === -1;\n          if (!k) for (T += I; A > T && !/\\S/.test(f[A - 1]); --A);\n          let P = o(w, T, h, (F, l) => d(h, F, l), [], \"rangeStart\"),\n              C = k ? P : o(w, A, h, F => d(h, F), [], \"rangeEnd\");\n          if (!P || !C) return {\n            rangeStart: 0,\n            rangeEnd: 0\n          };\n          let D, g;\n\n          if (a(h)) {\n            let F = r(P, C);\n            D = F, g = F;\n          } else {\n            var _i2 = i(P, C, h);\n\n            D = _i2.startNode;\n            g = _i2.endNode;\n          }\n\n          return {\n            rangeStart: Math.min(S(D), S(g)),\n            rangeEnd: Math.max(B(D), B(g))\n          };\n        }\n\n        n.exports = {\n          calculateRange: p,\n          findNodeAtOffset: o\n        };\n      }\n\n    }),\n        Sm = Z({\n      \"src/main/core.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _aD = aD(),\n            t = _aD.diffArrays,\n            _Oe4 = Oe(),\n            s = _Oe4.printer.printDocToString,\n            a = _Oe4.debug.printDocToDebug,\n            _Ue2 = Ue(),\n            r = _Ue2.getAlignmentSize,\n            _jn2 = jn(),\n            u = _jn2.guessEndOfLine,\n            i = _jn2.convertEndOfLineToChars,\n            o = _jn2.countEndOfLineChars,\n            c = _jn2.normalizeEndOfLine,\n            v = Wa().normalize,\n            m = vm(),\n            d = et(),\n            p = Gn(),\n            f = Fm(),\n            h = Am(),\n            w = \"\\uFEFF\",\n            T = Symbol(\"cursor\");\n\n        function A(g, F, l) {\n          let E = F.comments;\n          return E && (delete F.comments, d.attach(E, F, g, l)), l[Symbol.for(\"comments\")] = E || [], l[Symbol.for(\"tokens\")] = F.tokens || [], l.originalText = g, E;\n        }\n\n        function S(g, F) {\n          let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n          if (!g || g.trim().length === 0) return {\n            formatted: \"\",\n            cursorOffset: -1,\n            comments: []\n          };\n\n          let _p$parse = p.parse(g, F),\n              E = _p$parse.ast,\n              y = _p$parse.text;\n\n          if (F.cursorOffset >= 0) {\n            let L = h.findNodeAtOffset(E, F.cursorOffset, F);\n            L && L.node && (F.cursorNode = L.node);\n          }\n\n          let N = A(y, E, F),\n              x = f(E, F, l),\n              b = s(x, F);\n\n          if (d.ensureAllCommentsPrinted(N), l > 0) {\n            let L = b.formatted.trim();\n            b.cursorNodeStart !== void 0 && (b.cursorNodeStart -= b.formatted.indexOf(L)), b.formatted = L + i(F.endOfLine);\n          }\n\n          if (F.cursorOffset >= 0) {\n            let L, M, j, $, V;\n            if (F.cursorNode && b.cursorNodeText ? (L = F.locStart(F.cursorNode), M = y.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $ = b.cursorNodeStart, V = b.cursorNodeText) : (L = 0, M = y, j = F.cursorOffset, $ = 0, V = b.formatted), M === V) return {\n              formatted: b.formatted,\n              cursorOffset: $ + j,\n              comments: N\n            };\n            let q = [...M];\n            q.splice(j, 0, T);\n            let Y = [...V],\n                H = t(q, Y),\n                R = $;\n\n            for (let Q of H) if (Q.removed) {\n              if (Q.value.includes(T)) break;\n            } else R += Q.count;\n\n            return {\n              formatted: b.formatted,\n              cursorOffset: R,\n              comments: N\n            };\n          }\n\n          return {\n            formatted: b.formatted,\n            cursorOffset: -1,\n            comments: N\n          };\n        }\n\n        function B(g, F) {\n          let _p$parse2 = p.parse(g, F),\n              l = _p$parse2.ast,\n              E = _p$parse2.text,\n              _h$calculateRange = h.calculateRange(E, F, l),\n              y = _h$calculateRange.rangeStart,\n              N = _h$calculateRange.rangeEnd,\n              x = E.slice(y, N),\n              b = Math.min(y, E.lastIndexOf(\"\\n\", y) + 1),\n              L = E.slice(b, y).match(/^\\s*/)[0],\n              M = r(L, F.tabWidth),\n              j = S(x, Object.assign(Object.assign({}, F), {}, {\n            rangeStart: 0,\n            rangeEnd: Number.POSITIVE_INFINITY,\n            cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1,\n            endOfLine: \"lf\"\n          }), M),\n              $ = j.formatted.trimEnd(),\n              V = F.cursorOffset;\n\n          V > N ? V += $.length - x.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);\n          let q = E.slice(0, y) + $ + E.slice(N);\n\n          if (F.endOfLine !== \"lf\") {\n            let Y = i(F.endOfLine);\n            V >= 0 && Y === \"\\r\\n\" && (V += o(q.slice(0, V), \"\\n\")), q = q.replace(/\\n/g, Y);\n          }\n\n          return {\n            formatted: q,\n            cursorOffset: V,\n            comments: j.comments\n          };\n        }\n\n        function I(g, F, l) {\n          return typeof F != \"number\" || Number.isNaN(F) || F < 0 || F > g.length ? l : F;\n        }\n\n        function k(g, F) {\n          let l = F.cursorOffset,\n              E = F.rangeStart,\n              y = F.rangeEnd;\n          return l = I(g, l, -1), E = I(g, E, 0), y = I(g, y, g.length), Object.assign(Object.assign({}, F), {}, {\n            cursorOffset: l,\n            rangeStart: E,\n            rangeEnd: y\n          });\n        }\n\n        function P(g, F) {\n          let _k = k(g, F),\n              l = _k.cursorOffset,\n              E = _k.rangeStart,\n              y = _k.rangeEnd,\n              N = _k.endOfLine,\n              x = g.charAt(0) === w;\n\n          if (x && (g = g.slice(1), l--, E--, y--), N === \"auto\" && (N = u(g)), g.includes(\"\\r\")) {\n            let b = L => o(g.slice(0, Math.max(L, 0)), \"\\r\\n\");\n\n            l -= b(l), E -= b(E), y -= b(y), g = c(g);\n          }\n\n          return {\n            hasBOM: x,\n            text: g,\n            options: k(g, Object.assign(Object.assign({}, F), {}, {\n              cursorOffset: l,\n              rangeStart: E,\n              rangeEnd: y,\n              endOfLine: N\n            }))\n          };\n        }\n\n        function C(g, F) {\n          let l = p.resolveParser(F);\n          return !l.hasPragma || l.hasPragma(g);\n        }\n\n        function D(g, F) {\n          let _P = P(g, v(F)),\n              l = _P.hasBOM,\n              E = _P.text,\n              y = _P.options;\n\n          if (y.rangeStart >= y.rangeEnd && E !== \"\" || y.requirePragma && !C(E, y)) return {\n            formatted: g,\n            cursorOffset: F.cursorOffset,\n            comments: []\n          };\n          let N;\n          return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C(E, y) && (E = y.printer.insertPragma(E)), N = S(E, y)), l && (N.formatted = w + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;\n        }\n\n        n.exports = {\n          formatWithCursor: D,\n\n          parse(g, F, l) {\n            let _P2 = P(g, v(F)),\n                E = _P2.text,\n                y = _P2.options,\n                N = p.parse(E, y);\n\n            return l && (N.ast = m(N.ast, y)), N;\n          },\n\n          formatAST(g, F) {\n            F = v(F);\n            let l = f(g, F);\n            return s(l, F);\n          },\n\n          formatDoc(g, F) {\n            return D(a(g), Object.assign(Object.assign({}, F), {}, {\n              parser: \"__js_expression\"\n            })).formatted;\n          },\n\n          printToDoc(g, F) {\n            F = v(F);\n\n            let _p$parse3 = p.parse(g, F),\n                l = _p$parse3.ast,\n                E = _p$parse3.text;\n\n            return A(E, l, F), f(l, F);\n          },\n\n          printDocToString(g, F) {\n            return s(g, v(F));\n          }\n\n        };\n      }\n\n    }),\n        xm = Z({\n      \"src/common/util-shared.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue3 = Ue(),\n            t = _Ue3.getMaxContinuousCount,\n            s = _Ue3.getStringWidth,\n            a = _Ue3.getAlignmentSize,\n            r = _Ue3.getIndentSize,\n            u = _Ue3.skip,\n            i = _Ue3.skipWhitespace,\n            o = _Ue3.skipSpaces,\n            c = _Ue3.skipNewline,\n            v = _Ue3.skipToLineEnd,\n            m = _Ue3.skipEverythingButNewLine,\n            d = _Ue3.skipInlineComment,\n            p = _Ue3.skipTrailingComment,\n            f = _Ue3.hasNewline,\n            h = _Ue3.hasNewlineInRange,\n            w = _Ue3.hasSpaces,\n            T = _Ue3.isNextLineEmpty,\n            A = _Ue3.isNextLineEmptyAfterIndex,\n            S = _Ue3.isPreviousLineEmpty,\n            B = _Ue3.getNextNonSpaceNonCommentCharacterIndex,\n            I = _Ue3.makeString,\n            k = _Ue3.addLeadingComment,\n            P = _Ue3.addDanglingComment,\n            C = _Ue3.addTrailingComment;\n\n        n.exports = {\n          getMaxContinuousCount: t,\n          getStringWidth: s,\n          getAlignmentSize: a,\n          getIndentSize: r,\n          skip: u,\n          skipWhitespace: i,\n          skipSpaces: o,\n          skipNewline: c,\n          skipToLineEnd: v,\n          skipEverythingButNewLine: m,\n          skipInlineComment: d,\n          skipTrailingComment: p,\n          hasNewline: f,\n          hasNewlineInRange: h,\n          hasSpaces: w,\n          isNextLineEmpty: T,\n          isNextLineEmptyAfterIndex: A,\n          isPreviousLineEmpty: S,\n          getNextNonSpaceNonCommentCharacterIndex: B,\n          makeString: I,\n          addLeadingComment: k,\n          addDanglingComment: P,\n          addTrailingComment: C\n        };\n      }\n\n    }),\n        Bt = Z({\n      \"src/utils/create-language.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = function (t, s) {\n          let a = t.languageId,\n              r = kn(t, Zf);\n          return Object.assign(Object.assign({\n            linguistLanguageId: a\n          }, r), s(t));\n        };\n      }\n\n    }),\n        bm = Z({\n      \"node_modules/esutils/lib/ast.js\"(e, n) {\n        re(), function () {\n          \"use strict\";\n\n          function t(o) {\n            if (o == null) return !1;\n\n            switch (o.type) {\n              case \"ArrayExpression\":\n              case \"AssignmentExpression\":\n              case \"BinaryExpression\":\n              case \"CallExpression\":\n              case \"ConditionalExpression\":\n              case \"FunctionExpression\":\n              case \"Identifier\":\n              case \"Literal\":\n              case \"LogicalExpression\":\n              case \"MemberExpression\":\n              case \"NewExpression\":\n              case \"ObjectExpression\":\n              case \"SequenceExpression\":\n              case \"ThisExpression\":\n              case \"UnaryExpression\":\n              case \"UpdateExpression\":\n                return !0;\n            }\n\n            return !1;\n          }\n\n          function s(o) {\n            if (o == null) return !1;\n\n            switch (o.type) {\n              case \"DoWhileStatement\":\n              case \"ForInStatement\":\n              case \"ForStatement\":\n              case \"WhileStatement\":\n                return !0;\n            }\n\n            return !1;\n          }\n\n          function a(o) {\n            if (o == null) return !1;\n\n            switch (o.type) {\n              case \"BlockStatement\":\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n              case \"DebuggerStatement\":\n              case \"DoWhileStatement\":\n              case \"EmptyStatement\":\n              case \"ExpressionStatement\":\n              case \"ForInStatement\":\n              case \"ForStatement\":\n              case \"IfStatement\":\n              case \"LabeledStatement\":\n              case \"ReturnStatement\":\n              case \"SwitchStatement\":\n              case \"ThrowStatement\":\n              case \"TryStatement\":\n              case \"VariableDeclaration\":\n              case \"WhileStatement\":\n              case \"WithStatement\":\n                return !0;\n            }\n\n            return !1;\n          }\n\n          function r(o) {\n            return a(o) || o != null && o.type === \"FunctionDeclaration\";\n          }\n\n          function u(o) {\n            switch (o.type) {\n              case \"IfStatement\":\n                return o.alternate != null ? o.alternate : o.consequent;\n\n              case \"LabeledStatement\":\n              case \"ForStatement\":\n              case \"ForInStatement\":\n              case \"WhileStatement\":\n              case \"WithStatement\":\n                return o.body;\n            }\n\n            return null;\n          }\n\n          function i(o) {\n            var c;\n            if (o.type !== \"IfStatement\" || o.alternate == null) return !1;\n            c = o.consequent;\n\n            do {\n              if (c.type === \"IfStatement\" && c.alternate == null) return !0;\n              c = u(c);\n            } while (c);\n\n            return !1;\n          }\n\n          n.exports = {\n            isExpression: t,\n            isStatement: a,\n            isIterationStatement: s,\n            isSourceElement: r,\n            isProblematicIfStatement: i,\n            trailingStatement: u\n          };\n        }();\n      }\n\n    }),\n        $a = Z({\n      \"node_modules/esutils/lib/code.js\"(e, n) {\n        re(), function () {\n          \"use strict\";\n\n          var t, s, a, r, u, i;\n          s = {\n            NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n            NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n          }, t = {\n            NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n            NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n          };\n\n          function o(A) {\n            return 48 <= A && A <= 57;\n          }\n\n          function c(A) {\n            return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;\n          }\n\n          function v(A) {\n            return A >= 48 && A <= 55;\n          }\n\n          a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];\n\n          function m(A) {\n            return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && a.indexOf(A) >= 0;\n          }\n\n          function d(A) {\n            return A === 10 || A === 13 || A === 8232 || A === 8233;\n          }\n\n          function p(A) {\n            if (A <= 65535) return String.fromCharCode(A);\n            var S = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296),\n                B = String.fromCharCode((A - 65536) % 1024 + 56320);\n            return S + B;\n          }\n\n          for (r = new Array(128), i = 0; i < 128; ++i) r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;\n\n          for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;\n\n          function f(A) {\n            return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p(A));\n          }\n\n          function h(A) {\n            return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p(A));\n          }\n\n          function w(A) {\n            return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p(A));\n          }\n\n          function T(A) {\n            return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p(A));\n          }\n\n          n.exports = {\n            isDecimalDigit: o,\n            isHexDigit: c,\n            isOctalDigit: v,\n            isWhiteSpace: m,\n            isLineTerminator: d,\n            isIdentifierStartES5: f,\n            isIdentifierPartES5: h,\n            isIdentifierStartES6: w,\n            isIdentifierPartES6: T\n          };\n        }();\n      }\n\n    }),\n        Tm = Z({\n      \"node_modules/esutils/lib/keyword.js\"(e, n) {\n        re(), function () {\n          \"use strict\";\n\n          var t = $a();\n\n          function s(f) {\n            switch (f) {\n              case \"implements\":\n              case \"interface\":\n              case \"package\":\n              case \"private\":\n              case \"protected\":\n              case \"public\":\n              case \"static\":\n              case \"let\":\n                return !0;\n\n              default:\n                return !1;\n            }\n          }\n\n          function a(f, h) {\n            return !h && f === \"yield\" ? !1 : r(f, h);\n          }\n\n          function r(f, h) {\n            if (h && s(f)) return !0;\n\n            switch (f.length) {\n              case 2:\n                return f === \"if\" || f === \"in\" || f === \"do\";\n\n              case 3:\n                return f === \"var\" || f === \"for\" || f === \"new\" || f === \"try\";\n\n              case 4:\n                return f === \"this\" || f === \"else\" || f === \"case\" || f === \"void\" || f === \"with\" || f === \"enum\";\n\n              case 5:\n                return f === \"while\" || f === \"break\" || f === \"catch\" || f === \"throw\" || f === \"const\" || f === \"yield\" || f === \"class\" || f === \"super\";\n\n              case 6:\n                return f === \"return\" || f === \"typeof\" || f === \"delete\" || f === \"switch\" || f === \"export\" || f === \"import\";\n\n              case 7:\n                return f === \"default\" || f === \"finally\" || f === \"extends\";\n\n              case 8:\n                return f === \"function\" || f === \"continue\" || f === \"debugger\";\n\n              case 10:\n                return f === \"instanceof\";\n\n              default:\n                return !1;\n            }\n          }\n\n          function u(f, h) {\n            return f === \"null\" || f === \"true\" || f === \"false\" || a(f, h);\n          }\n\n          function i(f, h) {\n            return f === \"null\" || f === \"true\" || f === \"false\" || r(f, h);\n          }\n\n          function o(f) {\n            return f === \"eval\" || f === \"arguments\";\n          }\n\n          function c(f) {\n            var h, w, T;\n            if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T))) return !1;\n\n            for (h = 1, w = f.length; h < w; ++h) if (T = f.charCodeAt(h), !t.isIdentifierPartES5(T)) return !1;\n\n            return !0;\n          }\n\n          function v(f, h) {\n            return (f - 55296) * 1024 + (h - 56320) + 65536;\n          }\n\n          function m(f) {\n            var h, w, T, A, S;\n            if (f.length === 0) return !1;\n\n            for (S = t.isIdentifierStartES6, h = 0, w = f.length; h < w; ++h) {\n              if (T = f.charCodeAt(h), 55296 <= T && T <= 56319) {\n                if (++h, h >= w || (A = f.charCodeAt(h), !(56320 <= A && A <= 57343))) return !1;\n                T = v(T, A);\n              }\n\n              if (!S(T)) return !1;\n              S = t.isIdentifierPartES6;\n            }\n\n            return !0;\n          }\n\n          function d(f, h) {\n            return c(f) && !u(f, h);\n          }\n\n          function p(f, h) {\n            return m(f) && !i(f, h);\n          }\n\n          n.exports = {\n            isKeywordES5: a,\n            isKeywordES6: r,\n            isReservedWordES5: u,\n            isReservedWordES6: i,\n            isRestrictedWord: o,\n            isIdentifierNameES5: c,\n            isIdentifierNameES6: m,\n            isIdentifierES5: d,\n            isIdentifierES6: p\n          };\n        }();\n      }\n\n    }),\n        Bm = Z({\n      \"node_modules/esutils/lib/utils.js\"(e) {\n        re(), function () {\n          \"use strict\";\n\n          e.ast = bm(), e.code = $a(), e.keyword = Tm();\n        }();\n      }\n\n    }),\n        It = Z({\n      \"src/language-js/utils/is-block-comment.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = new Set([\"Block\", \"CommentBlock\", \"MultiLine\"]),\n            s = a => t.has(a == null ? void 0 : a.type);\n\n        n.exports = s;\n      }\n\n    }),\n        Nm = Z({\n      \"src/language-js/utils/is-node-matches.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a, r) {\n          let u = r.split(\".\");\n\n          for (let i = u.length - 1; i >= 0; i--) {\n            let o = u[i];\n            if (i === 0) return a.type === \"Identifier\" && a.name === o;\n            if (a.type !== \"MemberExpression\" || a.optional || a.computed || a.property.type !== \"Identifier\" || a.property.name !== o) return !1;\n            a = a.object;\n          }\n        }\n\n        function s(a, r) {\n          return r.some(u => t(a, u));\n        }\n\n        n.exports = s;\n      }\n\n    }),\n        Ke = Z({\n      \"src/language-js/utils/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Bm().keyword.isIdentifierNameES5,\n            _Ue4 = Ue(),\n            s = _Ue4.getLast,\n            a = _Ue4.hasNewline,\n            r = _Ue4.skipWhitespace,\n            u = _Ue4.isNonEmptyArray,\n            i = _Ue4.isNextLineEmptyAfterIndex,\n            o = _Ue4.getStringWidth,\n            _st = st(),\n            c = _st.locStart,\n            v = _st.locEnd,\n            m = _st.hasSameLocStart,\n            d = It(),\n            p = Nm(),\n            f = \"(?:(?=.)\\\\s)\",\n            h = new RegExp(\"^\".concat(f, \"*:\")),\n            w = new RegExp(\"^\".concat(f, \"*::\"));\n\n        function T(O) {\n          var fe, Te;\n          return ((fe = O.extra) === null || fe === void 0 ? void 0 : fe.parenthesized) && d((Te = O.trailingComments) === null || Te === void 0 ? void 0 : Te[0]) && h.test(O.trailingComments[0].value);\n        }\n\n        function A(O) {\n          let fe = O == null ? void 0 : O[0];\n          return d(fe) && w.test(fe.value);\n        }\n\n        function S(O, fe) {\n          if (!O || typeof O != \"object\") return !1;\n          if (Array.isArray(O)) return O.some($e => S($e, fe));\n          let Te = fe(O);\n          return typeof Te == \"boolean\" ? Te : Object.values(O).some($e => S($e, fe));\n        }\n\n        function B(O) {\n          return O.type === \"AssignmentExpression\" || O.type === \"BinaryExpression\" || O.type === \"LogicalExpression\" || O.type === \"NGPipeExpression\" || O.type === \"ConditionalExpression\" || ue(O) || De(O) || O.type === \"SequenceExpression\" || O.type === \"TaggedTemplateExpression\" || O.type === \"BindExpression\" || O.type === \"UpdateExpression\" && !O.prefix || O.type === \"TSAsExpression\" || O.type === \"TSNonNullExpression\";\n        }\n\n        function I(O) {\n          var fe, Te, $e, Je, Ze, ut;\n          return O.expressions ? O.expressions[0] : (fe = (Te = ($e = (Je = (Ze = (ut = O.left) !== null && ut !== void 0 ? ut : O.test) !== null && Ze !== void 0 ? Ze : O.callee) !== null && Je !== void 0 ? Je : O.object) !== null && $e !== void 0 ? $e : O.tag) !== null && Te !== void 0 ? Te : O.argument) !== null && fe !== void 0 ? fe : O.expression;\n        }\n\n        function k(O, fe) {\n          if (fe.expressions) return [\"expressions\", 0];\n          if (fe.left) return [\"left\"];\n          if (fe.test) return [\"test\"];\n          if (fe.object) return [\"object\"];\n          if (fe.callee) return [\"callee\"];\n          if (fe.tag) return [\"tag\"];\n          if (fe.argument) return [\"argument\"];\n          if (fe.expression) return [\"expression\"];\n          throw new Error(\"Unexpected node has no left side.\");\n        }\n\n        function P(O) {\n          return O = new Set(O), fe => O.has(fe == null ? void 0 : fe.type);\n        }\n\n        var C = P([\"Line\", \"CommentLine\", \"SingleLine\", \"HashbangComment\", \"HTMLOpen\", \"HTMLClose\"]),\n            D = P([\"ExportDefaultDeclaration\", \"ExportDefaultSpecifier\", \"DeclareExportDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\"]);\n\n        function g(O) {\n          let fe = O.getParentNode();\n          return O.getName() === \"declaration\" && D(fe) ? fe : null;\n        }\n\n        var F = P([\"BooleanLiteral\", \"DirectiveLiteral\", \"Literal\", \"NullLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"RegExpLiteral\", \"StringLiteral\", \"TemplateLiteral\", \"TSTypeLiteral\", \"JSXText\"]);\n\n        function l(O) {\n          return O.type === \"NumericLiteral\" || O.type === \"Literal\" && typeof O.value == \"number\";\n        }\n\n        function E(O) {\n          return O.type === \"UnaryExpression\" && (O.operator === \"+\" || O.operator === \"-\") && l(O.argument);\n        }\n\n        function y(O) {\n          return O.type === \"StringLiteral\" || O.type === \"Literal\" && typeof O.value == \"string\";\n        }\n\n        var N = P([\"ObjectTypeAnnotation\", \"TSTypeLiteral\", \"TSMappedType\"]),\n            x = P([\"FunctionExpression\", \"ArrowFunctionExpression\"]);\n\n        function b(O) {\n          return O.type === \"FunctionExpression\" || O.type === \"ArrowFunctionExpression\" && O.body.type === \"BlockStatement\";\n        }\n\n        function L(O) {\n          return ue(O) && O.callee.type === \"Identifier\" && [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(O.callee.name);\n        }\n\n        var M = P([\"JSXElement\", \"JSXFragment\"]);\n\n        function j(O, fe) {\n          if (O.parentParser !== \"markdown\" && O.parentParser !== \"mdx\") return !1;\n          let Te = fe.getNode();\n          if (!Te.expression || !M(Te.expression)) return !1;\n          let $e = fe.getParentNode();\n          return $e.type === \"Program\" && $e.body.length === 1;\n        }\n\n        function $(O) {\n          return O.kind === \"get\" || O.kind === \"set\";\n        }\n\n        function V(O) {\n          return $(O) || m(O, O.value);\n        }\n\n        function q(O) {\n          return (O.type === \"ObjectTypeProperty\" || O.type === \"ObjectTypeInternalSlot\") && O.value.type === \"FunctionTypeAnnotation\" && !O.static && !V(O);\n        }\n\n        function Y(O) {\n          return (O.type === \"TypeAnnotation\" || O.type === \"TSTypeAnnotation\") && O.typeAnnotation.type === \"FunctionTypeAnnotation\" && !O.static && !m(O, O.typeAnnotation);\n        }\n\n        var H = P([\"BinaryExpression\", \"LogicalExpression\", \"NGPipeExpression\"]);\n\n        function R(O) {\n          return De(O) || O.type === \"BindExpression\" && Boolean(O.object);\n        }\n\n        var Q = new Set([\"AnyTypeAnnotation\", \"TSAnyKeyword\", \"NullLiteralTypeAnnotation\", \"TSNullKeyword\", \"ThisTypeAnnotation\", \"TSThisType\", \"NumberTypeAnnotation\", \"TSNumberKeyword\", \"VoidTypeAnnotation\", \"TSVoidKeyword\", \"BooleanTypeAnnotation\", \"TSBooleanKeyword\", \"BigIntTypeAnnotation\", \"TSBigIntKeyword\", \"SymbolTypeAnnotation\", \"TSSymbolKeyword\", \"StringTypeAnnotation\", \"TSStringKeyword\", \"BooleanLiteralTypeAnnotation\", \"StringLiteralTypeAnnotation\", \"BigIntLiteralTypeAnnotation\", \"NumberLiteralTypeAnnotation\", \"TSLiteralType\", \"TSTemplateLiteralType\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"TSNeverKeyword\", \"TSObjectKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\"]);\n\n        function ee(O) {\n          return O ? !!((O.type === \"GenericTypeAnnotation\" || O.type === \"TSTypeReference\") && !O.typeParameters || Q.has(O.type)) : !1;\n        }\n\n        function te(O) {\n          let fe = /^(?:before|after)(?:Each|All)$/;\n          return O.callee.type === \"Identifier\" && fe.test(O.callee.name) && O.arguments.length === 1;\n        }\n\n        var oe = [\"it\", \"it.only\", \"it.skip\", \"describe\", \"describe.only\", \"describe.skip\", \"test\", \"test.only\", \"test.skip\", \"test.step\", \"test.describe\", \"test.describe.only\", \"test.describe.parallel\", \"test.describe.parallel.only\", \"test.describe.serial\", \"test.describe.serial.only\", \"skip\", \"xit\", \"xdescribe\", \"xtest\", \"fit\", \"fdescribe\", \"ftest\"];\n\n        function W(O) {\n          return p(O, oe);\n        }\n\n        function X(O, fe) {\n          if (O.type !== \"CallExpression\") return !1;\n\n          if (O.arguments.length === 1) {\n            if (L(O) && fe && X(fe)) return x(O.arguments[0]);\n            if (te(O)) return L(O.arguments[0]);\n          } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === \"TemplateLiteral\" || y(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !l(O.arguments[2]) ? !1 : (O.arguments.length === 2 ? x(O.arguments[1]) : b(O.arguments[1]) && Se(O.arguments[1]).length <= 1) || L(O.arguments[1]);\n\n          return !1;\n        }\n\n        var ue = P([\"CallExpression\", \"OptionalCallExpression\"]),\n            De = P([\"MemberExpression\", \"OptionalMemberExpression\"]);\n\n        function ie(O) {\n          let fe = \"expressions\";\n          O.type === \"TSTemplateLiteralType\" && (fe = \"types\");\n          let Te = O[fe];\n          return Te.length === 0 ? !1 : Te.every($e => {\n            if (se($e)) return !1;\n            if ($e.type === \"Identifier\" || $e.type === \"ThisExpression\") return !0;\n\n            if (De($e)) {\n              let Je = $e;\n\n              for (; De(Je);) if (Je.property.type !== \"Identifier\" && Je.property.type !== \"Literal\" && Je.property.type !== \"StringLiteral\" && Je.property.type !== \"NumericLiteral\" || (Je = Je.object, se(Je))) return !1;\n\n              return Je.type === \"Identifier\" || Je.type === \"ThisExpression\";\n            }\n\n            return !1;\n          });\n        }\n\n        function G(O, fe) {\n          return O === \"+\" || O === \"-\" ? O + fe : fe;\n        }\n\n        function z(O, fe) {\n          let Te = c(fe),\n              $e = r(O, v(fe));\n          return $e !== !1 && O.slice(Te, Te + 2) === \"/*\" && O.slice($e, $e + 2) === \"*/\";\n        }\n\n        function U(O, fe) {\n          return M(fe) ? Re(fe) : se(fe, Le.Leading, Te => a(O, v(Te)));\n        }\n\n        function le(O, fe) {\n          return fe.parser !== \"json\" && y(O.key) && ve(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(fe.parser === \"babel-ts\" && O.type === \"ClassProperty\" || fe.parser === \"typescript\" && O.type === \"PropertyDefinition\") || ge(O.key.value) && String(Number(O.key.value)) === O.key.value && (fe.parser === \"babel\" || fe.parser === \"acorn\" || fe.parser === \"espree\" || fe.parser === \"meriyah\" || fe.parser === \"__babel_estree\"));\n        }\n\n        function ge(O) {\n          return /^(?:\\d+|\\d+\\.\\d+)$/.test(O);\n        }\n\n        function Ae(O, fe) {\n          let Te = /^[fx]?(?:describe|it|test)$/;\n          return fe.type === \"TaggedTemplateExpression\" && fe.quasi === O && fe.tag.type === \"MemberExpression\" && fe.tag.property.type === \"Identifier\" && fe.tag.property.name === \"each\" && (fe.tag.object.type === \"Identifier\" && Te.test(fe.tag.object.name) || fe.tag.object.type === \"MemberExpression\" && fe.tag.object.property.type === \"Identifier\" && (fe.tag.object.property.name === \"only\" || fe.tag.object.property.name === \"skip\") && fe.tag.object.object.type === \"Identifier\" && Te.test(fe.tag.object.object.name));\n        }\n\n        function Ne(O) {\n          return O.quasis.some(fe => fe.value.raw.includes(\"\\n\"));\n        }\n\n        function ke(O, fe) {\n          return (O.type === \"TemplateLiteral\" && Ne(O) || O.type === \"TaggedTemplateExpression\" && Ne(O.quasi)) && !a(fe, c(O), {\n            backwards: !0\n          });\n        }\n\n        function ce(O) {\n          if (!se(O)) return !1;\n          let fe = s(He(O, Le.Dangling));\n          return fe && !d(fe);\n        }\n\n        function pe(O) {\n          if (O.length <= 1) return !1;\n          let fe = 0;\n\n          for (let Te of O) if (x(Te)) {\n            if (fe += 1, fe > 1) return !0;\n          } else if (ue(Te)) {\n            for (let $e of Te.arguments) if (x($e)) return !0;\n          }\n\n          return !1;\n        }\n\n        function de(O) {\n          let fe = O.getValue(),\n              Te = O.getParentNode();\n          return ue(fe) && ue(Te) && Te.callee === fe && fe.arguments.length > Te.arguments.length && Te.arguments.length > 0;\n        }\n\n        function ae(O, fe) {\n          if (fe >= 2) return !1;\n\n          let Te = Je => ae(Je, fe + 1),\n              $e = O.type === \"Literal\" && \"regex\" in O && O.regex.pattern || O.type === \"RegExpLiteral\" && O.pattern;\n\n          return $e && o($e) > 5 ? !1 : O.type === \"Literal\" || O.type === \"BigIntLiteral\" || O.type === \"DecimalLiteral\" || O.type === \"BooleanLiteral\" || O.type === \"NullLiteral\" || O.type === \"NumericLiteral\" || O.type === \"RegExpLiteral\" || O.type === \"StringLiteral\" || O.type === \"Identifier\" || O.type === \"ThisExpression\" || O.type === \"Super\" || O.type === \"PrivateName\" || O.type === \"PrivateIdentifier\" || O.type === \"ArgumentPlaceholder\" || O.type === \"Import\" ? !0 : O.type === \"TemplateLiteral\" ? O.quasis.every(Je => !Je.value.raw.includes(\"\\n\")) && O.expressions.every(Te) : O.type === \"ObjectExpression\" ? O.properties.every(Je => !Je.computed && (Je.shorthand || Je.value && Te(Je.value))) : O.type === \"ArrayExpression\" ? O.elements.every(Je => Je === null || Te(Je)) : ze(O) ? (O.type === \"ImportExpression\" || ae(O.callee, fe)) && Xe(O).every(Te) : De(O) ? ae(O.object, fe) && ae(O.property, fe) : O.type === \"UnaryExpression\" && (O.operator === \"!\" || O.operator === \"-\") ? ae(O.argument, fe) : O.type === \"TSNonNullExpression\" ? ae(O.expression, fe) : !1;\n        }\n\n        function ve(O) {\n          var fe, Te;\n          return (fe = (Te = O.extra) === null || Te === void 0 ? void 0 : Te.raw) !== null && fe !== void 0 ? fe : O.raw;\n        }\n\n        function K(O) {\n          return O;\n        }\n\n        function he(O) {\n          return O.filepath && /\\.tsx$/i.test(O.filepath);\n        }\n\n        function ye(O) {\n          let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"es5\";\n          return O.trailingComma === \"es5\" && fe === \"es5\" || O.trailingComma === \"all\" && (fe === \"all\" || fe === \"es5\");\n        }\n\n        function Ce(O, fe) {\n          switch (O = Ee(O), O.type) {\n            case \"FunctionExpression\":\n            case \"ClassExpression\":\n            case \"DoExpression\":\n              return fe;\n\n            case \"ObjectExpression\":\n              return !0;\n\n            case \"MemberExpression\":\n            case \"OptionalMemberExpression\":\n              return Ce(O.object, fe);\n\n            case \"TaggedTemplateExpression\":\n              return O.tag.type === \"FunctionExpression\" ? !1 : Ce(O.tag, fe);\n\n            case \"CallExpression\":\n            case \"OptionalCallExpression\":\n              return O.callee.type === \"FunctionExpression\" ? !1 : Ce(O.callee, fe);\n\n            case \"ConditionalExpression\":\n              return Ce(O.test, fe);\n\n            case \"UpdateExpression\":\n              return !O.prefix && Ce(O.argument, fe);\n\n            case \"BindExpression\":\n              return O.object && Ce(O.object, fe);\n\n            case \"SequenceExpression\":\n              return Ce(O.expressions[0], fe);\n\n            case \"TSAsExpression\":\n            case \"TSNonNullExpression\":\n              return Ce(O.expression, fe);\n\n            default:\n              return !1;\n          }\n        }\n\n        var Ie = {\n          \"==\": !0,\n          \"!=\": !0,\n          \"===\": !0,\n          \"!==\": !0\n        },\n            Fe = {\n          \"*\": !0,\n          \"/\": !0,\n          \"%\": !0\n        },\n            me = {\n          \">>\": !0,\n          \">>>\": !0,\n          \"<<\": !0\n        };\n\n        function _(O, fe) {\n          return !(ne(fe) !== ne(O) || O === \"**\" || Ie[O] && Ie[fe] || fe === \"%\" && Fe[O] || O === \"%\" && Fe[fe] || fe !== O && Fe[fe] && Fe[O] || me[O] && me[fe]);\n        }\n\n        var J = new Map([[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].flatMap((O, fe) => O.map(Te => [Te, fe])));\n\n        function ne(O) {\n          return J.get(O);\n        }\n\n        function Ee(O) {\n          for (; O.left;) O = O.left;\n\n          return O;\n        }\n\n        function We(O) {\n          return Boolean(me[O]) || O === \"|\" || O === \"^\" || O === \"&\";\n        }\n\n        function Be(O) {\n          var fe;\n          if (O.rest) return !0;\n          let Te = Se(O);\n          return ((fe = s(Te)) === null || fe === void 0 ? void 0 : fe.type) === \"RestElement\";\n        }\n\n        var Pe = new WeakMap();\n\n        function Se(O) {\n          if (Pe.has(O)) return Pe.get(O);\n          let fe = [];\n          return O.this && fe.push(O.this), Array.isArray(O.parameters) ? fe.push(...O.parameters) : Array.isArray(O.params) && fe.push(...O.params), O.rest && fe.push(O.rest), Pe.set(O, fe), fe;\n        }\n\n        function Qe(O, fe) {\n          let Te = O.getValue(),\n              $e = 0,\n              Je = Ze => fe(Ze, $e++);\n\n          Te.this && O.call(Je, \"this\"), Array.isArray(Te.parameters) ? O.each(Je, \"parameters\") : Array.isArray(Te.params) && O.each(Je, \"params\"), Te.rest && O.call(Je, \"rest\");\n        }\n\n        var xe = new WeakMap();\n\n        function Xe(O) {\n          if (xe.has(O)) return xe.get(O);\n          let fe = O.arguments;\n          return O.type === \"ImportExpression\" && (fe = [O.source], O.attributes && fe.push(O.attributes)), xe.set(O, fe), fe;\n        }\n\n        function _e(O, fe) {\n          let Te = O.getValue();\n          Te.type === \"ImportExpression\" ? (O.call($e => fe($e, 0), \"source\"), Te.attributes && O.call($e => fe($e, 1), \"attributes\")) : O.each(fe, \"arguments\");\n        }\n\n        function je(O) {\n          return O.value.trim() === \"prettier-ignore\" && !O.unignore;\n        }\n\n        function Re(O) {\n          return O && (O.prettierIgnore || se(O, Le.PrettierIgnore));\n        }\n\n        function be(O) {\n          let fe = O.getValue();\n          return Re(fe);\n        }\n\n        var Le = {\n          Leading: 1 << 1,\n          Trailing: 1 << 2,\n          Dangling: 1 << 3,\n          Block: 1 << 4,\n          Line: 1 << 5,\n          PrettierIgnore: 1 << 6,\n          First: 1 << 7,\n          Last: 1 << 8\n        },\n            qe = (O, fe) => {\n          if (typeof O == \"function\" && (fe = O, O = 0), O || fe) return (Te, $e, Je) => !(O & Le.Leading && !Te.leading || O & Le.Trailing && !Te.trailing || O & Le.Dangling && (Te.leading || Te.trailing) || O & Le.Block && !d(Te) || O & Le.Line && !C(Te) || O & Le.First && $e !== 0 || O & Le.Last && $e !== Je.length - 1 || O & Le.PrettierIgnore && !je(Te) || fe && !fe(Te));\n        };\n\n        function se(O, fe, Te) {\n          if (!u(O == null ? void 0 : O.comments)) return !1;\n          let $e = qe(fe, Te);\n          return $e ? O.comments.some($e) : !0;\n        }\n\n        function He(O, fe, Te) {\n          if (!Array.isArray(O == null ? void 0 : O.comments)) return [];\n          let $e = qe(fe, Te);\n          return $e ? O.comments.filter($e) : O.comments;\n        }\n\n        var Me = (O, fe) => {\n          let Te = fe.originalText;\n          return i(Te, v(O));\n        };\n\n        function ze(O) {\n          return ue(O) || O.type === \"NewExpression\" || O.type === \"ImportExpression\";\n        }\n\n        function nt(O) {\n          return O && (O.type === \"ObjectProperty\" || O.type === \"Property\" && !O.method && O.kind === \"init\");\n        }\n\n        function tt(O) {\n          return Boolean(O.__isUsingHackPipeline);\n        }\n\n        var pt = Symbol(\"ifWithoutBlockAndSameLineComment\");\n        n.exports = {\n          getFunctionParameters: Se,\n          iterateFunctionParametersPath: Qe,\n          getCallArguments: Xe,\n          iterateCallArgumentsPath: _e,\n          hasRestParameter: Be,\n          getLeftSide: I,\n          getLeftSidePathName: k,\n          getParentExportDeclaration: g,\n          getTypeScriptMappedTypeModifier: G,\n          hasFlowAnnotationComment: A,\n          hasFlowShorthandAnnotationComment: T,\n          hasLeadingOwnLineComment: U,\n          hasNakedLeftSide: B,\n          hasNode: S,\n          hasIgnoreComment: be,\n          hasNodeIgnoreComment: Re,\n          identity: K,\n          isBinaryish: H,\n          isCallLikeExpression: ze,\n          isEnabledHackPipeline: tt,\n          isLineComment: C,\n          isPrettierIgnoreComment: je,\n          isCallExpression: ue,\n          isMemberExpression: De,\n          isExportDeclaration: D,\n          isFlowAnnotationComment: z,\n          isFunctionCompositionArgs: pe,\n          isFunctionNotation: V,\n          isFunctionOrArrowExpression: x,\n          isGetterOrSetter: $,\n          isJestEachTemplateLiteral: Ae,\n          isJsxNode: M,\n          isLiteral: F,\n          isLongCurriedCallExpression: de,\n          isSimpleCallArgument: ae,\n          isMemberish: R,\n          isNumericLiteral: l,\n          isSignedNumericLiteral: E,\n          isObjectProperty: nt,\n          isObjectType: N,\n          isObjectTypePropertyAFunction: q,\n          isSimpleType: ee,\n          isSimpleNumber: ge,\n          isSimpleTemplateLiteral: ie,\n          isStringLiteral: y,\n          isStringPropSafeToUnquote: le,\n          isTemplateOnItsOwnLine: ke,\n          isTestCall: X,\n          isTheOnlyJsxElementInMarkdown: j,\n          isTSXFile: he,\n          isTypeAnnotationAFunction: Y,\n          isNextLineEmpty: Me,\n          needsHardlineAfterDanglingComment: ce,\n          rawText: ve,\n          shouldPrintComma: ye,\n          isBitwiseOperator: We,\n          shouldFlatten: _,\n          startsWithNoLookaheadToken: Ce,\n          getPrecedence: ne,\n          hasComment: se,\n          getComments: He,\n          CommentCheckFlags: Le,\n          markerForIfWithoutBlockAndSameLineComment: pt\n        };\n      }\n\n    }),\n        Lt = Z({\n      \"src/language-js/print/template-literal.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = it(),\n            _Ue5 = Ue(),\n            s = _Ue5.getStringWidth,\n            a = _Ue5.getIndentSize,\n            _Oe5 = Oe(),\n            _Oe5$builders = _Oe5.builders,\n            r = _Oe5$builders.join,\n            u = _Oe5$builders.hardline,\n            i = _Oe5$builders.softline,\n            o = _Oe5$builders.group,\n            c = _Oe5$builders.indent,\n            v = _Oe5$builders.align,\n            m = _Oe5$builders.lineSuffixBoundary,\n            d = _Oe5$builders.addAlignmentToDoc,\n            p = _Oe5.printer.printDocToString,\n            f = _Oe5.utils.mapDoc,\n            _Ke = Ke(),\n            h = _Ke.isBinaryish,\n            w = _Ke.isJestEachTemplateLiteral,\n            T = _Ke.isSimpleTemplateLiteral,\n            A = _Ke.hasComment,\n            S = _Ke.isMemberExpression;\n\n        function B(g, F, l) {\n          let E = g.getValue();\n\n          if (E.type === \"TemplateLiteral\" && w(E, g.getParentNode())) {\n            let M = I(g, l, F);\n            if (M) return M;\n          }\n\n          let N = \"expressions\";\n          E.type === \"TSTemplateLiteralType\" && (N = \"types\");\n          let x = [],\n              b = g.map(F, N),\n              L = T(E);\n          return L && (b = b.map(M => p(M, Object.assign(Object.assign({}, l), {}, {\n            printWidth: Number.POSITIVE_INFINITY\n          })).formatted)), x.push(m, \"`\"), g.each(M => {\n            let j = M.getName();\n\n            if (x.push(F()), j < b.length) {\n              let $ = l.tabWidth,\n                  V = M.getValue(),\n                  q = a(V.value.raw, $),\n                  Y = b[j];\n\n              if (!L) {\n                let R = E[N][j];\n                (A(R) || S(R) || R.type === \"ConditionalExpression\" || R.type === \"SequenceExpression\" || R.type === \"TSAsExpression\" || h(R)) && (Y = [c([i, Y]), i]);\n              }\n\n              let H = q === 0 && V.value.raw.endsWith(\"\\n\") ? v(Number.NEGATIVE_INFINITY, Y) : d(Y, q, $);\n              x.push(o([\"${\", H, m, \"}\"]));\n            }\n          }, \"quasis\"), x.push(\"`\"), x;\n        }\n\n        function I(g, F, l) {\n          let E = g.getNode(),\n              y = E.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n          if (y.length > 1 || y.some(N => N.length > 0)) {\n            F.__inJestEach = !0;\n            let N = g.map(l, \"expressions\");\n            F.__inJestEach = !1;\n            let x = [],\n                b = N.map(V => \"${\" + p(V, Object.assign(Object.assign({}, F), {}, {\n              printWidth: Number.POSITIVE_INFINITY,\n              endOfLine: \"lf\"\n            })).formatted + \"}\"),\n                L = [{\n              hasLineBreak: !1,\n              cells: []\n            }];\n\n            for (let V = 1; V < E.quasis.length; V++) {\n              let q = t(L),\n                  Y = b[V - 1];\n              q.cells.push(Y), Y.includes(\"\\n\") && (q.hasLineBreak = !0), E.quasis[V].value.raw.includes(\"\\n\") && L.push({\n                hasLineBreak: !1,\n                cells: []\n              });\n            }\n\n            let M = Math.max(y.length, ...L.map(V => V.cells.length)),\n                j = Array.from({\n              length: M\n            }).fill(0),\n                $ = [{\n              cells: y\n            }, ...L.filter(V => V.cells.length > 0)];\n\n            for (let _ref21 of $.filter(q => !q.hasLineBreak)) {\n              let V = _ref21.cells;\n\n              for (let _ref22 of V.entries()) {\n                var _ref23 = _slicedToArray(_ref22, 2);\n\n                let q = _ref23[0];\n                let Y = _ref23[1];\n                j[q] = Math.max(j[q], s(Y));\n              }\n            }\n\n            return x.push(m, \"`\", c([u, r(u, $.map(V => r(\" | \", V.cells.map((q, Y) => V.hasLineBreak ? q : q + \" \".repeat(j[Y] - s(q))))))]), u, \"`\"), x;\n          }\n        }\n\n        function k(g, F) {\n          let l = g.getValue(),\n              E = F();\n          return A(l) && (E = o([c([i, E]), i])), [\"${\", E, m, \"}\"];\n        }\n\n        function P(g, F) {\n          return g.map(l => k(l, F), \"expressions\");\n        }\n\n        function C(g, F) {\n          return f(g, l => typeof l == \"string\" ? F ? l.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : D(l) : l);\n        }\n\n        function D(g) {\n          return g.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");\n        }\n\n        n.exports = {\n          printTemplateLiteral: B,\n          printTemplateExpressions: P,\n          escapeTemplateCharacters: C,\n          uncookTemplateElementValue: D\n        };\n      }\n\n    }),\n        wm = Z({\n      \"src/language-js/embed/markdown.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe6 = Oe(),\n            _Oe6$builders = _Oe6.builders,\n            t = _Oe6$builders.indent,\n            s = _Oe6$builders.softline,\n            a = _Oe6$builders.literalline,\n            r = _Oe6$builders.dedentToRoot,\n            _Lt = Lt(),\n            u = _Lt.escapeTemplateCharacters;\n\n        function i(c, v, m) {\n          let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, (T, A) => \"\\\\\".repeat(A.length / 2) + \"`\"),\n              f = o(p),\n              h = f !== \"\";\n          h && (p = p.replace(new RegExp(\"^\".concat(f), \"gm\"), \"\"));\n          let w = u(m(p, {\n            parser: \"markdown\",\n            __inJsTemplate: !0\n          }, {\n            stripTrailingHardline: !0\n          }), !0);\n          return [\"`\", h ? t([s, w]) : [a, r(w)], s, \"`\"];\n        }\n\n        function o(c) {\n          let v = c.match(/^([^\\S\\n]*)\\S/m);\n          return v === null ? \"\" : v[1];\n        }\n\n        n.exports = i;\n      }\n\n    }),\n        _m = Z({\n      \"src/language-js/embed/css.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue6 = Ue(),\n            t = _Ue6.isNonEmptyArray,\n            _Oe7 = Oe(),\n            _Oe7$builders = _Oe7.builders,\n            s = _Oe7$builders.indent,\n            a = _Oe7$builders.hardline,\n            r = _Oe7$builders.softline,\n            _Oe7$utils = _Oe7.utils,\n            u = _Oe7$utils.mapDoc,\n            i = _Oe7$utils.replaceEndOfLine,\n            o = _Oe7$utils.cleanDoc,\n            _Lt2 = Lt(),\n            c = _Lt2.printTemplateExpressions;\n\n        function v(p, f, h) {\n          let w = p.getValue(),\n              T = w.quasis.map(k => k.value.raw),\n              A = 0,\n              S = T.reduce((k, P, C) => C === 0 ? P : k + \"@prettier-placeholder-\" + A++ + \"-id\" + P, \"\"),\n              B = h(S, {\n            parser: \"scss\"\n          }, {\n            stripTrailingHardline: !0\n          }),\n              I = c(p, f);\n          return m(B, w, I);\n        }\n\n        function m(p, f, h) {\n          if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return \"``\";\n          let T = d(p, h);\n          if (!T) throw new Error(\"Couldn't insert all the expressions\");\n          return [\"`\", s([a, T]), r, \"`\"];\n        }\n\n        function d(p, f) {\n          if (!t(f)) return p;\n          let h = 0,\n              w = u(o(p), T => typeof T != \"string\" || !T.includes(\"@prettier-placeholder\") ? T : T.split(/@prettier-placeholder-(\\d+)-id/).map((A, S) => S % 2 === 0 ? i(A) : (h++, f[A])));\n          return f.length === h ? w : null;\n        }\n\n        n.exports = v;\n      }\n\n    }),\n        Pm = Z({\n      \"src/language-js/embed/graphql.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe8 = Oe(),\n            _Oe8$builders = _Oe8.builders,\n            t = _Oe8$builders.indent,\n            s = _Oe8$builders.join,\n            a = _Oe8$builders.hardline,\n            _Lt3 = Lt(),\n            r = _Lt3.escapeTemplateCharacters,\n            u = _Lt3.printTemplateExpressions;\n\n        function i(c, v, m) {\n          let d = c.getValue(),\n              p = d.quasis.length;\n          if (p === 1 && d.quasis[0].value.raw.trim() === \"\") return \"``\";\n          let f = u(c, v),\n              h = [];\n\n          for (let w = 0; w < p; w++) {\n            let T = d.quasis[w],\n                A = w === 0,\n                S = w === p - 1,\n                B = T.value.cooked,\n                I = B.split(\"\\n\"),\n                k = I.length,\n                P = f[w],\n                C = k > 2 && I[0].trim() === \"\" && I[1].trim() === \"\",\n                D = k > 2 && I[k - 1].trim() === \"\" && I[k - 2].trim() === \"\",\n                g = I.every(l => /^\\s*(?:#[^\\n\\r]*)?$/.test(l));\n            if (!S && /#[^\\n\\r]*$/.test(I[k - 1])) return null;\n            let F = null;\n            g ? F = o(I) : F = m(B, {\n              parser: \"graphql\"\n            }, {\n              stripTrailingHardline: !0\n            }), F ? (F = r(F, !1), !A && C && h.push(\"\"), h.push(F), !S && D && h.push(\"\")) : !A && !S && C && h.push(\"\"), P && h.push(P);\n          }\n\n          return [\"`\", t([a, s(a, h)]), a, \"`\"];\n        }\n\n        function o(c) {\n          let v = [],\n              m = !1,\n              d = c.map(p => p.trim());\n\n          for (let _ref24 of d.entries()) {\n            var _ref25 = _slicedToArray(_ref24, 2);\n\n            let p = _ref25[0];\n            let f = _ref25[1];\n            f !== \"\" && (d[p - 1] === \"\" && m ? v.push([a, f]) : v.push(f), m = !0);\n          }\n\n          return v.length === 0 ? null : s(a, v);\n        }\n\n        n.exports = i;\n      }\n\n    }),\n        km = Z({\n      \"src/language-js/embed/html.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe9 = Oe(),\n            _Oe9$builders = _Oe9.builders,\n            t = _Oe9$builders.indent,\n            s = _Oe9$builders.line,\n            a = _Oe9$builders.hardline,\n            r = _Oe9$builders.group,\n            u = _Oe9.utils.mapDoc,\n            _Lt4 = Lt(),\n            i = _Lt4.printTemplateExpressions,\n            o = _Lt4.uncookTemplateElementValue,\n            c = 0;\n\n        function v(m, d, p, f, h) {\n          let w = h.parser,\n              T = m.getValue(),\n              A = c;\n          c = c + 1 >>> 0;\n\n          let S = E => \"PRETTIER_HTML_PLACEHOLDER_\".concat(E, \"_\").concat(A, \"_IN_JS\"),\n              B = T.quasis.map((E, y, N) => y === N.length - 1 ? E.value.cooked : E.value.cooked + S(y)).join(\"\"),\n              I = i(m, d);\n\n          if (I.length === 0 && B.trim().length === 0) return \"``\";\n          let k = new RegExp(S(\"(\\\\d+)\"), \"g\"),\n              P = 0,\n              C = p(B, {\n            parser: w,\n\n            __onHtmlRoot(E) {\n              P = E.children.length;\n            }\n\n          }, {\n            stripTrailingHardline: !0\n          }),\n              D = u(C, E => {\n            if (typeof E != \"string\") return E;\n            let y = [],\n                N = E.split(k);\n\n            for (let x = 0; x < N.length; x++) {\n              let b = N[x];\n\n              if (x % 2 === 0) {\n                b && (b = o(b), f.__embeddedInHtml && (b = b.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\")), y.push(b));\n                continue;\n              }\n\n              let L = Number(b);\n              y.push(I[L]);\n            }\n\n            return y;\n          }),\n              g = /^\\s/.test(B) ? \" \" : \"\",\n              F = /\\s$/.test(B) ? \" \" : \"\",\n              l = f.htmlWhitespaceSensitivity === \"ignore\" ? a : g && F ? s : null;\n          return r(l ? [\"`\", t([l, r(D)]), l, \"`\"] : [\"`\", g, P > 1 ? t(r(D)) : r(D), F, \"`\"]);\n        }\n\n        n.exports = v;\n      }\n\n    }),\n        Im = Z({\n      \"src/language-js/embed.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ke2 = Ke(),\n            t = _Ke2.hasComment,\n            s = _Ke2.CommentCheckFlags,\n            a = _Ke2.isObjectProperty,\n            r = wm(),\n            u = _m(),\n            i = Pm(),\n            o = km();\n\n        function c(C) {\n          if (d(C) || w(C) || T(C) || p(C)) return \"css\";\n          if (B(C)) return \"graphql\";\n          if (k(C)) return \"html\";\n          if (f(C)) return \"angular\";\n          if (m(C)) return \"markdown\";\n        }\n\n        function v(C, D, g, F) {\n          let l = C.getValue();\n          if (l.type !== \"TemplateLiteral\" || P(l)) return;\n          let E = c(C);\n\n          if (!!E) {\n            if (E === \"markdown\") return r(C, D, g);\n            if (E === \"css\") return u(C, D, g);\n            if (E === \"graphql\") return i(C, D, g);\n            if (E === \"html\" || E === \"angular\") return o(C, D, g, F, {\n              parser: E\n            });\n          }\n        }\n\n        function m(C) {\n          let D = C.getValue(),\n              g = C.getParentNode();\n          return g && g.type === \"TaggedTemplateExpression\" && D.quasis.length === 1 && g.tag.type === \"Identifier\" && (g.tag.name === \"md\" || g.tag.name === \"markdown\");\n        }\n\n        function d(C) {\n          let D = C.getValue(),\n              g = C.getParentNode(),\n              F = C.getParentNode(1);\n          return F && D.quasis && g.type === \"JSXExpressionContainer\" && F.type === \"JSXElement\" && F.openingElement.name.name === \"style\" && F.openingElement.attributes.some(l => l.name.name === \"jsx\") || g && g.type === \"TaggedTemplateExpression\" && g.tag.type === \"Identifier\" && g.tag.name === \"css\" || g && g.type === \"TaggedTemplateExpression\" && g.tag.type === \"MemberExpression\" && g.tag.object.name === \"css\" && (g.tag.property.name === \"global\" || g.tag.property.name === \"resolve\");\n        }\n\n        function p(C) {\n          return C.match(D => D.type === \"TemplateLiteral\", (D, g) => D.type === \"ArrayExpression\" && g === \"elements\", (D, g) => a(D) && D.key.type === \"Identifier\" && D.key.name === \"styles\" && g === \"value\", ...h);\n        }\n\n        function f(C) {\n          return C.match(D => D.type === \"TemplateLiteral\", (D, g) => a(D) && D.key.type === \"Identifier\" && D.key.name === \"template\" && g === \"value\", ...h);\n        }\n\n        var h = [(C, D) => C.type === \"ObjectExpression\" && D === \"properties\", (C, D) => C.type === \"CallExpression\" && C.callee.type === \"Identifier\" && C.callee.name === \"Component\" && D === \"arguments\", (C, D) => C.type === \"Decorator\" && D === \"expression\"];\n\n        function w(C) {\n          let D = C.getParentNode();\n          if (!D || D.type !== \"TaggedTemplateExpression\") return !1;\n          let g = D.tag.type === \"ParenthesizedExpression\" ? D.tag.expression : D.tag;\n\n          switch (g.type) {\n            case \"MemberExpression\":\n              return A(g.object) || S(g);\n\n            case \"CallExpression\":\n              return A(g.callee) || g.callee.type === \"MemberExpression\" && (g.callee.object.type === \"MemberExpression\" && (A(g.callee.object.object) || S(g.callee.object)) || g.callee.object.type === \"CallExpression\" && A(g.callee.object.callee));\n\n            case \"Identifier\":\n              return g.name === \"css\";\n\n            default:\n              return !1;\n          }\n        }\n\n        function T(C) {\n          let D = C.getParentNode(),\n              g = C.getParentNode(1);\n          return g && D.type === \"JSXExpressionContainer\" && g.type === \"JSXAttribute\" && g.name.type === \"JSXIdentifier\" && g.name.name === \"css\";\n        }\n\n        function A(C) {\n          return C.type === \"Identifier\" && C.name === \"styled\";\n        }\n\n        function S(C) {\n          return /^[A-Z]/.test(C.object.name) && C.property.name === \"extend\";\n        }\n\n        function B(C) {\n          let D = C.getValue(),\n              g = C.getParentNode();\n          return I(D, \"GraphQL\") || g && (g.type === \"TaggedTemplateExpression\" && (g.tag.type === \"MemberExpression\" && g.tag.object.name === \"graphql\" && g.tag.property.name === \"experimental\" || g.tag.type === \"Identifier\" && (g.tag.name === \"gql\" || g.tag.name === \"graphql\")) || g.type === \"CallExpression\" && g.callee.type === \"Identifier\" && g.callee.name === \"graphql\");\n        }\n\n        function I(C, D) {\n          return t(C, s.Block | s.Leading, g => {\n            let F = g.value;\n            return F === \" \".concat(D, \" \");\n          });\n        }\n\n        function k(C) {\n          return I(C.getValue(), \"HTML\") || C.match(D => D.type === \"TemplateLiteral\", (D, g) => D.type === \"TaggedTemplateExpression\" && D.tag.type === \"Identifier\" && D.tag.name === \"html\" && g === \"quasi\");\n        }\n\n        function P(C) {\n          let D = C.quasis;\n          return D.some(g => {\n            let F = g.value.cooked;\n            return F === null;\n          });\n        }\n\n        n.exports = v;\n      }\n\n    }),\n        Lm = Z({\n      \"src/language-js/clean.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = It(),\n            s = new Set([\"range\", \"raw\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"extra\", \"start\", \"end\", \"loc\", \"flags\", \"errors\", \"tokens\"]),\n            a = u => {\n          for (let i of u.quasis) delete i.value;\n        };\n\n        function r(u, i, o) {\n          if (u.type === \"Program\" && delete i.sourceType, (u.type === \"BigIntLiteral\" || u.type === \"BigIntLiteralTypeAnnotation\") && i.value && (i.value = i.value.toLowerCase()), (u.type === \"BigIntLiteral\" || u.type === \"Literal\") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === \"DecimalLiteral\" && (i.value = Number(i.value)), u.type === \"Literal\" && i.decimal && (i.decimal = Number(i.decimal)), u.type === \"EmptyStatement\" || u.type === \"JSXText\" || u.type === \"JSXExpressionContainer\" && (u.expression.type === \"Literal\" || u.expression.type === \"StringLiteral\") && u.expression.value === \" \") return null;\n          if ((u.type === \"Property\" || u.type === \"ObjectProperty\" || u.type === \"MethodDefinition\" || u.type === \"ClassProperty\" || u.type === \"ClassMethod\" || u.type === \"PropertyDefinition\" || u.type === \"TSDeclareMethod\" || u.type === \"TSPropertySignature\" || u.type === \"ObjectTypeProperty\") && typeof u.key == \"object\" && u.key && (u.key.type === \"Literal\" || u.key.type === \"NumericLiteral\" || u.key.type === \"StringLiteral\" || u.key.type === \"Identifier\") && delete i.key, u.type === \"JSXElement\" && u.openingElement.name.name === \"style\" && u.openingElement.attributes.some(m => m.name.name === \"jsx\")) for (let _ref26 of i.children) {\n            let m = _ref26.type;\n            let d = _ref26.expression;\n            m === \"JSXExpressionContainer\" && d.type === \"TemplateLiteral\" && a(d);\n          }\n          u.type === \"JSXAttribute\" && u.name.name === \"css\" && u.value.type === \"JSXExpressionContainer\" && u.value.expression.type === \"TemplateLiteral\" && a(i.value.expression), u.type === \"JSXAttribute\" && u.value && u.value.type === \"Literal\" && /[\"']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/[\"']|&quot;|&apos;/g, '\"'));\n          let c = u.expression || u.callee;\n\n          if (u.type === \"Decorator\" && c.type === \"CallExpression\" && c.callee.name === \"Component\" && c.arguments.length === 1) {\n            let m = u.expression.arguments[0].properties;\n\n            for (let _ref27 of i.expression.arguments[0].properties.entries()) {\n              var _ref28 = _slicedToArray(_ref27, 2);\n\n              let d = _ref28[0];\n              let p = _ref28[1];\n\n              switch (m[d].key.name) {\n                case \"styles\":\n                  p.value.type === \"ArrayExpression\" && a(p.value.elements[0]);\n                  break;\n\n                case \"template\":\n                  p.value.type === \"TemplateLiteral\" && a(p.value);\n                  break;\n              }\n            }\n          }\n\n          if (u.type === \"TaggedTemplateExpression\" && (u.tag.type === \"MemberExpression\" || u.tag.type === \"Identifier\" && (u.tag.name === \"gql\" || u.tag.name === \"graphql\" || u.tag.name === \"css\" || u.tag.name === \"md\" || u.tag.name === \"markdown\" || u.tag.name === \"html\") || u.tag.type === \"CallExpression\") && a(i.quasi), u.type === \"TemplateLiteral\") {\n            var v;\n            (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some(d => t(d) && [\"GraphQL\", \"HTML\"].some(p => d.value === \" \".concat(p, \" \")))) || o.type === \"CallExpression\" && o.callee.name === \"graphql\" || !u.leadingComments) && a(i);\n          }\n\n          if (u.type === \"InterpreterDirective\" && (i.value = i.value.trimEnd()), (u.type === \"TSIntersectionType\" || u.type === \"TSUnionType\") && u.types.length === 1) return i.types[0];\n        }\n\n        r.ignoredProperties = s, n.exports = r;\n      }\n\n    }),\n        Ha = {};\n\n    Ut(Ha, {\n      EOL: () => Pn,\n      arch: () => jm,\n      cpus: () => Ya,\n      default: () => ro,\n      endianness: () => Ga,\n      freemem: () => Xa,\n      getNetworkInterfaces: () => to,\n      hostname: () => Ja,\n      loadavg: () => Ua,\n      networkInterfaces: () => eo,\n      platform: () => Om,\n      release: () => Za,\n      tmpDir: () => wn,\n      tmpdir: () => _n,\n      totalmem: () => Ka,\n      type: () => Qa,\n      uptime: () => za\n    });\n\n    function Ga() {\n      if (typeof Sr > \"u\") {\n        var e = new ArrayBuffer(2),\n            n = new Uint8Array(e),\n            t = new Uint16Array(e);\n        if (n[0] = 1, n[1] = 2, t[0] === 258) Sr = \"BE\";else if (t[0] === 513) Sr = \"LE\";else throw new Error(\"unable to figure out endianess\");\n      }\n\n      return Sr;\n    }\n\n    function Ja() {\n      return typeof globalThis.location < \"u\" ? globalThis.location.hostname : \"\";\n    }\n\n    function Ua() {\n      return [];\n    }\n\n    function za() {\n      return 0;\n    }\n\n    function Xa() {\n      return Number.MAX_VALUE;\n    }\n\n    function Ka() {\n      return Number.MAX_VALUE;\n    }\n\n    function Ya() {\n      return [];\n    }\n\n    function Qa() {\n      return \"Browser\";\n    }\n\n    function Za() {\n      return typeof globalThis.navigator < \"u\" ? globalThis.navigator.appVersion : \"\";\n    }\n\n    function eo() {}\n\n    function to() {}\n\n    function jm() {\n      return \"javascript\";\n    }\n\n    function Om() {\n      return \"browser\";\n    }\n\n    function wn() {\n      return \"/tmp\";\n    }\n\n    var Sr,\n        _n,\n        Pn,\n        ro,\n        qm = mt({\n      \"node-modules-polyfills:os\"() {\n        re(), _n = wn, Pn = \"\\n\", ro = {\n          EOL: Pn,\n          tmpdir: _n,\n          tmpDir: wn,\n          networkInterfaces: eo,\n          getNetworkInterfaces: to,\n          release: Za,\n          type: Qa,\n          cpus: Ya,\n          totalmem: Ka,\n          freemem: Xa,\n          uptime: za,\n          loadavg: Ua,\n          hostname: Ja,\n          endianness: Ga\n        };\n      }\n\n    }),\n        Mm = Z({\n      \"node-modules-polyfills-commonjs:os\"(e, n) {\n        re();\n        var t = (qm(), lt(Ha));\n\n        if (t && t.default) {\n          n.exports = t.default;\n\n          for (let s in t) n.exports[s] = t[s];\n        } else t && (n.exports = t);\n      }\n\n    }),\n        Rm = Z({\n      \"node_modules/detect-newline/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = s => {\n          if (typeof s != \"string\") throw new TypeError(\"Expected a string\");\n          let a = s.match(/(?:\\r?\\n)/g) || [];\n          if (a.length === 0) return;\n          let r = a.filter(i => i === \"\\r\\n\").length,\n              u = a.length - r;\n          return r > u ? \"\\r\\n\" : \"\\n\";\n        };\n\n        n.exports = t, n.exports.graceful = s => typeof s == \"string\" && t(s) || \"\\n\";\n      }\n\n    }),\n        Vm = Z({\n      \"node_modules/jest-docblock/build/index.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.extract = p, e.parse = h, e.parseWithComments = w, e.print = T, e.strip = f;\n\n        function n() {\n          let S = Mm();\n          return n = function () {\n            return S;\n          }, S;\n        }\n\n        function t() {\n          let S = s(Rm());\n          return t = function () {\n            return S;\n          }, S;\n        }\n\n        function s(S) {\n          return S && S.__esModule ? S : {\n            default: S\n          };\n        }\n\n        var a = /\\*\\/$/,\n            r = /^\\/\\*\\*/,\n            u = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/,\n            i = /(^|\\s+)\\/\\/([^\\r\\n]*)/g,\n            o = /^(\\r?\\n)+/,\n            c = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g,\n            v = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g,\n            m = /(\\r?\\n|^) *\\* ?/g,\n            d = [];\n\n        function p(S) {\n          let B = S.match(u);\n          return B ? B[0].trimLeft() : \"\";\n        }\n\n        function f(S) {\n          let B = S.match(u);\n          return B && B[0] ? S.substring(B[0].length) : S;\n        }\n\n        function h(S) {\n          return w(S).pragmas;\n        }\n\n        function w(S) {\n          let B = (0, t().default)(S) || n().EOL;\n          S = S.replace(r, \"\").replace(a, \"\").replace(m, \"$1\");\n          let I = \"\";\n\n          for (; I !== S;) I = S, S = S.replace(c, \"\".concat(B, \"$1 $2\").concat(B));\n\n          S = S.replace(o, \"\").trimRight();\n          let k = Object.create(null),\n              P = S.replace(v, \"\").replace(o, \"\").trimRight(),\n              C;\n\n          for (; C = v.exec(S);) {\n            let D = C[2].replace(i, \"\");\n            typeof k[C[1]] == \"string\" || Array.isArray(k[C[1]]) ? k[C[1]] = d.concat(k[C[1]], D) : k[C[1]] = D;\n          }\n\n          return {\n            comments: P,\n            pragmas: k\n          };\n        }\n\n        function T(S) {\n          let _S$comments = S.comments,\n              B = _S$comments === void 0 ? \"\" : _S$comments,\n              _S$pragmas = S.pragmas,\n              I = _S$pragmas === void 0 ? {} : _S$pragmas,\n              k = (0, t().default)(B) || n().EOL,\n              P = \"/**\",\n              C = \" *\",\n              D = \" */\",\n              g = Object.keys(I),\n              F = g.map(E => A(E, I[E])).reduce((E, y) => E.concat(y), []).map(E => C + \" \" + E + k).join(\"\");\n\n          if (!B) {\n            if (g.length === 0) return \"\";\n\n            if (g.length === 1 && !Array.isArray(I[g[0]])) {\n              let E = I[g[0]];\n              return \"\".concat(P, \" \").concat(A(g[0], E)[0]).concat(D);\n            }\n          }\n\n          let l = B.split(k).map(E => \"\".concat(C, \" \").concat(E)).join(k) + k;\n          return P + k + (B ? l : \"\") + (B && g.length ? C + k : \"\") + F + D;\n        }\n\n        function A(S, B) {\n          return d.concat(B).map(I => \"@\".concat(S, \" \").concat(I).trim());\n        }\n      }\n\n    }),\n        Wm = Z({\n      \"src/language-js/utils/get-shebang.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s) {\n          if (!s.startsWith(\"#!\")) return \"\";\n          let a = s.indexOf(\"\\n\");\n          return a === -1 ? s : s.slice(0, a);\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        no = Z({\n      \"src/language-js/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Vm = Vm(),\n            t = _Vm.parseWithComments,\n            s = _Vm.strip,\n            a = _Vm.extract,\n            r = _Vm.print,\n            _jn3 = jn(),\n            u = _jn3.normalizeEndOfLine,\n            i = Wm();\n\n        function o(m) {\n          let d = i(m);\n          d && (m = m.slice(d.length + 1));\n\n          let p = a(m),\n              _t2 = t(p),\n              f = _t2.pragmas,\n              h = _t2.comments;\n\n          return {\n            shebang: d,\n            text: m,\n            pragmas: f,\n            comments: h\n          };\n        }\n\n        function c(m) {\n          let d = Object.keys(o(m).pragmas);\n          return d.includes(\"prettier\") || d.includes(\"format\");\n        }\n\n        function v(m) {\n          let _o2 = o(m),\n              d = _o2.shebang,\n              p = _o2.text,\n              f = _o2.pragmas,\n              h = _o2.comments,\n              w = s(p),\n              T = r({\n            pragmas: Object.assign({\n              format: \"\"\n            }, f),\n            comments: h.trimStart()\n          });\n\n          return (d ? \"\".concat(d, \"\\n\") : \"\") + u(T) + (w.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") + w;\n        }\n\n        n.exports = {\n          hasPragma: c,\n          insertPragma: v\n        };\n      }\n\n    }),\n        uo = Z({\n      \"src/language-js/comments.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue7 = Ue(),\n            t = _Ue7.getLast,\n            s = _Ue7.hasNewline,\n            a = _Ue7.getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n            r = _Ue7.getNextNonSpaceNonCommentCharacter,\n            u = _Ue7.hasNewlineInRange,\n            i = _Ue7.addLeadingComment,\n            o = _Ue7.addTrailingComment,\n            c = _Ue7.addDanglingComment,\n            v = _Ue7.getNextNonSpaceNonCommentCharacterIndex,\n            m = _Ue7.isNonEmptyArray,\n            _Ke3 = Ke(),\n            d = _Ke3.getFunctionParameters,\n            p = _Ke3.isPrettierIgnoreComment,\n            f = _Ke3.isJsxNode,\n            h = _Ke3.hasFlowShorthandAnnotationComment,\n            w = _Ke3.hasFlowAnnotationComment,\n            T = _Ke3.hasIgnoreComment,\n            A = _Ke3.isCallLikeExpression,\n            S = _Ke3.getCallArguments,\n            B = _Ke3.isCallExpression,\n            I = _Ke3.isMemberExpression,\n            k = _Ke3.isObjectProperty,\n            P = _Ke3.isLineComment,\n            C = _Ke3.getComments,\n            D = _Ke3.CommentCheckFlags,\n            g = _Ke3.markerForIfWithoutBlockAndSameLineComment,\n            _st2 = st(),\n            F = _st2.locStart,\n            l = _st2.locEnd,\n            E = It();\n\n        function y(me) {\n          return [ve, De, q, j, $, V, Q, Ae, U, ge, Ne, ke, te, ie, G].some(_ => _(me));\n        }\n\n        function N(me) {\n          return [M, De, Y, Ne, j, $, V, Q, ie, z, le, ge, de, G, he].some(_ => _(me));\n        }\n\n        function x(me) {\n          return [ve, j, $, H, ue, te, ge, X, W, K, G, ae].some(_ => _(me));\n        }\n\n        function b(me, _) {\n          let J = (me.body || me.properties).find(ne => {\n            let Ee = ne.type;\n            return Ee !== \"EmptyStatement\";\n          });\n          J ? i(J, _) : c(me, _);\n        }\n\n        function L(me, _) {\n          me.type === \"BlockStatement\" ? b(me, _) : i(me, _);\n        }\n\n        function M(me) {\n          let _ = me.comment,\n              J = me.followingNode;\n          return J && Ie(_) ? (i(J, _), !0) : !1;\n        }\n\n        function j(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode,\n              We = me.text;\n          if ((ne == null ? void 0 : ne.type) !== \"IfStatement\" || !Ee) return !1;\n          if (r(We, _, l) === \")\") return o(J, _), !0;\n\n          if (J === ne.consequent && Ee === ne.alternate) {\n            if (J.type === \"BlockStatement\") o(J, _);else {\n              let Pe = _.type === \"SingleLine\" || _.loc.start.line === _.loc.end.line,\n                  Se = _.loc.start.line === J.loc.start.line;\n              Pe && Se ? c(J, _, g) : c(ne, _);\n            }\n            return !0;\n          }\n\n          return Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : Ee.type === \"IfStatement\" ? (L(Ee.consequent, _), !0) : ne.consequent === Ee ? (i(Ee, _), !0) : !1;\n        }\n\n        function $(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode,\n              We = me.text;\n          return (ne == null ? void 0 : ne.type) !== \"WhileStatement\" || !Ee ? !1 : r(We, _, l) === \")\" ? (o(J, _), !0) : Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : ne.body === Ee ? (i(Ee, _), !0) : !1;\n        }\n\n        function V(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode;\n          return (ne == null ? void 0 : ne.type) !== \"TryStatement\" && (ne == null ? void 0 : ne.type) !== \"CatchClause\" || !Ee ? !1 : ne.type === \"CatchClause\" && J ? (o(J, _), !0) : Ee.type === \"BlockStatement\" ? (b(Ee, _), !0) : Ee.type === \"TryStatement\" ? (L(Ee.finalizer, _), !0) : Ee.type === \"CatchClause\" ? (L(Ee.body, _), !0) : !1;\n        }\n\n        function q(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode;\n          return I(J) && (ne == null ? void 0 : ne.type) === \"Identifier\" ? (i(J, _), !0) : !1;\n        }\n\n        function Y(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode,\n              We = me.text,\n              Be = J && !u(We, l(J), F(_));\n          return (!J || !Be) && ((ne == null ? void 0 : ne.type) === \"ConditionalExpression\" || (ne == null ? void 0 : ne.type) === \"TSConditionalType\") && Ee ? (i(Ee, _), !0) : !1;\n        }\n\n        function H(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode;\n          return k(ne) && ne.shorthand && ne.key === J && ne.value.type === \"AssignmentPattern\" ? (o(ne.value.left, _), !0) : !1;\n        }\n\n        var R = new Set([\"ClassDeclaration\", \"ClassExpression\", \"DeclareClass\", \"DeclareInterface\", \"InterfaceDeclaration\", \"TSInterfaceDeclaration\"]);\n\n        function Q(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode;\n\n          if (R.has(ne == null ? void 0 : ne.type)) {\n            if (m(ne.decorators) && !(Ee && Ee.type === \"Decorator\")) return o(t(ne.decorators), _), !0;\n            if (ne.body && Ee === ne.body) return b(ne.body, _), !0;\n\n            if (Ee) {\n              if (ne.superClass && Ee === ne.superClass && J && (J === ne.id || J === ne.typeParameters)) return o(J, _), !0;\n\n              for (let We of [\"implements\", \"extends\", \"mixins\"]) if (ne[We] && Ee === ne[We][0]) return J && (J === ne.id || J === ne.typeParameters || J === ne.superClass) ? o(J, _) : c(ne, _, We), !0;\n            }\n          }\n\n          return !1;\n        }\n\n        var ee = new Set([\"ClassMethod\", \"ClassProperty\", \"PropertyDefinition\", \"TSAbstractPropertyDefinition\", \"TSAbstractMethodDefinition\", \"TSDeclareMethod\", \"MethodDefinition\"]);\n\n        function te(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.text;\n          return ne && J && r(Ee, _, l) === \"(\" && (ne.type === \"Property\" || ne.type === \"TSDeclareMethod\" || ne.type === \"TSAbstractMethodDefinition\") && J.type === \"Identifier\" && ne.key === J && r(Ee, J, l) !== \":\" || (J == null ? void 0 : J.type) === \"Decorator\" && ee.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;\n        }\n\n        var oe = new Set([\"FunctionDeclaration\", \"FunctionExpression\", \"ClassMethod\", \"MethodDefinition\", \"ObjectMethod\"]);\n\n        function W(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.text;\n          return r(Ee, _, l) !== \"(\" ? !1 : J && oe.has(ne == null ? void 0 : ne.type) ? (o(J, _), !0) : !1;\n        }\n\n        function X(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.text;\n          if ((J == null ? void 0 : J.type) !== \"ArrowFunctionExpression\") return !1;\n          let Ee = v(ne, _, l);\n          return Ee !== !1 && ne.slice(Ee, Ee + 2) === \"=>\" ? (c(J, _), !0) : !1;\n        }\n\n        function ue(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.text;\n          return r(ne, _, l) !== \")\" ? !1 : J && (ye(J) && d(J).length === 0 || A(J) && S(J).length === 0) ? (c(J, _), !0) : ((J == null ? void 0 : J.type) === \"MethodDefinition\" || (J == null ? void 0 : J.type) === \"TSAbstractMethodDefinition\") && d(J.value).length === 0 ? (c(J.value, _), !0) : !1;\n        }\n\n        function De(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode,\n              We = me.text;\n          if ((J == null ? void 0 : J.type) === \"FunctionTypeParam\" && (ne == null ? void 0 : ne.type) === \"FunctionTypeAnnotation\" && (Ee == null ? void 0 : Ee.type) !== \"FunctionTypeParam\" || ((J == null ? void 0 : J.type) === \"Identifier\" || (J == null ? void 0 : J.type) === \"AssignmentPattern\") && ne && ye(ne) && r(We, _, l) === \")\") return o(J, _), !0;\n\n          if ((ne == null ? void 0 : ne.type) === \"FunctionDeclaration\" && (Ee == null ? void 0 : Ee.type) === \"BlockStatement\") {\n            let Be = (() => {\n              let Pe = d(ne);\n              if (Pe.length > 0) return a(We, l(t(Pe)));\n              let Se = a(We, l(ne.id));\n              return Se !== !1 && a(We, Se + 1);\n            })();\n\n            if (F(_) > Be) return b(Ee, _), !0;\n          }\n\n          return !1;\n        }\n\n        function ie(me) {\n          let _ = me.comment,\n              J = me.enclosingNode;\n          return (J == null ? void 0 : J.type) === \"LabeledStatement\" ? (i(J, _), !0) : !1;\n        }\n\n        function G(me) {\n          let _ = me.comment,\n              J = me.enclosingNode;\n          return ((J == null ? void 0 : J.type) === \"ContinueStatement\" || (J == null ? void 0 : J.type) === \"BreakStatement\") && !J.label ? (o(J, _), !0) : !1;\n        }\n\n        function z(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode;\n          return B(ne) && J && ne.callee === J && ne.arguments.length > 0 ? (i(ne.arguments[0], _), !0) : !1;\n        }\n\n        function U(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode;\n          return (ne == null ? void 0 : ne.type) === \"UnionTypeAnnotation\" || (ne == null ? void 0 : ne.type) === \"TSUnionType\" ? (p(_) && (Ee.prettierIgnore = !0, _.unignore = !0), J ? (o(J, _), !0) : !1) : (((Ee == null ? void 0 : Ee.type) === \"UnionTypeAnnotation\" || (Ee == null ? void 0 : Ee.type) === \"TSUnionType\") && p(_) && (Ee.types[0].prettierIgnore = !0, _.unignore = !0), !1);\n        }\n\n        function le(me) {\n          let _ = me.comment,\n              J = me.enclosingNode;\n          return k(J) ? (i(J, _), !0) : !1;\n        }\n\n        function ge(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode,\n              Ee = me.ast,\n              We = me.isLastComment;\n          return Ee && Ee.body && Ee.body.length === 0 ? (We ? c(Ee, _) : i(Ee, _), !0) : (J == null ? void 0 : J.type) === \"Program\" && (J == null ? void 0 : J.body.length) === 0 && !m(J.directives) ? (We ? c(J, _) : i(J, _), !0) : (ne == null ? void 0 : ne.type) === \"Program\" && (ne == null ? void 0 : ne.body.length) === 0 && (J == null ? void 0 : J.type) === \"ModuleExpression\" ? (c(ne, _), !0) : !1;\n        }\n\n        function Ae(me) {\n          let _ = me.comment,\n              J = me.enclosingNode;\n          return (J == null ? void 0 : J.type) === \"ForInStatement\" || (J == null ? void 0 : J.type) === \"ForOfStatement\" ? (i(J, _), !0) : !1;\n        }\n\n        function Ne(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.text;\n          if ((ne == null ? void 0 : ne.type) === \"ImportSpecifier\" || (ne == null ? void 0 : ne.type) === \"ExportSpecifier\") return i(ne, _), !0;\n          let We = (J == null ? void 0 : J.type) === \"ImportSpecifier\" && (ne == null ? void 0 : ne.type) === \"ImportDeclaration\",\n              Be = (J == null ? void 0 : J.type) === \"ExportSpecifier\" && (ne == null ? void 0 : ne.type) === \"ExportNamedDeclaration\";\n          return (We || Be) && s(Ee, l(_)) ? (o(J, _), !0) : !1;\n        }\n\n        function ke(me) {\n          let _ = me.comment,\n              J = me.enclosingNode;\n          return (J == null ? void 0 : J.type) === \"AssignmentPattern\" ? (i(J, _), !0) : !1;\n        }\n\n        var ce = new Set([\"VariableDeclarator\", \"AssignmentExpression\", \"TypeAlias\", \"TSTypeAliasDeclaration\"]),\n            pe = new Set([\"ObjectExpression\", \"ArrayExpression\", \"TemplateLiteral\", \"TaggedTemplateExpression\", \"ObjectTypeAnnotation\", \"TSTypeLiteral\"]);\n\n        function de(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode;\n          return ce.has(J == null ? void 0 : J.type) && ne && (pe.has(ne.type) || E(_)) ? (i(ne, _), !0) : !1;\n        }\n\n        function ae(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode,\n              Ee = me.text;\n          return !ne && ((J == null ? void 0 : J.type) === \"TSMethodSignature\" || (J == null ? void 0 : J.type) === \"TSDeclareFunction\" || (J == null ? void 0 : J.type) === \"TSAbstractMethodDefinition\") && r(Ee, _, l) === \";\" ? (o(J, _), !0) : !1;\n        }\n\n        function ve(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode;\n          if (p(_) && (J == null ? void 0 : J.type) === \"TSMappedType\" && (ne == null ? void 0 : ne.type) === \"TSTypeParameter\" && ne.constraint) return J.prettierIgnore = !0, _.unignore = !0, !0;\n        }\n\n        function K(me) {\n          let _ = me.comment,\n              J = me.precedingNode,\n              ne = me.enclosingNode,\n              Ee = me.followingNode;\n          return (ne == null ? void 0 : ne.type) !== \"TSMappedType\" ? !1 : (Ee == null ? void 0 : Ee.type) === \"TSTypeParameter\" && Ee.name ? (i(Ee.name, _), !0) : (J == null ? void 0 : J.type) === \"TSTypeParameter\" && J.constraint ? (o(J.constraint, _), !0) : !1;\n        }\n\n        function he(me) {\n          let _ = me.comment,\n              J = me.enclosingNode,\n              ne = me.followingNode;\n          return !J || J.type !== \"SwitchCase\" || J.test ? !1 : (ne.type === \"BlockStatement\" && P(_) ? b(ne, _) : c(J, _), !0);\n        }\n\n        function ye(me) {\n          return me.type === \"ArrowFunctionExpression\" || me.type === \"FunctionExpression\" || me.type === \"FunctionDeclaration\" || me.type === \"ObjectMethod\" || me.type === \"ClassMethod\" || me.type === \"TSDeclareFunction\" || me.type === \"TSCallSignatureDeclaration\" || me.type === \"TSConstructSignatureDeclaration\" || me.type === \"TSMethodSignature\" || me.type === \"TSConstructorType\" || me.type === \"TSFunctionType\" || me.type === \"TSDeclareMethod\";\n        }\n\n        function Ce(me, _) {\n          if ((_.parser === \"typescript\" || _.parser === \"flow\" || _.parser === \"acorn\" || _.parser === \"espree\" || _.parser === \"meriyah\" || _.parser === \"__babel_estree\") && me.type === \"MethodDefinition\" && me.value && me.value.type === \"FunctionExpression\" && d(me.value).length === 0 && !me.value.returnType && !m(me.value.typeParameters) && me.value.body) return [...(me.decorators || []), me.key, me.value.body];\n        }\n\n        function Ie(me) {\n          return E(me) && me.value[0] === \"*\" && /@type\\b/.test(me.value);\n        }\n\n        function Fe(me) {\n          let _ = me.getValue(),\n              J = me.getParentNode(),\n              ne = Ee => w(C(Ee, D.Leading)) || w(C(Ee, D.Trailing));\n\n          return (_ && (f(_) || h(_) || B(J) && ne(_)) || J && (J.type === \"JSXSpreadAttribute\" || J.type === \"JSXSpreadChild\" || J.type === \"UnionTypeAnnotation\" || J.type === \"TSUnionType\" || (J.type === \"ClassDeclaration\" || J.type === \"ClassExpression\") && J.superClass === _)) && (!T(me) || J.type === \"UnionTypeAnnotation\" || J.type === \"TSUnionType\");\n        }\n\n        n.exports = {\n          handleOwnLineComment: y,\n          handleEndOfLineComment: N,\n          handleRemainingComment: x,\n          isTypeCastComment: Ie,\n          getCommentChildNodes: Ce,\n          willPrintOwnComments: Fe\n        };\n      }\n\n    }),\n        jt = Z({\n      \"src/language-js/needs-parens.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = it(),\n            s = Rn(),\n            _Ke4 = Ke(),\n            a = _Ke4.getFunctionParameters,\n            r = _Ke4.getLeftSidePathName,\n            u = _Ke4.hasFlowShorthandAnnotationComment,\n            i = _Ke4.hasNakedLeftSide,\n            o = _Ke4.hasNode,\n            c = _Ke4.isBitwiseOperator,\n            v = _Ke4.startsWithNoLookaheadToken,\n            m = _Ke4.shouldFlatten,\n            d = _Ke4.getPrecedence,\n            p = _Ke4.isCallExpression,\n            f = _Ke4.isMemberExpression,\n            h = _Ke4.isObjectProperty;\n\n        function w(P, C) {\n          let D = P.getParentNode();\n          if (!D) return !1;\n          let g = P.getName(),\n              F = P.getNode();\n          if (C.__isInHtmlInterpolation && !C.bracketSpacing && B(F) && I(P)) return !0;\n          if (T(F)) return !1;\n          if (C.parser !== \"flow\" && u(P.getValue())) return !0;\n          if (F.type === \"Identifier\") return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(F.name) || g === \"left\" && F.name === \"async\" && D.type === \"ForOfStatement\" && !D.await);\n\n          switch (D.type) {\n            case \"ParenthesizedExpression\":\n              return !1;\n\n            case \"ClassDeclaration\":\n            case \"ClassExpression\":\n              {\n                if (g === \"superClass\" && (F.type === \"ArrowFunctionExpression\" || F.type === \"AssignmentExpression\" || F.type === \"AwaitExpression\" || F.type === \"BinaryExpression\" || F.type === \"ConditionalExpression\" || F.type === \"LogicalExpression\" || F.type === \"NewExpression\" || F.type === \"ObjectExpression\" || F.type === \"SequenceExpression\" || F.type === \"TaggedTemplateExpression\" || F.type === \"UnaryExpression\" || F.type === \"UpdateExpression\" || F.type === \"YieldExpression\" || F.type === \"TSNonNullExpression\")) return !0;\n                break;\n              }\n\n            case \"ExportDefaultDeclaration\":\n              return k(P, C) || F.type === \"SequenceExpression\";\n\n            case \"Decorator\":\n              {\n                if (g === \"expression\") {\n                  let l = !1,\n                      E = !1,\n                      y = F;\n\n                  for (; y;) switch (y.type) {\n                    case \"MemberExpression\":\n                      E = !0, y = y.object;\n                      break;\n\n                    case \"CallExpression\":\n                      if (E || l) return C.parser !== \"typescript\";\n                      l = !0, y = y.callee;\n                      break;\n\n                    case \"Identifier\":\n                      return !1;\n\n                    case \"TaggedTemplateExpression\":\n                      return C.parser !== \"typescript\";\n\n                    default:\n                      return !0;\n                  }\n\n                  return !0;\n                }\n\n                break;\n              }\n\n            case \"ExpressionStatement\":\n              {\n                if (v(F, !0)) return !0;\n                break;\n              }\n\n            case \"ArrowFunctionExpression\":\n              {\n                if (g === \"body\" && F.type !== \"SequenceExpression\" && v(F, !1)) return !0;\n                break;\n              }\n          }\n\n          switch (F.type) {\n            case \"UpdateExpression\":\n              if (D.type === \"UnaryExpression\") return F.prefix && (F.operator === \"++\" && D.operator === \"+\" || F.operator === \"--\" && D.operator === \"-\");\n\n            case \"UnaryExpression\":\n              switch (D.type) {\n                case \"UnaryExpression\":\n                  return F.operator === D.operator && (F.operator === \"+\" || F.operator === \"-\");\n\n                case \"BindExpression\":\n                  return !0;\n\n                case \"MemberExpression\":\n                case \"OptionalMemberExpression\":\n                  return g === \"object\";\n\n                case \"TaggedTemplateExpression\":\n                  return !0;\n\n                case \"NewExpression\":\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"BinaryExpression\":\n                  return g === \"left\" && D.operator === \"**\";\n\n                case \"TSNonNullExpression\":\n                  return !0;\n\n                default:\n                  return !1;\n              }\n\n            case \"BinaryExpression\":\n              {\n                if (D.type === \"UpdateExpression\" || F.operator === \"in\" && A(P)) return !0;\n\n                if (F.operator === \"|>\" && F.extra && F.extra.parenthesized) {\n                  let l = P.getParentNode(1);\n                  if (l.type === \"BinaryExpression\" && l.operator === \"|>\") return !0;\n                }\n              }\n\n            case \"TSTypeAssertion\":\n            case \"TSAsExpression\":\n            case \"LogicalExpression\":\n              switch (D.type) {\n                case \"TSAsExpression\":\n                  return F.type !== \"TSAsExpression\";\n\n                case \"ConditionalExpression\":\n                  return F.type === \"TSAsExpression\";\n\n                case \"CallExpression\":\n                case \"NewExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"ClassExpression\":\n                case \"ClassDeclaration\":\n                  return g === \"superClass\";\n\n                case \"TSTypeAssertion\":\n                case \"TaggedTemplateExpression\":\n                case \"UnaryExpression\":\n                case \"JSXSpreadAttribute\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                case \"BindExpression\":\n                case \"AwaitExpression\":\n                case \"TSNonNullExpression\":\n                case \"UpdateExpression\":\n                  return !0;\n\n                case \"MemberExpression\":\n                case \"OptionalMemberExpression\":\n                  return g === \"object\";\n\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                  return g === \"left\" && (F.type === \"TSTypeAssertion\" || F.type === \"TSAsExpression\");\n\n                case \"LogicalExpression\":\n                  if (F.type === \"LogicalExpression\") return D.operator !== F.operator;\n\n                case \"BinaryExpression\":\n                  {\n                    let l = F.operator,\n                        E = F.type;\n                    if (!l && E !== \"TSTypeAssertion\") return !0;\n                    let y = d(l),\n                        N = D.operator,\n                        x = d(N);\n                    return x > y || g === \"right\" && x === y || x === y && !m(N, l) ? !0 : x < y && l === \"%\" ? N === \"+\" || N === \"-\" : !!c(N);\n                  }\n\n                default:\n                  return !1;\n              }\n\n            case \"SequenceExpression\":\n              switch (D.type) {\n                case \"ReturnStatement\":\n                  return !1;\n\n                case \"ForStatement\":\n                  return !1;\n\n                case \"ExpressionStatement\":\n                  return g !== \"expression\";\n\n                case \"ArrowFunctionExpression\":\n                  return g !== \"body\";\n\n                default:\n                  return !0;\n              }\n\n            case \"YieldExpression\":\n              if (D.type === \"UnaryExpression\" || D.type === \"AwaitExpression\" || D.type === \"TSAsExpression\" || D.type === \"TSNonNullExpression\") return !0;\n\n            case \"AwaitExpression\":\n              switch (D.type) {\n                case \"TaggedTemplateExpression\":\n                case \"UnaryExpression\":\n                case \"LogicalExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                case \"TSAsExpression\":\n                case \"TSNonNullExpression\":\n                case \"BindExpression\":\n                  return !0;\n\n                case \"MemberExpression\":\n                case \"OptionalMemberExpression\":\n                  return g === \"object\";\n\n                case \"NewExpression\":\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"ConditionalExpression\":\n                  return g === \"test\";\n\n                case \"BinaryExpression\":\n                  return !(!F.argument && D.operator === \"|>\");\n\n                default:\n                  return !1;\n              }\n\n            case \"TSConditionalType\":\n              if (g === \"extendsType\" && D.type === \"TSConditionalType\") return !0;\n\n            case \"TSFunctionType\":\n            case \"TSConstructorType\":\n              if (g === \"checkType\" && D.type === \"TSConditionalType\") return !0;\n\n            case \"TSUnionType\":\n            case \"TSIntersectionType\":\n              if ((D.type === \"TSUnionType\" || D.type === \"TSIntersectionType\") && D.types.length > 1 && (!F.types || F.types.length > 1)) return !0;\n\n            case \"TSInferType\":\n              if (F.type === \"TSInferType\" && D.type === \"TSRestType\") return !1;\n\n            case \"TSTypeOperator\":\n              return D.type === \"TSArrayType\" || D.type === \"TSOptionalType\" || D.type === \"TSRestType\" || g === \"objectType\" && D.type === \"TSIndexedAccessType\" || D.type === \"TSTypeOperator\" || D.type === \"TSTypeAnnotation\" && P.getParentNode(1).type.startsWith(\"TSJSDoc\");\n\n            case \"ArrayTypeAnnotation\":\n              return D.type === \"NullableTypeAnnotation\";\n\n            case \"IntersectionTypeAnnotation\":\n            case \"UnionTypeAnnotation\":\n              return D.type === \"ArrayTypeAnnotation\" || D.type === \"NullableTypeAnnotation\" || D.type === \"IntersectionTypeAnnotation\" || D.type === \"UnionTypeAnnotation\" || g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n\n            case \"NullableTypeAnnotation\":\n              return D.type === \"ArrayTypeAnnotation\" || g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n\n            case \"FunctionTypeAnnotation\":\n              {\n                let l = D.type === \"NullableTypeAnnotation\" ? P.getParentNode(1) : D;\n                return l.type === \"UnionTypeAnnotation\" || l.type === \"IntersectionTypeAnnotation\" || l.type === \"ArrayTypeAnnotation\" || g === \"objectType\" && (l.type === \"IndexedAccessType\" || l.type === \"OptionalIndexedAccessType\") || l.type === \"NullableTypeAnnotation\" || D.type === \"FunctionTypeParam\" && D.name === null && a(F).some(E => E.typeAnnotation && E.typeAnnotation.type === \"NullableTypeAnnotation\");\n              }\n\n            case \"OptionalIndexedAccessType\":\n              return g === \"objectType\" && D.type === \"IndexedAccessType\";\n\n            case \"TypeofTypeAnnotation\":\n              return g === \"objectType\" && (D.type === \"IndexedAccessType\" || D.type === \"OptionalIndexedAccessType\");\n\n            case \"StringLiteral\":\n            case \"NumericLiteral\":\n            case \"Literal\":\n              if (typeof F.value == \"string\" && D.type === \"ExpressionStatement\" && !D.directive) {\n                let l = P.getParentNode(1);\n                return l.type === \"Program\" || l.type === \"BlockStatement\";\n              }\n\n              return g === \"object\" && D.type === \"MemberExpression\" && typeof F.value == \"number\";\n\n            case \"AssignmentExpression\":\n              {\n                let l = P.getParentNode(1);\n                return g === \"body\" && D.type === \"ArrowFunctionExpression\" ? !0 : g === \"key\" && (D.type === \"ClassProperty\" || D.type === \"PropertyDefinition\") && D.computed || (g === \"init\" || g === \"update\") && D.type === \"ForStatement\" ? !1 : D.type === \"ExpressionStatement\" ? F.left.type === \"ObjectPattern\" : !(g === \"key\" && D.type === \"TSPropertySignature\" || D.type === \"AssignmentExpression\" || D.type === \"SequenceExpression\" && l && l.type === \"ForStatement\" && (l.init === D || l.update === D) || g === \"value\" && D.type === \"Property\" && l && l.type === \"ObjectPattern\" && l.properties.includes(D) || D.type === \"NGChainedExpression\");\n              }\n\n            case \"ConditionalExpression\":\n              switch (D.type) {\n                case \"TaggedTemplateExpression\":\n                case \"UnaryExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                case \"BinaryExpression\":\n                case \"LogicalExpression\":\n                case \"NGPipeExpression\":\n                case \"ExportDefaultDeclaration\":\n                case \"AwaitExpression\":\n                case \"JSXSpreadAttribute\":\n                case \"TSTypeAssertion\":\n                case \"TypeCastExpression\":\n                case \"TSAsExpression\":\n                case \"TSNonNullExpression\":\n                  return !0;\n\n                case \"NewExpression\":\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"ConditionalExpression\":\n                  return g === \"test\";\n\n                case \"MemberExpression\":\n                case \"OptionalMemberExpression\":\n                  return g === \"object\";\n\n                default:\n                  return !1;\n              }\n\n            case \"FunctionExpression\":\n              switch (D.type) {\n                case \"NewExpression\":\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"TaggedTemplateExpression\":\n                  return !0;\n\n                default:\n                  return !1;\n              }\n\n            case \"ArrowFunctionExpression\":\n              switch (D.type) {\n                case \"BinaryExpression\":\n                  return D.operator !== \"|>\" || F.extra && F.extra.parenthesized;\n\n                case \"NewExpression\":\n                case \"CallExpression\":\n                case \"OptionalCallExpression\":\n                  return g === \"callee\";\n\n                case \"MemberExpression\":\n                case \"OptionalMemberExpression\":\n                  return g === \"object\";\n\n                case \"TSAsExpression\":\n                case \"TSNonNullExpression\":\n                case \"BindExpression\":\n                case \"TaggedTemplateExpression\":\n                case \"UnaryExpression\":\n                case \"LogicalExpression\":\n                case \"AwaitExpression\":\n                case \"TSTypeAssertion\":\n                  return !0;\n\n                case \"ConditionalExpression\":\n                  return g === \"test\";\n\n                default:\n                  return !1;\n              }\n\n            case \"ClassExpression\":\n              if (s(F.decorators)) return !0;\n\n              switch (D.type) {\n                case \"NewExpression\":\n                  return g === \"callee\";\n\n                default:\n                  return !1;\n              }\n\n            case \"OptionalMemberExpression\":\n            case \"OptionalCallExpression\":\n              {\n                let l = P.getParentNode(1);\n                if (g === \"object\" && D.type === \"MemberExpression\" || g === \"callee\" && (D.type === \"CallExpression\" || D.type === \"NewExpression\") || D.type === \"TSNonNullExpression\" && l.type === \"MemberExpression\" && l.object === D) return !0;\n              }\n\n            case \"CallExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"TSNonNullExpression\":\n              if (g === \"callee\" && (D.type === \"BindExpression\" || D.type === \"NewExpression\")) {\n                let l = F;\n\n                for (; l;) switch (l.type) {\n                  case \"CallExpression\":\n                  case \"OptionalCallExpression\":\n                    return !0;\n\n                  case \"MemberExpression\":\n                  case \"OptionalMemberExpression\":\n                  case \"BindExpression\":\n                    l = l.object;\n                    break;\n\n                  case \"TaggedTemplateExpression\":\n                    l = l.tag;\n                    break;\n\n                  case \"TSNonNullExpression\":\n                    l = l.expression;\n                    break;\n\n                  default:\n                    return !1;\n                }\n              }\n\n              return !1;\n\n            case \"BindExpression\":\n              return g === \"callee\" && (D.type === \"BindExpression\" || D.type === \"NewExpression\") || g === \"object\" && f(D);\n\n            case \"NGPipeExpression\":\n              return !(D.type === \"NGRoot\" || D.type === \"NGMicrosyntaxExpression\" || D.type === \"ObjectProperty\" && !(F.extra && F.extra.parenthesized) || D.type === \"ArrayExpression\" || p(D) && D.arguments[g] === F || g === \"right\" && D.type === \"NGPipeExpression\" || g === \"property\" && D.type === \"MemberExpression\" || D.type === \"AssignmentExpression\");\n\n            case \"JSXFragment\":\n            case \"JSXElement\":\n              return g === \"callee\" || g === \"left\" && D.type === \"BinaryExpression\" && D.operator === \"<\" || D.type !== \"ArrayExpression\" && D.type !== \"ArrowFunctionExpression\" && D.type !== \"AssignmentExpression\" && D.type !== \"AssignmentPattern\" && D.type !== \"BinaryExpression\" && D.type !== \"NewExpression\" && D.type !== \"ConditionalExpression\" && D.type !== \"ExpressionStatement\" && D.type !== \"JsExpressionRoot\" && D.type !== \"JSXAttribute\" && D.type !== \"JSXElement\" && D.type !== \"JSXExpressionContainer\" && D.type !== \"JSXFragment\" && D.type !== \"LogicalExpression\" && !p(D) && !h(D) && D.type !== \"ReturnStatement\" && D.type !== \"ThrowStatement\" && D.type !== \"TypeCastExpression\" && D.type !== \"VariableDeclarator\" && D.type !== \"YieldExpression\";\n\n            case \"TypeAnnotation\":\n              return g === \"returnType\" && D.type === \"ArrowFunctionExpression\" && S(F);\n          }\n\n          return !1;\n        }\n\n        function T(P) {\n          return P.type === \"BlockStatement\" || P.type === \"BreakStatement\" || P.type === \"ClassBody\" || P.type === \"ClassDeclaration\" || P.type === \"ClassMethod\" || P.type === \"ClassProperty\" || P.type === \"PropertyDefinition\" || P.type === \"ClassPrivateProperty\" || P.type === \"ContinueStatement\" || P.type === \"DebuggerStatement\" || P.type === \"DeclareClass\" || P.type === \"DeclareExportAllDeclaration\" || P.type === \"DeclareExportDeclaration\" || P.type === \"DeclareFunction\" || P.type === \"DeclareInterface\" || P.type === \"DeclareModule\" || P.type === \"DeclareModuleExports\" || P.type === \"DeclareVariable\" || P.type === \"DoWhileStatement\" || P.type === \"EnumDeclaration\" || P.type === \"ExportAllDeclaration\" || P.type === \"ExportDefaultDeclaration\" || P.type === \"ExportNamedDeclaration\" || P.type === \"ExpressionStatement\" || P.type === \"ForInStatement\" || P.type === \"ForOfStatement\" || P.type === \"ForStatement\" || P.type === \"FunctionDeclaration\" || P.type === \"IfStatement\" || P.type === \"ImportDeclaration\" || P.type === \"InterfaceDeclaration\" || P.type === \"LabeledStatement\" || P.type === \"MethodDefinition\" || P.type === \"ReturnStatement\" || P.type === \"SwitchStatement\" || P.type === \"ThrowStatement\" || P.type === \"TryStatement\" || P.type === \"TSDeclareFunction\" || P.type === \"TSEnumDeclaration\" || P.type === \"TSImportEqualsDeclaration\" || P.type === \"TSInterfaceDeclaration\" || P.type === \"TSModuleDeclaration\" || P.type === \"TSNamespaceExportDeclaration\" || P.type === \"TypeAlias\" || P.type === \"VariableDeclaration\" || P.type === \"WhileStatement\" || P.type === \"WithStatement\";\n        }\n\n        function A(P) {\n          let C = 0,\n              D = P.getValue();\n\n          for (; D;) {\n            let g = P.getParentNode(C++);\n            if (g && g.type === \"ForStatement\" && g.init === D) return !0;\n            D = g;\n          }\n\n          return !1;\n        }\n\n        function S(P) {\n          return o(P, C => C.type === \"ObjectTypeAnnotation\" && o(C, D => D.type === \"FunctionTypeAnnotation\" || void 0) || void 0);\n        }\n\n        function B(P) {\n          switch (P.type) {\n            case \"ObjectExpression\":\n              return !0;\n\n            default:\n              return !1;\n          }\n        }\n\n        function I(P) {\n          let C = P.getValue(),\n              D = P.getParentNode(),\n              g = P.getName();\n\n          switch (D.type) {\n            case \"NGPipeExpression\":\n              if (typeof g == \"number\" && D.arguments[g] === C && D.arguments.length - 1 === g) return P.callParent(I);\n              break;\n\n            case \"ObjectProperty\":\n              if (g === \"value\") {\n                let F = P.getParentNode(1);\n                return t(F.properties) === D;\n              }\n\n              break;\n\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n              if (g === \"right\") return P.callParent(I);\n              break;\n\n            case \"ConditionalExpression\":\n              if (g === \"alternate\") return P.callParent(I);\n              break;\n\n            case \"UnaryExpression\":\n              if (D.prefix) return P.callParent(I);\n              break;\n          }\n\n          return !1;\n        }\n\n        function k(P, C) {\n          let D = P.getValue(),\n              g = P.getParentNode();\n          return D.type === \"FunctionExpression\" || D.type === \"ClassExpression\" ? g.type === \"ExportDefaultDeclaration\" || !w(P, C) : !i(D) || g.type !== \"ExportDefaultDeclaration\" && w(P, C) ? !1 : P.call(F => k(F, C), ...r(P, D));\n        }\n\n        n.exports = w;\n      }\n\n    }),\n        so = Z({\n      \"src/language-js/print-preprocess.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a) {\n          switch (a.parser) {\n            case \"json\":\n            case \"json5\":\n            case \"json-stringify\":\n            case \"__js_expression\":\n            case \"__vue_expression\":\n            case \"__vue_ts_expression\":\n              return Object.assign(Object.assign({}, s), {}, {\n                type: a.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",\n                node: s,\n                comments: [],\n                rootMarker: a.rootMarker\n              });\n\n            default:\n              return s;\n          }\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        $m = Z({\n      \"src/language-js/print/html-binding.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe10 = Oe(),\n            _Oe10$builders = _Oe10.builders,\n            t = _Oe10$builders.join,\n            s = _Oe10$builders.line,\n            a = _Oe10$builders.group,\n            r = _Oe10$builders.softline,\n            u = _Oe10$builders.indent;\n\n        function i(c, v, m) {\n          let d = c.getValue();\n\n          if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d, v), d.type === \"File\") {\n            if (v.__isVueForBindingLeft) return c.call(p => {\n              let f = t([\",\", s], p.map(m, \"params\")),\n                  _p$getValue = p.getValue(),\n                  h = _p$getValue.params;\n\n              return h.length === 1 ? f : [\"(\", u([r, a(f)]), r, \")\"];\n            }, \"program\", \"body\", 0);\n            if (v.__isVueBindings) return c.call(p => t([\",\", s], p.map(m, \"params\")), \"program\", \"body\", 0);\n          }\n        }\n\n        function o(c) {\n          switch (c.type) {\n            case \"MemberExpression\":\n              switch (c.property.type) {\n                case \"Identifier\":\n                case \"NumericLiteral\":\n                case \"StringLiteral\":\n                  return o(c.object);\n              }\n\n              return !1;\n\n            case \"Identifier\":\n              return !0;\n\n            default:\n              return !1;\n          }\n        }\n\n        n.exports = {\n          isVueEventBindingExpression: o,\n          printHtmlBinding: i\n        };\n      }\n\n    }),\n        Jn = Z({\n      \"src/language-js/print/binaryish.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et2 = et(),\n            t = _et2.printComments,\n            _Ue8 = Ue(),\n            s = _Ue8.getLast,\n            _Oe11 = Oe(),\n            _Oe11$builders = _Oe11.builders,\n            a = _Oe11$builders.join,\n            r = _Oe11$builders.line,\n            u = _Oe11$builders.softline,\n            i = _Oe11$builders.group,\n            o = _Oe11$builders.indent,\n            c = _Oe11$builders.align,\n            v = _Oe11$builders.ifBreak,\n            m = _Oe11$builders.indentIfBreak,\n            _Oe11$utils = _Oe11.utils,\n            d = _Oe11$utils.cleanDoc,\n            p = _Oe11$utils.getDocParts,\n            f = _Oe11$utils.isConcat,\n            _Ke5 = Ke(),\n            h = _Ke5.hasLeadingOwnLineComment,\n            w = _Ke5.isBinaryish,\n            T = _Ke5.isJsxNode,\n            A = _Ke5.shouldFlatten,\n            S = _Ke5.hasComment,\n            B = _Ke5.CommentCheckFlags,\n            I = _Ke5.isCallExpression,\n            k = _Ke5.isMemberExpression,\n            P = _Ke5.isObjectProperty,\n            C = _Ke5.isEnabledHackPipeline,\n            D = 0;\n\n        function g(E, y, N) {\n          let x = E.getValue(),\n              b = E.getParentNode(),\n              L = E.getParentNode(1),\n              M = x !== b.body && (b.type === \"IfStatement\" || b.type === \"WhileStatement\" || b.type === \"SwitchStatement\" || b.type === \"DoWhileStatement\"),\n              j = C(y) && x.operator === \"|>\",\n              $ = F(E, N, y, !1, M);\n          if (M) return $;\n          if (j) return i($);\n          if (I(b) && b.callee === x || b.type === \"UnaryExpression\" || k(b) && !b.computed) return i([o([u, ...$]), u]);\n          let V = b.type === \"ReturnStatement\" || b.type === \"ThrowStatement\" || b.type === \"JSXExpressionContainer\" && L.type === \"JSXAttribute\" || x.operator !== \"|\" && b.type === \"JsExpressionRoot\" || x.type !== \"NGPipeExpression\" && (b.type === \"NGRoot\" && y.parser === \"__ng_binding\" || b.type === \"NGMicrosyntaxExpression\" && L.type === \"NGMicrosyntax\" && L.body.length === 1) || x === b.body && b.type === \"ArrowFunctionExpression\" || x !== b.body && b.type === \"ForStatement\" || b.type === \"ConditionalExpression\" && L.type !== \"ReturnStatement\" && L.type !== \"ThrowStatement\" && !I(L) || b.type === \"TemplateLiteral\",\n              q = b.type === \"AssignmentExpression\" || b.type === \"VariableDeclarator\" || b.type === \"ClassProperty\" || b.type === \"PropertyDefinition\" || b.type === \"TSAbstractPropertyDefinition\" || b.type === \"ClassPrivateProperty\" || P(b),\n              Y = w(x.left) && A(x.operator, x.left.operator);\n          if (V || l(x) && !Y || !l(x) && q) return i($);\n          if ($.length === 0) return \"\";\n          let H = T(x.right),\n              R = $.findIndex(X => typeof X != \"string\" && !Array.isArray(X) && X.type === \"group\"),\n              Q = $.slice(0, R === -1 ? 1 : R + 1),\n              ee = $.slice(Q.length, H ? -1 : void 0),\n              te = Symbol(\"logicalChain-\" + ++D),\n              oe = i([...Q, o(ee)], {\n            id: te\n          });\n          if (!H) return oe;\n          let W = s($);\n          return i([oe, m(W, {\n            groupId: te\n          })]);\n        }\n\n        function F(E, y, N, x, b) {\n          let L = E.getValue();\n          if (!w(L)) return [i(y())];\n          let M = [];\n          A(L.operator, L.left.operator) ? M = E.call(ee => F(ee, y, N, !0, b), \"left\") : M.push(i(y(\"left\")));\n          let j = l(L),\n              $ = (L.operator === \"|>\" || L.type === \"NGPipeExpression\" || L.operator === \"|\" && N.parser === \"__vue_expression\") && !h(N.originalText, L.right),\n              V = L.type === \"NGPipeExpression\" ? \"|\" : L.operator,\n              q = L.type === \"NGPipeExpression\" && L.arguments.length > 0 ? i(o([u, \": \", a([u, \":\", v(\" \")], E.map(y, \"arguments\").map(ee => c(2, i(ee))))])) : \"\",\n              Y;\n          if (j) Y = [V, \" \", y(\"right\"), q];else {\n            let te = C(N) && V === \"|>\" ? E.call(oe => F(oe, y, N, !0, b), \"right\") : y(\"right\");\n            Y = [$ ? r : \"\", V, $ ? \" \" : r, te, q];\n          }\n          let H = E.getParentNode(),\n              R = S(L.left, B.Trailing | B.Line),\n              Q = R || !(b && L.type === \"LogicalExpression\") && H.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;\n\n          if (M.push($ ? \"\" : \" \", Q ? i(Y, {\n            shouldBreak: R\n          }) : Y), x && S(L)) {\n            let ee = d(t(E, M, N));\n            return f(ee) || ee.type === \"fill\" ? p(ee) : [ee];\n          }\n\n          return M;\n        }\n\n        function l(E) {\n          return E.type !== \"LogicalExpression\" ? !1 : !!(E.right.type === \"ObjectExpression\" && E.right.properties.length > 0 || E.right.type === \"ArrayExpression\" && E.right.elements.length > 0 || T(E.right));\n        }\n\n        n.exports = {\n          printBinaryishExpression: g,\n          shouldInlineLogicalExpression: l\n        };\n      }\n\n    }),\n        Hm = Z({\n      \"src/language-js/print/angular.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe12 = Oe(),\n            _Oe12$builders = _Oe12.builders,\n            t = _Oe12$builders.join,\n            s = _Oe12$builders.line,\n            a = _Oe12$builders.group,\n            _Ke6 = Ke(),\n            r = _Ke6.hasNode,\n            u = _Ke6.hasComment,\n            i = _Ke6.getComments,\n            _Jn = Jn(),\n            o = _Jn.printBinaryishExpression;\n\n        function c(d, p, f) {\n          let h = d.getValue();\n          if (!!h.type.startsWith(\"NG\")) switch (h.type) {\n            case \"NGRoot\":\n              return [f(\"node\"), u(h.node) ? \" //\" + i(h.node)[0].value.trimEnd() : \"\"];\n\n            case \"NGPipeExpression\":\n              return o(d, p, f);\n\n            case \"NGChainedExpression\":\n              return a(t([\";\", s], d.map(w => m(w) ? f() : [\"(\", f(), \")\"], \"expressions\")));\n\n            case \"NGEmptyExpression\":\n              return \"\";\n\n            case \"NGQuotedExpression\":\n              return [h.prefix, \": \", h.value.trim()];\n\n            case \"NGMicrosyntax\":\n              return d.map((w, T) => [T === 0 ? \"\" : v(w.getValue(), T, h) ? \" \" : [\";\", s], f()], \"body\");\n\n            case \"NGMicrosyntaxKey\":\n              return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(h.name) ? h.name : JSON.stringify(h.name);\n\n            case \"NGMicrosyntaxExpression\":\n              return [f(\"expression\"), h.alias === null ? \"\" : [\" as \", f(\"alias\")]];\n\n            case \"NGMicrosyntaxKeyedExpression\":\n              {\n                let w = d.getName(),\n                    T = d.getParentNode(),\n                    A = v(h, w, T) || (w === 1 && (h.key.name === \"then\" || h.key.name === \"else\") || w === 2 && h.key.name === \"else\" && T.body[w - 1].type === \"NGMicrosyntaxKeyedExpression\" && T.body[w - 1].key.name === \"then\") && T.body[0].type === \"NGMicrosyntaxExpression\";\n                return [f(\"key\"), A ? \" \" : \": \", f(\"expression\")];\n              }\n\n            case \"NGMicrosyntaxLet\":\n              return [\"let \", f(\"key\"), h.value === null ? \"\" : [\" = \", f(\"value\")]];\n\n            case \"NGMicrosyntaxAs\":\n              return [f(\"key\"), \" as \", f(\"alias\")];\n\n            default:\n              throw new Error(\"Unknown Angular node type: \".concat(JSON.stringify(h.type), \".\"));\n          }\n        }\n\n        function v(d, p, f) {\n          return d.type === \"NGMicrosyntaxKeyedExpression\" && d.key.name === \"of\" && p === 1 && f.body[0].type === \"NGMicrosyntaxLet\" && f.body[0].value === null;\n        }\n\n        function m(d) {\n          return r(d.getValue(), p => {\n            switch (p.type) {\n              case void 0:\n                return !1;\n\n              case \"CallExpression\":\n              case \"OptionalCallExpression\":\n              case \"AssignmentExpression\":\n                return !0;\n            }\n          });\n        }\n\n        n.exports = {\n          printAngular: c\n        };\n      }\n\n    }),\n        Gm = Z({\n      \"src/language-js/print/jsx.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et3 = et(),\n            t = _et3.printComments,\n            s = _et3.printDanglingComments,\n            _Oe13 = Oe(),\n            _Oe13$builders = _Oe13.builders,\n            a = _Oe13$builders.line,\n            r = _Oe13$builders.hardline,\n            u = _Oe13$builders.softline,\n            i = _Oe13$builders.group,\n            o = _Oe13$builders.indent,\n            c = _Oe13$builders.conditionalGroup,\n            v = _Oe13$builders.fill,\n            m = _Oe13$builders.ifBreak,\n            d = _Oe13$builders.lineSuffixBoundary,\n            p = _Oe13$builders.join,\n            f = _Oe13.utils.willBreak,\n            _Ue9 = Ue(),\n            h = _Ue9.getLast,\n            w = _Ue9.getPreferredQuote,\n            _Ke7 = Ke(),\n            T = _Ke7.isJsxNode,\n            A = _Ke7.rawText,\n            S = _Ke7.isLiteral,\n            B = _Ke7.isCallExpression,\n            I = _Ke7.isStringLiteral,\n            k = _Ke7.isBinaryish,\n            P = _Ke7.hasComment,\n            C = _Ke7.CommentCheckFlags,\n            D = _Ke7.hasNodeIgnoreComment,\n            g = jt(),\n            _uo = uo(),\n            F = _uo.willPrintOwnComments,\n            l = ie => ie === \"\" || ie === a || ie === r || ie === u;\n\n        function E(ie, G, z) {\n          let U = ie.getValue();\n          if (U.type === \"JSXElement\" && W(U)) return [z(\"openingElement\"), z(\"closingElement\")];\n          let le = U.type === \"JSXElement\" ? z(\"openingElement\") : z(\"openingFragment\"),\n              ge = U.type === \"JSXElement\" ? z(\"closingElement\") : z(\"closingFragment\");\n          if (U.children.length === 1 && U.children[0].type === \"JSXExpressionContainer\" && (U.children[0].expression.type === \"TemplateLiteral\" || U.children[0].expression.type === \"TaggedTemplateExpression\")) return [le, ...ie.map(z, \"children\"), ge];\n          U.children = U.children.map(Fe => ue(Fe) ? {\n            type: \"JSXText\",\n            value: \" \",\n            raw: \" \"\n          } : Fe);\n          let Ae = U.children.some(T),\n              Ne = U.children.filter(Fe => Fe.type === \"JSXExpressionContainer\").length > 1,\n              ke = U.type === \"JSXElement\" && U.openingElement.attributes.length > 1,\n              ce = f(le) || Ae || ke || Ne,\n              pe = ie.getParentNode().rootMarker === \"mdx\",\n              de = G.singleQuote ? \"{' '}\" : '{\" \"}',\n              ae = pe ? \" \" : m([de, u], \" \"),\n              ve = U.openingElement && U.openingElement.name && U.openingElement.name.name === \"fbt\",\n              K = y(ie, G, z, ae, ve),\n              he = U.children.some(Fe => X(Fe));\n\n          for (let Fe = K.length - 2; Fe >= 0; Fe--) {\n            let me = K[Fe] === \"\" && K[Fe + 1] === \"\",\n                _ = K[Fe] === r && K[Fe + 1] === \"\" && K[Fe + 2] === r,\n                J = (K[Fe] === u || K[Fe] === r) && K[Fe + 1] === \"\" && K[Fe + 2] === ae,\n                ne = K[Fe] === ae && K[Fe + 1] === \"\" && (K[Fe + 2] === u || K[Fe + 2] === r),\n                Ee = K[Fe] === ae && K[Fe + 1] === \"\" && K[Fe + 2] === ae,\n                We = K[Fe] === u && K[Fe + 1] === \"\" && K[Fe + 2] === r || K[Fe] === r && K[Fe + 1] === \"\" && K[Fe + 2] === u;\n\n            _ && he || me || J || Ee || We ? K.splice(Fe, 2) : ne && K.splice(Fe + 1, 2);\n          }\n\n          for (; K.length > 0 && l(h(K));) K.pop();\n\n          for (; K.length > 1 && l(K[0]) && l(K[1]);) K.shift(), K.shift();\n\n          let ye = [];\n\n          for (let _ref29 of K.entries()) {\n            var _ref30 = _slicedToArray(_ref29, 2);\n\n            let Fe = _ref30[0];\n            let me = _ref30[1];\n\n            if (me === ae) {\n              if (Fe === 1 && K[Fe - 1] === \"\") {\n                if (K.length === 2) {\n                  ye.push(de);\n                  continue;\n                }\n\n                ye.push([de, r]);\n                continue;\n              } else if (Fe === K.length - 1) {\n                ye.push(de);\n                continue;\n              } else if (K[Fe - 1] === \"\" && K[Fe - 2] === r) {\n                ye.push(de);\n                continue;\n              }\n            }\n\n            ye.push(me), f(me) && (ce = !0);\n          }\n\n          let Ce = he ? v(ye) : i(ye, {\n            shouldBreak: !0\n          });\n          if (pe) return Ce;\n          let Ie = i([le, o([r, Ce]), r, ge]);\n          return ce ? Ie : c([i([le, ...K, ge]), Ie]);\n        }\n\n        function y(ie, G, z, U, le) {\n          let ge = [];\n          return ie.each((Ae, Ne, ke) => {\n            let ce = Ae.getValue();\n\n            if (S(ce)) {\n              let pe = A(ce);\n\n              if (X(ce)) {\n                let de = pe.split(ee);\n\n                if (de[0] === \"\") {\n                  if (ge.push(\"\"), de.shift(), /\\n/.test(de[0])) {\n                    let ve = ke[Ne + 1];\n                    ge.push(x(le, de[1], ce, ve));\n                  } else ge.push(U);\n\n                  de.shift();\n                }\n\n                let ae;\n                if (h(de) === \"\" && (de.pop(), ae = de.pop()), de.length === 0) return;\n\n                for (let _ref31 of de.entries()) {\n                  var _ref32 = _slicedToArray(_ref31, 2);\n\n                  let ve = _ref32[0];\n                  let K = _ref32[1];\n                  ve % 2 === 1 ? ge.push(a) : ge.push(K);\n                }\n\n                if (ae !== void 0) {\n                  if (/\\n/.test(ae)) {\n                    let ve = ke[Ne + 1];\n                    ge.push(x(le, h(ge), ce, ve));\n                  } else ge.push(U);\n                } else {\n                  let ve = ke[Ne + 1];\n                  ge.push(N(le, h(ge), ce, ve));\n                }\n              } else /\\n/.test(pe) ? pe.match(/\\n/g).length > 1 && ge.push(\"\", r) : ge.push(\"\", U);\n            } else {\n              let pe = z();\n              ge.push(pe);\n              let de = ke[Ne + 1];\n\n              if (de && X(de)) {\n                let ve = oe(A(de)).split(ee)[0];\n                ge.push(N(le, ve, ce, de));\n              } else ge.push(r);\n            }\n          }, \"children\"), ge;\n        }\n\n        function N(ie, G, z, U) {\n          return ie ? \"\" : z.type === \"JSXElement\" && !z.closingElement || U && U.type === \"JSXElement\" && !U.closingElement ? G.length === 1 ? u : r : u;\n        }\n\n        function x(ie, G, z, U) {\n          return ie ? r : G.length === 1 ? z.type === \"JSXElement\" && !z.closingElement || U && U.type === \"JSXElement\" && !U.closingElement ? r : u : r;\n        }\n\n        function b(ie, G, z) {\n          let U = ie.getParentNode();\n          if (!U || {\n            ArrayExpression: !0,\n            JSXAttribute: !0,\n            JSXElement: !0,\n            JSXExpressionContainer: !0,\n            JSXFragment: !0,\n            ExpressionStatement: !0,\n            CallExpression: !0,\n            OptionalCallExpression: !0,\n            ConditionalExpression: !0,\n            JsExpressionRoot: !0\n          }[U.type]) return G;\n          let ge = ie.match(void 0, Ne => Ne.type === \"ArrowFunctionExpression\", B, Ne => Ne.type === \"JSXExpressionContainer\"),\n              Ae = g(ie, z);\n          return i([Ae ? \"\" : m(\"(\"), o([u, G]), u, Ae ? \"\" : m(\")\")], {\n            shouldBreak: ge\n          });\n        }\n\n        function L(ie, G, z) {\n          let U = ie.getValue(),\n              le = [];\n\n          if (le.push(z(\"name\")), U.value) {\n            let ge;\n\n            if (I(U.value)) {\n              let Ne = A(U.value).slice(1, -1).replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"'),\n                  _w = w(Ne, G.jsxSingleQuote ? \"'\" : '\"'),\n                  ke = _w.escaped,\n                  ce = _w.quote,\n                  pe = _w.regex;\n\n              Ne = Ne.replace(pe, ke), ge = [ce, Ne, ce];\n            } else ge = z(\"value\");\n\n            le.push(\"=\", ge);\n          }\n\n          return le;\n        }\n\n        function M(ie, G, z) {\n          let U = ie.getValue(),\n              le = (ge, Ae) => ge.type === \"JSXEmptyExpression\" || !P(ge) && (ge.type === \"ArrayExpression\" || ge.type === \"ObjectExpression\" || ge.type === \"ArrowFunctionExpression\" || ge.type === \"AwaitExpression\" && (le(ge.argument, ge) || ge.argument.type === \"JSXElement\") || B(ge) || ge.type === \"FunctionExpression\" || ge.type === \"TemplateLiteral\" || ge.type === \"TaggedTemplateExpression\" || ge.type === \"DoExpression\" || T(Ae) && (ge.type === \"ConditionalExpression\" || k(ge)));\n\n          return le(U.expression, ie.getParentNode(0)) ? i([\"{\", z(\"expression\"), d, \"}\"]) : i([\"{\", o([u, z(\"expression\")]), u, d, \"}\"]);\n        }\n\n        function j(ie, G, z) {\n          let U = ie.getValue(),\n              le = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);\n          if (U.selfClosing && U.attributes.length === 0 && !le) return [\"<\", z(\"name\"), z(\"typeParameters\"), \" />\"];\n          if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I(U.attributes[0].value) && !U.attributes[0].value.value.includes(\"\\n\") && !le && !P(U.attributes[0])) return i([\"<\", z(\"name\"), z(\"typeParameters\"), \" \", ...ie.map(z, \"attributes\"), U.selfClosing ? \" />\" : \">\"]);\n          let ge = U.attributes.length > 0 && P(h(U.attributes), C.Trailing),\n              Ae = U.attributes.length === 0 && !le || (G.bracketSameLine || G.jsxBracketSameLine) && (!le || U.attributes.length > 0) && !ge,\n              Ne = U.attributes && U.attributes.some(ce => ce.value && I(ce.value) && ce.value.value.includes(\"\\n\")),\n              ke = G.singleAttributePerLine && U.attributes.length > 1 ? r : a;\n          return i([\"<\", z(\"name\"), z(\"typeParameters\"), o(ie.map(() => [ke, z()], \"attributes\")), U.selfClosing ? a : Ae ? \">\" : u, U.selfClosing ? \"/>\" : Ae ? \"\" : \">\"], {\n            shouldBreak: Ne\n          });\n        }\n\n        function $(ie, G, z) {\n          let U = ie.getValue(),\n              le = [];\n          le.push(\"</\");\n          let ge = z(\"name\");\n          return P(U.name, C.Leading | C.Line) ? le.push(o([r, ge]), r) : P(U.name, C.Leading | C.Block) ? le.push(\" \", ge) : le.push(ge), le.push(\">\"), le;\n        }\n\n        function V(ie, G) {\n          let z = ie.getValue(),\n              U = P(z),\n              le = P(z, C.Line),\n              ge = z.type === \"JSXOpeningFragment\";\n          return [ge ? \"<\" : \"</\", o([le ? r : U && !ge ? \" \" : \"\", s(ie, G, !0)]), le ? r : \"\", \">\"];\n        }\n\n        function q(ie, G, z) {\n          let U = t(ie, E(ie, G, z), G);\n          return b(ie, U, G);\n        }\n\n        function Y(ie, G) {\n          let z = ie.getValue(),\n              U = P(z, C.Line);\n          return [s(ie, G, !U), U ? r : \"\"];\n        }\n\n        function H(ie, G, z) {\n          let U = ie.getValue();\n          return [\"{\", ie.call(le => {\n            let ge = [\"...\", z()],\n                Ae = le.getValue();\n            return !P(Ae) || !F(le) ? ge : [o([u, t(le, ge, G)]), u];\n          }, U.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"];\n        }\n\n        function R(ie, G, z) {\n          let U = ie.getValue();\n          if (!!U.type.startsWith(\"JSX\")) switch (U.type) {\n            case \"JSXAttribute\":\n              return L(ie, G, z);\n\n            case \"JSXIdentifier\":\n              return String(U.name);\n\n            case \"JSXNamespacedName\":\n              return p(\":\", [z(\"namespace\"), z(\"name\")]);\n\n            case \"JSXMemberExpression\":\n              return p(\".\", [z(\"object\"), z(\"property\")]);\n\n            case \"JSXSpreadAttribute\":\n              return H(ie, G, z);\n\n            case \"JSXSpreadChild\":\n              return H(ie, G, z);\n\n            case \"JSXExpressionContainer\":\n              return M(ie, G, z);\n\n            case \"JSXFragment\":\n            case \"JSXElement\":\n              return q(ie, G, z);\n\n            case \"JSXOpeningElement\":\n              return j(ie, G, z);\n\n            case \"JSXClosingElement\":\n              return $(ie, G, z);\n\n            case \"JSXOpeningFragment\":\n            case \"JSXClosingFragment\":\n              return V(ie, G);\n\n            case \"JSXEmptyExpression\":\n              return Y(ie, G);\n\n            case \"JSXText\":\n              throw new Error(\"JSXTest should be handled by JSXElement\");\n\n            default:\n              throw new Error(\"Unknown JSX node type: \".concat(JSON.stringify(U.type), \".\"));\n          }\n        }\n\n        var Q = \" \\n\\r\\t\",\n            ee = new RegExp(\"([\" + Q + \"]+)\"),\n            te = new RegExp(\"[^\" + Q + \"]\"),\n            oe = ie => ie.replace(new RegExp(\"(?:^\" + ee.source + \"|\" + ee.source + \"$)\"), \"\");\n\n        function W(ie) {\n          if (ie.children.length === 0) return !0;\n          if (ie.children.length > 1) return !1;\n          let G = ie.children[0];\n          return S(G) && !X(G);\n        }\n\n        function X(ie) {\n          return S(ie) && (te.test(A(ie)) || !/\\n/.test(A(ie)));\n        }\n\n        function ue(ie) {\n          return ie.type === \"JSXExpressionContainer\" && S(ie.expression) && ie.expression.value === \" \" && !P(ie.expression);\n        }\n\n        function De(ie) {\n          let G = ie.getValue(),\n              z = ie.getParentNode();\n          if (!z || !G || !T(G) || !T(z)) return !1;\n          let U = z.children.indexOf(G),\n              le = null;\n\n          for (let ge = U; ge > 0; ge--) {\n            let Ae = z.children[ge - 1];\n\n            if (!(Ae.type === \"JSXText\" && !X(Ae))) {\n              le = Ae;\n              break;\n            }\n          }\n\n          return le && le.type === \"JSXExpressionContainer\" && le.expression.type === \"JSXEmptyExpression\" && D(le.expression);\n        }\n\n        n.exports = {\n          hasJsxIgnoreComment: De,\n          printJsx: R\n        };\n      }\n\n    }),\n        ct = Z({\n      \"src/language-js/print/misc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue10 = Ue(),\n            t = _Ue10.isNonEmptyArray,\n            _Oe14 = Oe(),\n            _Oe14$builders = _Oe14.builders,\n            s = _Oe14$builders.indent,\n            a = _Oe14$builders.join,\n            r = _Oe14$builders.line,\n            _Ke8 = Ke(),\n            u = _Ke8.isFlowAnnotationComment;\n\n        function i(h) {\n          let w = h.getValue();\n          return !w.optional || w.type === \"Identifier\" && w === h.getParentNode().key ? \"\" : w.type === \"OptionalCallExpression\" || w.type === \"OptionalMemberExpression\" && w.computed ? \"?.\" : \"?\";\n        }\n\n        function o(h) {\n          return h.getValue().definite || h.match(void 0, (w, T) => T === \"id\" && w.type === \"VariableDeclarator\" && w.definite) ? \"!\" : \"\";\n        }\n\n        function c(h, w, T) {\n          let A = h.getValue();\n          return A.typeArguments ? T(\"typeArguments\") : A.typeParameters ? T(\"typeParameters\") : \"\";\n        }\n\n        function v(h, w, T) {\n          let A = h.getValue();\n          if (!A.typeAnnotation) return \"\";\n          let S = h.getParentNode(),\n              B = S.type === \"DeclareFunction\" && S.id === A;\n          return u(w.originalText, A.typeAnnotation) ? [\" /*: \", T(\"typeAnnotation\"), \" */\"] : [B ? \"\" : \": \", T(\"typeAnnotation\")];\n        }\n\n        function m(h, w, T) {\n          return [\"::\", T(\"callee\")];\n        }\n\n        function d(h, w, T) {\n          let A = h.getValue();\n          return t(A.modifiers) ? [a(\" \", h.map(T, \"modifiers\")), \" \"] : \"\";\n        }\n\n        function p(h, w, T) {\n          return h.type === \"EmptyStatement\" ? \";\" : h.type === \"BlockStatement\" || T ? [\" \", w] : s([r, w]);\n        }\n\n        function f(h, w, T) {\n          return [\"...\", T(\"argument\"), v(h, w, T)];\n        }\n\n        n.exports = {\n          printOptionalToken: i,\n          printDefiniteToken: o,\n          printFunctionTypeParameters: c,\n          printBindExpressionCallee: m,\n          printTypeScriptModifiers: d,\n          printTypeAnnotation: v,\n          printRestSpread: f,\n          adjustClause: p\n        };\n      }\n\n    }),\n        Kt = Z({\n      \"src/language-js/print/array.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et4 = et(),\n            t = _et4.printDanglingComments,\n            _Oe15 = Oe(),\n            _Oe15$builders = _Oe15.builders,\n            s = _Oe15$builders.line,\n            a = _Oe15$builders.softline,\n            r = _Oe15$builders.hardline,\n            u = _Oe15$builders.group,\n            i = _Oe15$builders.indent,\n            o = _Oe15$builders.ifBreak,\n            c = _Oe15$builders.fill,\n            _Ue11 = Ue(),\n            v = _Ue11.getLast,\n            m = _Ue11.hasNewline,\n            _Ke9 = Ke(),\n            d = _Ke9.shouldPrintComma,\n            p = _Ke9.hasComment,\n            f = _Ke9.CommentCheckFlags,\n            h = _Ke9.isNextLineEmpty,\n            w = _Ke9.isNumericLiteral,\n            T = _Ke9.isSignedNumericLiteral,\n            _st3 = st(),\n            A = _st3.locStart,\n            _ct = ct(),\n            S = _ct.printOptionalToken,\n            B = _ct.printTypeAnnotation;\n\n        function I(D, g, F) {\n          let l = D.getValue(),\n              E = [],\n              y = l.type === \"TupleExpression\" ? \"#[\" : \"[\",\n              N = \"]\";\n          if (l.elements.length === 0) p(l, f.Dangling) ? E.push(u([y, t(D, g), a, N])) : E.push(y, N);else {\n            let x = v(l.elements),\n                b = !(x && x.type === \"RestElement\"),\n                L = x === null,\n                M = Symbol(\"array\"),\n                j = !g.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y, H) => {\n              let R = q && q.type;\n              if (R !== \"ArrayExpression\" && R !== \"ObjectExpression\") return !1;\n              let Q = H[Y + 1];\n              if (Q && R !== Q.type) return !1;\n              let ee = R === \"ArrayExpression\" ? \"elements\" : \"properties\";\n              return q[ee] && q[ee].length > 1;\n            }),\n                $ = k(l, g),\n                V = b ? L ? \",\" : d(g) ? $ ? o(\",\", \"\", {\n              groupId: M\n            }) : o(\",\") : \"\" : \"\";\n            E.push(u([y, i([a, $ ? C(D, g, F, V) : [P(D, g, \"elements\", F), V], t(D, g, !0)]), a, N], {\n              shouldBreak: j,\n              id: M\n            }));\n          }\n          return E.push(S(D), B(D, g, F)), E;\n        }\n\n        function k(D, g) {\n          return D.elements.length > 1 && D.elements.every(F => F && (w(F) || T(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, l => !m(g.originalText, A(l), {\n            backwards: !0\n          })));\n        }\n\n        function P(D, g, F, l) {\n          let E = [],\n              y = [];\n          return D.each(N => {\n            E.push(y, u(l())), y = [\",\", s], N.getValue() && h(N.getValue(), g) && y.push(a);\n          }, F), E;\n        }\n\n        function C(D, g, F, l) {\n          let E = [];\n          return D.each((y, N, x) => {\n            let b = N === x.length - 1;\n            E.push([F(), b ? l : \",\"]), b || E.push(h(y.getValue(), g) ? [r, r] : p(x[N + 1], f.Leading | f.Line) ? r : s);\n          }, \"elements\"), c(E);\n        }\n\n        n.exports = {\n          printArray: I,\n          printArrayItems: P,\n          isConciselyPrintedArray: k\n        };\n      }\n\n    }),\n        io = Z({\n      \"src/language-js/print/call-arguments.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et5 = et(),\n            t = _et5.printDanglingComments,\n            _Ue12 = Ue(),\n            s = _Ue12.getLast,\n            a = _Ue12.getPenultimate,\n            _Ke10 = Ke(),\n            r = _Ke10.getFunctionParameters,\n            u = _Ke10.hasComment,\n            i = _Ke10.CommentCheckFlags,\n            o = _Ke10.isFunctionCompositionArgs,\n            c = _Ke10.isJsxNode,\n            v = _Ke10.isLongCurriedCallExpression,\n            m = _Ke10.shouldPrintComma,\n            d = _Ke10.getCallArguments,\n            p = _Ke10.iterateCallArgumentsPath,\n            f = _Ke10.isNextLineEmpty,\n            h = _Ke10.isCallExpression,\n            w = _Ke10.isStringLiteral,\n            T = _Ke10.isObjectProperty,\n            _Oe16 = Oe(),\n            _Oe16$builders = _Oe16.builders,\n            A = _Oe16$builders.line,\n            S = _Oe16$builders.hardline,\n            B = _Oe16$builders.softline,\n            I = _Oe16$builders.group,\n            k = _Oe16$builders.indent,\n            P = _Oe16$builders.conditionalGroup,\n            C = _Oe16$builders.ifBreak,\n            D = _Oe16$builders.breakParent,\n            g = _Oe16.utils.willBreak,\n            _zt3 = zt(),\n            F = _zt3.ArgExpansionBailout,\n            _Kt = Kt(),\n            l = _Kt.isConciselyPrintedArray;\n\n        function E(j, $, V) {\n          let q = j.getValue(),\n              Y = q.type === \"ImportExpression\",\n              H = d(q);\n          if (H.length === 0) return [\"(\", t(j, $, !0), \")\"];\n          if (b(H)) return [\"(\", V([\"arguments\", 0]), \", \", V([\"arguments\", 1]), \")\"];\n          let R = !1,\n              Q = !1,\n              ee = H.length - 1,\n              te = [];\n          p(j, (ie, G) => {\n            let z = ie.getNode(),\n                U = [V()];\n            G === ee || (f(z, $) ? (G === 0 && (Q = !0), R = !0, U.push(\",\", S, S)) : U.push(\",\", A)), te.push(U);\n          });\n          let oe = !(Y || q.callee && q.callee.type === \"Import\") && m($, \"all\") ? \",\" : \"\";\n\n          function W() {\n            return I([\"(\", k([A, ...te]), oe, A, \")\"], {\n              shouldBreak: !0\n            });\n          }\n\n          if (R || j.getParentNode().type !== \"Decorator\" && o(H)) return W();\n          let X = x(H),\n              ue = N(H, $);\n\n          if (X || ue) {\n            if (X ? te.slice(1).some(g) : te.slice(0, -1).some(g)) return W();\n            let ie = [];\n\n            try {\n              j.try(() => {\n                p(j, (G, z) => {\n                  X && z === 0 && (ie = [[V([], {\n                    expandFirstArg: !0\n                  }), te.length > 1 ? \",\" : \"\", Q ? S : A, Q ? S : \"\"], ...te.slice(1)]), ue && z === ee && (ie = [...te.slice(0, -1), V([], {\n                    expandLastArg: !0\n                  })]);\n                });\n              });\n            } catch (G) {\n              if (G instanceof F) return W();\n              throw G;\n            }\n\n            return [te.some(g) ? D : \"\", P([[\"(\", ...ie, \")\"], X ? [\"(\", I(ie[0], {\n              shouldBreak: !0\n            }), ...ie.slice(1), \")\"] : [\"(\", ...te.slice(0, -1), I(s(ie), {\n              shouldBreak: !0\n            }), \")\"], W()])];\n          }\n\n          let De = [\"(\", k([B, ...te]), C(oe), B, \")\"];\n          return v(j) ? De : I(De, {\n            shouldBreak: te.some(g) || R\n          });\n        }\n\n        function y(j) {\n          let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n          return j.type === \"ObjectExpression\" && (j.properties.length > 0 || u(j)) || j.type === \"ArrayExpression\" && (j.elements.length > 0 || u(j)) || j.type === \"TSTypeAssertion\" && y(j.expression) || j.type === \"TSAsExpression\" && y(j.expression) || j.type === \"FunctionExpression\" || j.type === \"ArrowFunctionExpression\" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== \"TSTypeReference\" || L(j.body)) && (j.body.type === \"BlockStatement\" || j.body.type === \"ArrowFunctionExpression\" && y(j.body, !0) || j.body.type === \"ObjectExpression\" || j.body.type === \"ArrayExpression\" || !$ && (h(j.body) || j.body.type === \"ConditionalExpression\") || c(j.body)) || j.type === \"DoExpression\" || j.type === \"ModuleExpression\";\n        }\n\n        function N(j, $) {\n          let V = s(j),\n              q = a(j);\n          return !u(V, i.Leading) && !u(V, i.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== \"ArrowFunctionExpression\" || V.type !== \"ArrayExpression\") && !(j.length > 1 && V.type === \"ArrayExpression\" && l(V, $));\n        }\n\n        function x(j) {\n          if (j.length !== 2) return !1;\n\n          let _j = _slicedToArray(j, 2),\n              $ = _j[0],\n              V = _j[1];\n\n          return $.type === \"ModuleExpression\" && M(V) ? !0 : !u($) && ($.type === \"FunctionExpression\" || $.type === \"ArrowFunctionExpression\" && $.body.type === \"BlockStatement\") && V.type !== \"FunctionExpression\" && V.type !== \"ArrowFunctionExpression\" && V.type !== \"ConditionalExpression\" && !y(V);\n        }\n\n        function b(j) {\n          return j.length === 2 && j[0].type === \"ArrowFunctionExpression\" && r(j[0]).length === 0 && j[0].body.type === \"BlockStatement\" && j[1].type === \"ArrayExpression\" && !j.some($ => u($));\n        }\n\n        function L(j) {\n          return j.type === \"BlockStatement\" && (j.body.some($ => $.type !== \"EmptyStatement\") || u(j, i.Dangling));\n        }\n\n        function M(j) {\n          return j.type === \"ObjectExpression\" && j.properties.length === 1 && T(j.properties[0]) && j.properties[0].key.type === \"Identifier\" && j.properties[0].key.name === \"type\" && w(j.properties[0].value) && j.properties[0].value.value === \"module\";\n        }\n\n        n.exports = E;\n      }\n\n    }),\n        ao = Z({\n      \"src/language-js/print/member.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe17 = Oe(),\n            _Oe17$builders = _Oe17.builders,\n            t = _Oe17$builders.softline,\n            s = _Oe17$builders.group,\n            a = _Oe17$builders.indent,\n            r = _Oe17$builders.label,\n            _Ke11 = Ke(),\n            u = _Ke11.isNumericLiteral,\n            i = _Ke11.isMemberExpression,\n            o = _Ke11.isCallExpression,\n            _ct2 = ct(),\n            c = _ct2.printOptionalToken;\n\n        function v(d, p, f) {\n          let h = d.getValue(),\n              w = d.getParentNode(),\n              T,\n              A = 0;\n\n          do T = d.getParentNode(A), A++; while (T && (i(T) || T.type === \"TSNonNullExpression\"));\n\n          let S = f(\"object\"),\n              B = m(d, p, f),\n              I = T && (T.type === \"NewExpression\" || T.type === \"BindExpression\" || T.type === \"AssignmentExpression\" && T.left.type !== \"Identifier\") || h.computed || h.object.type === \"Identifier\" && h.property.type === \"Identifier\" && !i(w) || (w.type === \"AssignmentExpression\" || w.type === \"VariableDeclarator\") && (o(h.object) && h.object.arguments.length > 0 || h.object.type === \"TSNonNullExpression\" && o(h.object.expression) && h.object.expression.arguments.length > 0 || S.label === \"member-chain\");\n          return r(S.label === \"member-chain\" ? \"member-chain\" : \"member\", [S, I ? B : s(a([t, B]))]);\n        }\n\n        function m(d, p, f) {\n          let h = f(\"property\"),\n              w = d.getValue(),\n              T = c(d);\n          return w.computed ? !w.property || u(w.property) ? [T, \"[\", h, \"]\"] : s([T, \"[\", a([t, h]), t, \"]\"]) : [T, \".\", h];\n        }\n\n        n.exports = {\n          printMemberExpression: v,\n          printMemberLookup: m\n        };\n      }\n\n    }),\n        Jm = Z({\n      \"src/language-js/print/member-chain.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et6 = et(),\n            t = _et6.printComments,\n            _Ue13 = Ue(),\n            s = _Ue13.getLast,\n            a = _Ue13.isNextLineEmptyAfterIndex,\n            r = _Ue13.getNextNonSpaceNonCommentCharacterIndex,\n            u = jt(),\n            _Ke12 = Ke(),\n            i = _Ke12.isCallExpression,\n            o = _Ke12.isMemberExpression,\n            c = _Ke12.isFunctionOrArrowExpression,\n            v = _Ke12.isLongCurriedCallExpression,\n            m = _Ke12.isMemberish,\n            d = _Ke12.isNumericLiteral,\n            p = _Ke12.isSimpleCallArgument,\n            f = _Ke12.hasComment,\n            h = _Ke12.CommentCheckFlags,\n            w = _Ke12.isNextLineEmpty,\n            _st4 = st(),\n            T = _st4.locEnd,\n            _Oe18 = Oe(),\n            _Oe18$builders = _Oe18.builders,\n            A = _Oe18$builders.join,\n            S = _Oe18$builders.hardline,\n            B = _Oe18$builders.group,\n            I = _Oe18$builders.indent,\n            k = _Oe18$builders.conditionalGroup,\n            P = _Oe18$builders.breakParent,\n            C = _Oe18$builders.label,\n            D = _Oe18.utils.willBreak,\n            g = io(),\n            _ao = ao(),\n            F = _ao.printMemberLookup,\n            _ct3 = ct(),\n            l = _ct3.printOptionalToken,\n            E = _ct3.printFunctionTypeParameters,\n            y = _ct3.printBindExpressionCallee;\n\n        function N(x, b, L) {\n          let M = x.getParentNode(),\n              j = !M || M.type === \"ExpressionStatement\",\n              $ = [];\n\n          function V(de) {\n            let ae = b.originalText,\n                ve = r(ae, de, T);\n            return ae.charAt(ve) === \")\" ? ve !== !1 && a(ae, ve + 1) : w(de, b);\n          }\n\n          function q(de) {\n            let ae = de.getValue();\n            i(ae) && (m(ae.callee) || i(ae.callee)) ? ($.unshift({\n              node: ae,\n              printed: [t(de, [l(de), E(de, b, L), g(de, b, L)], b), V(ae) ? S : \"\"]\n            }), de.call(ve => q(ve), \"callee\")) : m(ae) ? ($.unshift({\n              node: ae,\n              needsParens: u(de, b),\n              printed: t(de, o(ae) ? F(de, b, L) : y(de, b, L), b)\n            }), de.call(ve => q(ve), \"object\")) : ae.type === \"TSNonNullExpression\" ? ($.unshift({\n              node: ae,\n              printed: t(de, \"!\", b)\n            }), de.call(ve => q(ve), \"expression\")) : $.unshift({\n              node: ae,\n              printed: L()\n            });\n          }\n\n          let Y = x.getValue();\n          $.unshift({\n            node: Y,\n            printed: [l(x), E(x, b, L), g(x, b, L)]\n          }), Y.callee && x.call(de => q(de), \"callee\");\n          let H = [],\n              R = [$[0]],\n              Q = 1;\n\n          for (; Q < $.length && ($[Q].node.type === \"TSNonNullExpression\" || i($[Q].node) || o($[Q].node) && $[Q].node.computed && d($[Q].node.property)); ++Q) R.push($[Q]);\n\n          if (!i($[0].node)) for (; Q + 1 < $.length && m($[Q].node) && m($[Q + 1].node); ++Q) R.push($[Q]);\n          H.push(R), R = [];\n          let ee = !1;\n\n          for (; Q < $.length; ++Q) {\n            if (ee && m($[Q].node)) {\n              if ($[Q].node.computed && d($[Q].node.property)) {\n                R.push($[Q]);\n                continue;\n              }\n\n              H.push(R), R = [], ee = !1;\n            }\n\n            (i($[Q].node) || $[Q].node.type === \"ImportExpression\") && (ee = !0), R.push($[Q]), f($[Q].node, h.Trailing) && (H.push(R), R = [], ee = !1);\n          }\n\n          R.length > 0 && H.push(R);\n\n          function te(de) {\n            return /^[A-Z]|^[$_]+$/.test(de);\n          }\n\n          function oe(de) {\n            return de.length <= b.tabWidth;\n          }\n\n          function W(de) {\n            let ae = de[1].length > 0 && de[1][0].node.computed;\n\n            if (de[0].length === 1) {\n              let K = de[0][0].node;\n              return K.type === \"ThisExpression\" || K.type === \"Identifier\" && (te(K.name) || j && oe(K.name) || ae);\n            }\n\n            let ve = s(de[0]).node;\n            return o(ve) && ve.property.type === \"Identifier\" && (te(ve.property.name) || ae);\n          }\n\n          let X = H.length >= 2 && !f(H[1][0].node) && W(H);\n\n          function ue(de) {\n            let ae = de.map(ve => ve.printed);\n            return de.length > 0 && s(de).needsParens ? [\"(\", ...ae, \")\"] : ae;\n          }\n\n          function De(de) {\n            return de.length === 0 ? \"\" : I(B([S, A(S, de.map(ue))]));\n          }\n\n          let ie = H.map(ue),\n              G = ie,\n              z = X ? 3 : 2,\n              U = H.flat(),\n              le = U.slice(1, -1).some(de => f(de.node, h.Leading)) || U.slice(0, -1).some(de => f(de.node, h.Trailing)) || H[z] && f(H[z][0].node, h.Leading);\n          if (H.length <= z && !le) return v(x) ? G : B(G);\n          let ge = s(H[X ? 1 : 0]).node,\n              Ae = !i(ge) && V(ge),\n              Ne = [ue(H[0]), X ? H.slice(1, 2).map(ue) : \"\", Ae ? S : \"\", De(H.slice(X ? 2 : 1))],\n              ke = $.map(de => {\n            let ae = de.node;\n            return ae;\n          }).filter(i);\n\n          function ce() {\n            let de = s(s(H)).node,\n                ae = s(ie);\n            return i(de) && D(ae) && ke.slice(0, -1).some(ve => ve.arguments.some(c));\n          }\n\n          let pe;\n          return le || ke.length > 2 && ke.some(de => !de.arguments.every(ae => p(ae, 0))) || ie.slice(0, -1).some(D) || ce() ? pe = B(Ne) : pe = [D(G) || Ae ? P : \"\", k([G, Ne])], C(\"member-chain\", pe);\n        }\n\n        n.exports = N;\n      }\n\n    }),\n        oo = Z({\n      \"src/language-js/print/call-expression.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe19 = Oe(),\n            _Oe19$builders = _Oe19.builders,\n            t = _Oe19$builders.join,\n            s = _Oe19$builders.group,\n            a = jt(),\n            _Ke13 = Ke(),\n            r = _Ke13.getCallArguments,\n            u = _Ke13.hasFlowAnnotationComment,\n            i = _Ke13.isCallExpression,\n            o = _Ke13.isMemberish,\n            c = _Ke13.isStringLiteral,\n            v = _Ke13.isTemplateOnItsOwnLine,\n            m = _Ke13.isTestCall,\n            d = _Ke13.iterateCallArgumentsPath,\n            p = Jm(),\n            f = io(),\n            _ct4 = ct(),\n            h = _ct4.printOptionalToken,\n            w = _ct4.printFunctionTypeParameters;\n\n        function T(S, B, I) {\n          let k = S.getValue(),\n              P = S.getParentNode(),\n              C = k.type === \"NewExpression\",\n              D = k.type === \"ImportExpression\",\n              g = h(S),\n              F = r(k);\n\n          if (F.length > 0 && (!D && !C && A(k, P) || F.length === 1 && v(F[0], B.originalText) || !C && m(k, P))) {\n            let y = [];\n            return d(S, () => {\n              y.push(I());\n            }), [C ? \"new \" : \"\", I(\"callee\"), g, w(S, B, I), \"(\", t(\", \", y), \")\"];\n          }\n\n          let l = (B.parser === \"babel\" || B.parser === \"babel-flow\") && k.callee && k.callee.type === \"Identifier\" && u(k.callee.trailingComments);\n          if (l && (k.callee.trailingComments[0].printed = !0), !D && !C && o(k.callee) && !S.call(y => a(y, B), \"callee\")) return p(S, B, I);\n          let E = [C ? \"new \" : \"\", D ? \"import\" : I(\"callee\"), g, l ? \"/*:: \".concat(k.callee.trailingComments[0].value.slice(2).trim(), \" */\") : \"\", w(S, B, I), f(S, B, I)];\n          return D || i(k.callee) ? s(E) : E;\n        }\n\n        function A(S, B) {\n          if (S.callee.type !== \"Identifier\") return !1;\n          if (S.callee.name === \"require\") return !0;\n\n          if (S.callee.name === \"define\") {\n            let I = r(S);\n            return B.type === \"ExpressionStatement\" && (I.length === 1 || I.length === 2 && I[0].type === \"ArrayExpression\" || I.length === 3 && c(I[0]) && I[1].type === \"ArrayExpression\");\n          }\n\n          return !1;\n        }\n\n        n.exports = {\n          printCallExpression: T\n        };\n      }\n\n    }),\n        Yt = Z({\n      \"src/language-js/print/assignment.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue14 = Ue(),\n            t = _Ue14.isNonEmptyArray,\n            s = _Ue14.getStringWidth,\n            _Oe20 = Oe(),\n            _Oe20$builders = _Oe20.builders,\n            a = _Oe20$builders.line,\n            r = _Oe20$builders.group,\n            u = _Oe20$builders.indent,\n            i = _Oe20$builders.indentIfBreak,\n            o = _Oe20$builders.lineSuffixBoundary,\n            _Oe20$utils = _Oe20.utils,\n            c = _Oe20$utils.cleanDoc,\n            v = _Oe20$utils.willBreak,\n            m = _Oe20$utils.canBreak,\n            _Ke14 = Ke(),\n            d = _Ke14.hasLeadingOwnLineComment,\n            p = _Ke14.isBinaryish,\n            f = _Ke14.isStringLiteral,\n            h = _Ke14.isLiteral,\n            w = _Ke14.isNumericLiteral,\n            T = _Ke14.isCallExpression,\n            A = _Ke14.isMemberExpression,\n            S = _Ke14.getCallArguments,\n            B = _Ke14.rawText,\n            I = _Ke14.hasComment,\n            k = _Ke14.isSignedNumericLiteral,\n            P = _Ke14.isObjectProperty,\n            _Jn2 = Jn(),\n            C = _Jn2.shouldInlineLogicalExpression,\n            _oo = oo(),\n            D = _oo.printCallExpression;\n\n        function g(W, X, ue, De, ie, G) {\n          let z = E(W, X, ue, De, G),\n              U = ue(G, {\n            assignmentLayout: z\n          });\n\n          switch (z) {\n            case \"break-after-operator\":\n              return r([r(De), ie, r(u([a, U]))]);\n\n            case \"never-break-after-operator\":\n              return r([r(De), ie, \" \", U]);\n\n            case \"fluid\":\n              {\n                let le = Symbol(\"assignment\");\n                return r([r(De), ie, r(u(a), {\n                  id: le\n                }), o, i(U, {\n                  groupId: le\n                })]);\n              }\n\n            case \"break-lhs\":\n              return r([De, ie, \" \", r(U)]);\n\n            case \"chain\":\n              return [r(De), ie, a, U];\n\n            case \"chain-tail\":\n              return [r(De), ie, u([a, U])];\n\n            case \"chain-tail-arrow-chain\":\n              return [r(De), ie, U];\n\n            case \"only-left\":\n              return De;\n          }\n        }\n\n        function F(W, X, ue) {\n          let De = W.getValue();\n          return g(W, X, ue, ue(\"left\"), [\" \", De.operator], \"right\");\n        }\n\n        function l(W, X, ue) {\n          return g(W, X, ue, ue(\"id\"), \" =\", \"init\");\n        }\n\n        function E(W, X, ue, De, ie) {\n          let G = W.getValue(),\n              z = G[ie];\n          if (!z) return \"only-left\";\n          let U = !x(z);\n          if (W.match(x, b, Ne => !U || Ne.type !== \"ExpressionStatement\" && Ne.type !== \"VariableDeclaration\")) return U ? z.type === \"ArrowFunctionExpression\" && z.body.type === \"ArrowFunctionExpression\" ? \"chain-tail-arrow-chain\" : \"chain-tail\" : \"chain\";\n          if (!U && x(z.right) || d(X.originalText, z)) return \"break-after-operator\";\n          if (z.type === \"CallExpression\" && z.callee.name === \"require\" || X.parser === \"json5\" || X.parser === \"json\") return \"never-break-after-operator\";\n          if (N(G) || L(G) || $(G) || V(G) && m(De)) return \"break-lhs\";\n          let Ae = ee(G, De, X);\n          return W.call(() => y(W, X, ue, Ae), ie) ? \"break-after-operator\" : Ae || z.type === \"TemplateLiteral\" || z.type === \"TaggedTemplateExpression\" || z.type === \"BooleanLiteral\" || w(z) || z.type === \"ClassExpression\" ? \"never-break-after-operator\" : \"fluid\";\n        }\n\n        function y(W, X, ue, De) {\n          let ie = W.getValue();\n          if (p(ie) && !C(ie)) return !0;\n\n          switch (ie.type) {\n            case \"StringLiteralTypeAnnotation\":\n            case \"SequenceExpression\":\n              return !0;\n\n            case \"ConditionalExpression\":\n              {\n                let U = ie.test;\n                return p(U) && !C(U);\n              }\n\n            case \"ClassExpression\":\n              return t(ie.decorators);\n          }\n\n          if (De) return !1;\n          let G = ie,\n              z = [];\n\n          for (;;) if (G.type === \"UnaryExpression\") G = G.argument, z.push(\"argument\");else if (G.type === \"TSNonNullExpression\") G = G.expression, z.push(\"expression\");else break;\n\n          return !!(f(G) || W.call(() => H(W, X, ue), ...z));\n        }\n\n        function N(W) {\n          if (b(W)) {\n            let X = W.left || W.id;\n            return X.type === \"ObjectPattern\" && X.properties.length > 2 && X.properties.some(ue => P(ue) && (!ue.shorthand || ue.value && ue.value.type === \"AssignmentPattern\"));\n          }\n\n          return !1;\n        }\n\n        function x(W) {\n          return W.type === \"AssignmentExpression\";\n        }\n\n        function b(W) {\n          return x(W) || W.type === \"VariableDeclarator\";\n        }\n\n        function L(W) {\n          let X = M(W);\n\n          if (t(X)) {\n            let ue = W.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";\n            if (X.length > 1 && X.some(De => De[ue] || De.default)) return !0;\n          }\n\n          return !1;\n        }\n\n        function M(W) {\n          return j(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n        }\n\n        function j(W) {\n          return W.type === \"TSTypeAliasDeclaration\" || W.type === \"TypeAlias\";\n        }\n\n        function $(W) {\n          if (W.type !== \"VariableDeclarator\") return !1;\n          let X = W.id.typeAnnotation;\n          if (!X || !X.typeAnnotation) return !1;\n          let ue = q(X.typeAnnotation);\n          return t(ue) && ue.length > 1 && ue.some(De => t(q(De)) || De.type === \"TSConditionalType\");\n        }\n\n        function V(W) {\n          return W.type === \"VariableDeclarator\" && W.init && W.init.type === \"ArrowFunctionExpression\";\n        }\n\n        function q(W) {\n          return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;\n        }\n\n        function Y(W) {\n          return W.type === \"TSTypeReference\" || W.type === \"GenericTypeAnnotation\";\n        }\n\n        function H(W, X, ue) {\n          let De = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,\n              ie = W.getValue(),\n              G = () => H(W, X, ue, !0);\n\n          if (ie.type === \"TSNonNullExpression\") return W.call(G, \"expression\");\n\n          if (T(ie)) {\n            if (D(W, X, ue).label === \"member-chain\") return !1;\n            let U = S(ie);\n            return !(U.length === 0 || U.length === 1 && Q(U[0], X)) || te(ie, ue) ? !1 : W.call(G, \"callee\");\n          }\n\n          return A(ie) ? W.call(G, \"object\") : De && (ie.type === \"Identifier\" || ie.type === \"ThisExpression\");\n        }\n\n        var R = .25;\n\n        function Q(W, X) {\n          let ue = X.printWidth;\n          if (I(W)) return !1;\n          let De = ue * R;\n          if (W.type === \"ThisExpression\" || W.type === \"Identifier\" && W.name.length <= De || k(W) && !I(W.argument)) return !0;\n          let ie = W.type === \"Literal\" && \"regex\" in W && W.regex.pattern || W.type === \"RegExpLiteral\" && W.pattern;\n          return ie ? ie.length <= De : f(W) ? B(W).length <= De : W.type === \"TemplateLiteral\" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= De && !W.quasis[0].value.raw.includes(\"\\n\") : h(W);\n        }\n\n        function ee(W, X, ue) {\n          if (!P(W)) return !1;\n          X = c(X);\n          let De = 3;\n          return typeof X == \"string\" && s(X) < ue.tabWidth + De;\n        }\n\n        function te(W, X) {\n          let ue = oe(W);\n\n          if (t(ue)) {\n            if (ue.length > 1) return !0;\n\n            if (ue.length === 1) {\n              let ie = ue[0];\n              if (ie.type === \"TSUnionType\" || ie.type === \"UnionTypeAnnotation\" || ie.type === \"TSIntersectionType\" || ie.type === \"IntersectionTypeAnnotation\" || ie.type === \"TSTypeLiteral\" || ie.type === \"ObjectTypeAnnotation\") return !0;\n            }\n\n            let De = W.typeParameters ? \"typeParameters\" : \"typeArguments\";\n            if (v(X(De))) return !0;\n          }\n\n          return !1;\n        }\n\n        function oe(W) {\n          return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;\n        }\n\n        n.exports = {\n          printVariableDeclarator: l,\n          printAssignmentExpression: F,\n          printAssignment: g,\n          isArrowFunctionVariableDeclarator: V\n        };\n      }\n\n    }),\n        Pr = Z({\n      \"src/language-js/print/function-parameters.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue15 = Ue(),\n            t = _Ue15.getNextNonSpaceNonCommentCharacter,\n            _et7 = et(),\n            s = _et7.printDanglingComments,\n            _Oe21 = Oe(),\n            _Oe21$builders = _Oe21.builders,\n            a = _Oe21$builders.line,\n            r = _Oe21$builders.hardline,\n            u = _Oe21$builders.softline,\n            i = _Oe21$builders.group,\n            o = _Oe21$builders.indent,\n            c = _Oe21$builders.ifBreak,\n            _Oe21$utils = _Oe21.utils,\n            v = _Oe21$utils.removeLines,\n            m = _Oe21$utils.willBreak,\n            _Ke15 = Ke(),\n            d = _Ke15.getFunctionParameters,\n            p = _Ke15.iterateFunctionParametersPath,\n            f = _Ke15.isSimpleType,\n            h = _Ke15.isTestCall,\n            w = _Ke15.isTypeAnnotationAFunction,\n            T = _Ke15.isObjectType,\n            A = _Ke15.isObjectTypePropertyAFunction,\n            S = _Ke15.hasRestParameter,\n            B = _Ke15.shouldPrintComma,\n            I = _Ke15.hasComment,\n            k = _Ke15.isNextLineEmpty,\n            _st5 = st(),\n            P = _st5.locEnd,\n            _zt4 = zt(),\n            C = _zt4.ArgExpansionBailout,\n            _ct5 = ct(),\n            D = _ct5.printFunctionTypeParameters;\n\n        function g(y, N, x, b, L) {\n          let M = y.getValue(),\n              j = d(M),\n              $ = L ? D(y, x, N) : \"\";\n          if (j.length === 0) return [$, \"(\", s(y, x, !0, ee => t(x.originalText, ee, P) === \")\"), \")\"];\n          let V = y.getParentNode(),\n              q = h(V),\n              Y = F(M),\n              H = [];\n\n          if (p(y, (ee, te) => {\n            let oe = te === j.length - 1;\n            oe && M.rest && H.push(\"...\"), H.push(N()), !oe && (H.push(\",\"), q || Y ? H.push(\" \") : k(j[te], x) ? H.push(r, r) : H.push(a));\n          }), b) {\n            if (m($) || m(H)) throw new C();\n            return i([v($), \"(\", v(H), \")\"]);\n          }\n\n          let R = j.every(ee => !ee.decorators);\n          return Y && R ? [$, \"(\", ...H, \")\"] : q ? [$, \"(\", ...H, \")\"] : (A(V) || w(V) || V.type === \"TypeAlias\" || V.type === \"UnionTypeAnnotation\" || V.type === \"TSUnionType\" || V.type === \"IntersectionTypeAnnotation\" || V.type === \"FunctionTypeAnnotation\" && V.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && f(j[0].typeAnnotation) && !M.rest ? x.arrowParens === \"always\" ? [\"(\", ...H, \")\"] : H : [$, \"(\", o([u, ...H]), c(!S(M) && B(x, \"all\") ? \",\" : \"\"), u, \")\"];\n        }\n\n        function F(y) {\n          if (!y) return !1;\n          let N = d(y);\n          if (N.length !== 1) return !1;\n\n          let _N2 = _slicedToArray(N, 1),\n              x = _N2[0];\n\n          return !I(x) && (x.type === \"ObjectPattern\" || x.type === \"ArrayPattern\" || x.type === \"Identifier\" && x.typeAnnotation && (x.typeAnnotation.type === \"TypeAnnotation\" || x.typeAnnotation.type === \"TSTypeAnnotation\") && T(x.typeAnnotation.typeAnnotation) || x.type === \"FunctionTypeParam\" && T(x.typeAnnotation) || x.type === \"AssignmentPattern\" && (x.left.type === \"ObjectPattern\" || x.left.type === \"ArrayPattern\") && (x.right.type === \"Identifier\" || x.right.type === \"ObjectExpression\" && x.right.properties.length === 0 || x.right.type === \"ArrayExpression\" && x.right.elements.length === 0));\n        }\n\n        function l(y) {\n          let N;\n          return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;\n        }\n\n        function E(y, N) {\n          let x = l(y);\n          if (!x) return !1;\n          let b = y.typeParameters && y.typeParameters.params;\n\n          if (b) {\n            if (b.length > 1) return !1;\n\n            if (b.length === 1) {\n              let L = b[0];\n              if (L.constraint || L.default) return !1;\n            }\n          }\n\n          return d(y).length === 1 && (T(x) || m(N));\n        }\n\n        n.exports = {\n          printFunctionParameters: g,\n          shouldHugFunctionParameters: F,\n          shouldGroupFunctionParameters: E\n        };\n      }\n\n    }),\n        kr = Z({\n      \"src/language-js/print/type-annotation.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et8 = et(),\n            t = _et8.printComments,\n            s = _et8.printDanglingComments,\n            _Ue16 = Ue(),\n            a = _Ue16.isNonEmptyArray,\n            _Oe22 = Oe(),\n            _Oe22$builders = _Oe22.builders,\n            r = _Oe22$builders.group,\n            u = _Oe22$builders.join,\n            i = _Oe22$builders.line,\n            o = _Oe22$builders.softline,\n            c = _Oe22$builders.indent,\n            v = _Oe22$builders.align,\n            m = _Oe22$builders.ifBreak,\n            d = jt(),\n            _st6 = st(),\n            p = _st6.locStart,\n            _Ke16 = Ke(),\n            f = _Ke16.isSimpleType,\n            h = _Ke16.isObjectType,\n            w = _Ke16.hasLeadingOwnLineComment,\n            T = _Ke16.isObjectTypePropertyAFunction,\n            A = _Ke16.shouldPrintComma,\n            _Yt = Yt(),\n            S = _Yt.printAssignment,\n            _Pr = Pr(),\n            B = _Pr.printFunctionParameters,\n            I = _Pr.shouldGroupFunctionParameters,\n            _Kt2 = Kt(),\n            k = _Kt2.printArrayItems;\n\n        function P(x) {\n          if (f(x) || h(x)) return !0;\n\n          if (x.type === \"UnionTypeAnnotation\" || x.type === \"TSUnionType\") {\n            let b = x.types.filter(M => M.type === \"VoidTypeAnnotation\" || M.type === \"TSVoidKeyword\" || M.type === \"NullLiteralTypeAnnotation\" || M.type === \"TSNullKeyword\").length,\n                L = x.types.some(M => M.type === \"ObjectTypeAnnotation\" || M.type === \"TSTypeLiteral\" || M.type === \"GenericTypeAnnotation\" || M.type === \"TSTypeReference\");\n            if (x.types.length - 1 === b && L) return !0;\n          }\n\n          return !1;\n        }\n\n        function C(x, b, L) {\n          let M = b.semi ? \";\" : \"\",\n              j = x.getValue(),\n              $ = [];\n          return $.push(\"opaque type \", L(\"id\"), L(\"typeParameters\")), j.supertype && $.push(\": \", L(\"supertype\")), j.impltype && $.push(\" = \", L(\"impltype\")), $.push(M), $;\n        }\n\n        function D(x, b, L) {\n          let M = b.semi ? \";\" : \"\",\n              j = x.getValue(),\n              $ = [];\n          j.declare && $.push(\"declare \"), $.push(\"type \", L(\"id\"), L(\"typeParameters\"));\n          let V = j.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";\n          return [S(x, b, L, $, \" =\", V), M];\n        }\n\n        function g(x, b, L) {\n          let M = x.getValue(),\n              j = x.map(L, \"types\"),\n              $ = [],\n              V = !1;\n\n          for (let q = 0; q < j.length; ++q) q === 0 ? $.push(j[q]) : h(M.types[q - 1]) && h(M.types[q]) ? $.push([\" & \", V ? c(j[q]) : j[q]]) : !h(M.types[q - 1]) && !h(M.types[q]) ? $.push(c([\" &\", i, j[q]])) : (q > 1 && (V = !0), $.push(\" & \", q > 1 ? c(j[q]) : j[q]));\n\n          return r($);\n        }\n\n        function F(x, b, L) {\n          let M = x.getValue(),\n              j = x.getParentNode(),\n              $ = j.type !== \"TypeParameterInstantiation\" && j.type !== \"TSTypeParameterInstantiation\" && j.type !== \"GenericTypeAnnotation\" && j.type !== \"TSTypeReference\" && j.type !== \"TSTypeAssertion\" && j.type !== \"TupleTypeAnnotation\" && j.type !== \"TSTupleType\" && !(j.type === \"FunctionTypeParam\" && !j.name && x.getParentNode(1).this !== j) && !((j.type === \"TypeAlias\" || j.type === \"VariableDeclarator\" || j.type === \"TSTypeAliasDeclaration\") && w(b.originalText, M)),\n              V = P(M),\n              q = x.map(R => {\n            let Q = L();\n            return V || (Q = v(2, Q)), t(R, Q, b);\n          }, \"types\");\n          if (V) return u(\" | \", q);\n          let Y = $ && !w(b.originalText, M),\n              H = [m([Y ? i : \"\", \"| \"]), u([i, \"| \"], q)];\n          return d(x, b) ? r([c(H), o]) : j.type === \"TupleTypeAnnotation\" && j.types.length > 1 || j.type === \"TSTupleType\" && j.elementTypes.length > 1 ? r([c([m([\"(\", o]), H]), o, m(\")\")]) : r($ ? c(H) : H);\n        }\n\n        function l(x, b, L) {\n          let M = x.getValue(),\n              j = [],\n              $ = x.getParentNode(0),\n              V = x.getParentNode(1),\n              q = x.getParentNode(2),\n              Y = M.type === \"TSFunctionType\" || !(($.type === \"ObjectTypeProperty\" || $.type === \"ObjectTypeInternalSlot\") && !$.variance && !$.optional && p($) === p(M) || $.type === \"ObjectTypeCallProperty\" || q && q.type === \"DeclareFunction\"),\n              H = Y && ($.type === \"TypeAnnotation\" || $.type === \"TSTypeAnnotation\"),\n              R = H && Y && ($.type === \"TypeAnnotation\" || $.type === \"TSTypeAnnotation\") && V.type === \"ArrowFunctionExpression\";\n          T($) && (Y = !0, H = !0), R && j.push(\"(\");\n          let Q = B(x, L, b, !1, !0),\n              ee = M.returnType || M.predicate || M.typeAnnotation ? [Y ? \" => \" : \": \", L(\"returnType\"), L(\"predicate\"), L(\"typeAnnotation\")] : \"\",\n              te = I(M, ee);\n          return j.push(te ? r(Q) : Q), ee && j.push(ee), R && j.push(\")\"), r(j);\n        }\n\n        function E(x, b, L) {\n          let M = x.getValue(),\n              j = M.type === \"TSTupleType\" ? \"elementTypes\" : \"types\",\n              $ = M[j],\n              V = a($),\n              q = V ? o : \"\";\n          return r([\"[\", c([q, k(x, b, j, L)]), m(V && A(b, \"all\") ? \",\" : \"\"), s(x, b, !0), q, \"]\"]);\n        }\n\n        function y(x, b, L) {\n          let M = x.getValue(),\n              j = M.type === \"OptionalIndexedAccessType\" && M.optional ? \"?.[\" : \"[\";\n          return [L(\"objectType\"), j, L(\"indexType\"), \"]\"];\n        }\n\n        function N(x, b, L) {\n          let M = x.getValue();\n          return [M.postfix ? \"\" : L, b(\"typeAnnotation\"), M.postfix ? L : \"\"];\n        }\n\n        n.exports = {\n          printOpaqueType: C,\n          printTypeAlias: D,\n          printIntersectionType: g,\n          printUnionType: F,\n          printFunctionType: l,\n          printTupleType: E,\n          printIndexedAccessType: y,\n          shouldHugType: P,\n          printJSDocType: N\n        };\n      }\n\n    }),\n        Ir = Z({\n      \"src/language-js/print/type-parameters.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et9 = et(),\n            t = _et9.printDanglingComments,\n            _Oe23 = Oe(),\n            _Oe23$builders = _Oe23.builders,\n            s = _Oe23$builders.join,\n            a = _Oe23$builders.line,\n            r = _Oe23$builders.hardline,\n            u = _Oe23$builders.softline,\n            i = _Oe23$builders.group,\n            o = _Oe23$builders.indent,\n            c = _Oe23$builders.ifBreak,\n            _Ke17 = Ke(),\n            v = _Ke17.isTestCall,\n            m = _Ke17.hasComment,\n            d = _Ke17.CommentCheckFlags,\n            p = _Ke17.isTSXFile,\n            f = _Ke17.shouldPrintComma,\n            h = _Ke17.getFunctionParameters,\n            w = _Ke17.isObjectType,\n            _Ue17 = Ue(),\n            T = _Ue17.createGroupIdMapper,\n            _kr = kr(),\n            A = _kr.shouldHugType,\n            _Yt2 = Yt(),\n            S = _Yt2.isArrowFunctionVariableDeclarator,\n            B = T(\"typeParameters\");\n\n        function I(C, D, g, F) {\n          let l = C.getValue();\n          if (!l[F]) return \"\";\n          if (!Array.isArray(l[F])) return g(F);\n          let E = C.getNode(2),\n              y = E && v(E);\n          if (!C.match(L => !(L[F].length === 1 && w(L[F][0])), void 0, (L, M) => M === \"typeAnnotation\", L => L.type === \"Identifier\", S) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === \"NullableTypeAnnotation\" || A(l[F][0])))) return [\"<\", s(\", \", C.map(g, F)), k(C, D), \">\"];\n          let b = l.type === \"TSTypeParameterInstantiation\" ? \"\" : h(l).length === 1 && p(D) && !l[F][0].constraint && C.getParentNode().type === \"ArrowFunctionExpression\" ? \",\" : f(D, \"all\") ? c(\",\") : \"\";\n          return i([\"<\", o([u, s([\",\", a], C.map(g, F))]), b, u, \">\"], {\n            id: B(l)\n          });\n        }\n\n        function k(C, D) {\n          let g = C.getValue();\n          if (!m(g, d.Dangling)) return \"\";\n          let F = !m(g, d.Line),\n              l = t(C, D, F);\n          return F ? l : [l, r];\n        }\n\n        function P(C, D, g) {\n          let F = C.getValue(),\n              l = [],\n              E = C.getParentNode();\n          return E.type === \"TSMappedType\" ? (l.push(\"[\", g(\"name\")), F.constraint && l.push(\" in \", g(\"constraint\")), E.nameType && l.push(\" as \", C.callParent(() => g(\"nameType\"))), l.push(\"]\"), l) : (F.variance && l.push(g(\"variance\")), F.in && l.push(\"in \"), F.out && l.push(\"out \"), l.push(g(\"name\")), F.bound && l.push(\": \", g(\"bound\")), F.constraint && l.push(\" extends \", g(\"constraint\")), F.default && l.push(\" = \", g(\"default\")), l);\n        }\n\n        n.exports = {\n          printTypeParameter: P,\n          printTypeParameters: I,\n          getTypeParametersGroupId: B\n        };\n      }\n\n    }),\n        Qt = Z({\n      \"src/language-js/print/property.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et10 = et(),\n            t = _et10.printComments,\n            _Ue18 = Ue(),\n            s = _Ue18.printString,\n            a = _Ue18.printNumber,\n            _Ke18 = Ke(),\n            r = _Ke18.isNumericLiteral,\n            u = _Ke18.isSimpleNumber,\n            i = _Ke18.isStringLiteral,\n            o = _Ke18.isStringPropSafeToUnquote,\n            c = _Ke18.rawText,\n            _Yt3 = Yt(),\n            v = _Yt3.printAssignment,\n            m = new WeakMap();\n\n        function d(f, h, w) {\n          let T = f.getNode();\n          if (T.computed) return [\"[\", w(\"key\"), \"]\"];\n          let A = f.getParentNode(),\n              S = T.key;\n          if (T.type === \"ClassPrivateProperty\" && S.type === \"Identifier\") return [\"#\", w(\"key\")];\n\n          if (h.quoteProps === \"consistent\" && !m.has(A)) {\n            let B = (A.properties || A.body || A.members).some(I => !I.computed && I.key && i(I.key) && !o(I, h));\n            m.set(A, B);\n          }\n\n          if ((S.type === \"Identifier\" || r(S) && u(a(c(S))) && String(S.value) === a(c(S)) && !(h.parser === \"typescript\" || h.parser === \"babel-ts\")) && (h.parser === \"json\" || h.quoteProps === \"consistent\" && m.get(A))) {\n            let B = s(JSON.stringify(S.type === \"Identifier\" ? S.name : S.value.toString()), h);\n            return f.call(I => t(I, B, h), \"key\");\n          }\n\n          return o(T, h) && (h.quoteProps === \"as-needed\" || h.quoteProps === \"consistent\" && !m.get(A)) ? f.call(B => t(B, /^\\d/.test(S.value) ? a(S.value) : S.value, h), \"key\") : w(\"key\");\n        }\n\n        function p(f, h, w) {\n          return f.getValue().shorthand ? w(\"value\") : v(f, h, w, d(f, h, w), \":\", \"value\");\n        }\n\n        n.exports = {\n          printProperty: p,\n          printPropertyKey: d\n        };\n      }\n\n    }),\n        Lr = Z({\n      \"src/language-js/print/function.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Xt(),\n            _et11 = et(),\n            s = _et11.printDanglingComments,\n            a = _et11.printCommentsSeparately,\n            r = it(),\n            _Ue19 = Ue(),\n            u = _Ue19.getNextNonSpaceNonCommentCharacterIndex,\n            _Oe24 = Oe(),\n            _Oe24$builders = _Oe24.builders,\n            i = _Oe24$builders.line,\n            o = _Oe24$builders.softline,\n            c = _Oe24$builders.group,\n            v = _Oe24$builders.indent,\n            m = _Oe24$builders.ifBreak,\n            d = _Oe24$builders.hardline,\n            p = _Oe24$builders.join,\n            f = _Oe24$builders.indentIfBreak,\n            _Oe24$utils = _Oe24.utils,\n            h = _Oe24$utils.removeLines,\n            w = _Oe24$utils.willBreak,\n            _zt5 = zt(),\n            T = _zt5.ArgExpansionBailout,\n            _Ke19 = Ke(),\n            A = _Ke19.getFunctionParameters,\n            S = _Ke19.hasLeadingOwnLineComment,\n            B = _Ke19.isFlowAnnotationComment,\n            I = _Ke19.isJsxNode,\n            k = _Ke19.isTemplateOnItsOwnLine,\n            P = _Ke19.shouldPrintComma,\n            C = _Ke19.startsWithNoLookaheadToken,\n            D = _Ke19.isBinaryish,\n            g = _Ke19.isLineComment,\n            F = _Ke19.hasComment,\n            l = _Ke19.getComments,\n            E = _Ke19.CommentCheckFlags,\n            y = _Ke19.isCallLikeExpression,\n            N = _Ke19.isCallExpression,\n            x = _Ke19.getCallArguments,\n            b = _Ke19.hasNakedLeftSide,\n            L = _Ke19.getLeftSide,\n            _st7 = st(),\n            M = _st7.locEnd,\n            _Pr2 = Pr(),\n            j = _Pr2.printFunctionParameters,\n            $ = _Pr2.shouldGroupFunctionParameters,\n            _Qt = Qt(),\n            V = _Qt.printPropertyKey,\n            _ct6 = ct(),\n            q = _ct6.printFunctionTypeParameters;\n\n        function Y(z, U, le, ge) {\n          let Ae = z.getValue(),\n              Ne = !1;\n\n          if ((Ae.type === \"FunctionDeclaration\" || Ae.type === \"FunctionExpression\") && ge && ge.expandLastArg) {\n            let ae = z.getParentNode();\n            N(ae) && x(ae).length > 1 && (Ne = !0);\n          }\n\n          let ke = [];\n          Ae.type === \"TSDeclareFunction\" && Ae.declare && ke.push(\"declare \"), Ae.async && ke.push(\"async \"), Ae.generator ? ke.push(\"function* \") : ke.push(\"function \"), Ae.id && ke.push(U(\"id\"));\n          let ce = j(z, U, le, Ne),\n              pe = X(z, U, le),\n              de = $(Ae, pe);\n          return ke.push(q(z, le, U), c([de ? c(ce) : ce, pe]), Ae.body ? \" \" : \"\", U(\"body\")), le.semi && (Ae.declare || !Ae.body) && ke.push(\";\"), ke;\n        }\n\n        function H(z, U, le) {\n          let ge = z.getNode(),\n              Ae = ge.kind,\n              Ne = ge.value || ge,\n              ke = [];\n          return !Ae || Ae === \"init\" || Ae === \"method\" || Ae === \"constructor\" ? Ne.async && ke.push(\"async \") : (t.ok(Ae === \"get\" || Ae === \"set\"), ke.push(Ae, \" \")), Ne.generator && ke.push(\"*\"), ke.push(V(z, U, le), ge.optional || ge.key.optional ? \"?\" : \"\"), ge === Ne ? ke.push(R(z, U, le)) : Ne.type === \"FunctionExpression\" ? ke.push(z.call(ce => R(ce, U, le), \"value\")) : ke.push(le(\"value\")), ke;\n        }\n\n        function R(z, U, le) {\n          let ge = z.getNode(),\n              Ae = j(z, le, U),\n              Ne = X(z, le, U),\n              ke = $(ge, Ne),\n              ce = [q(z, U, le), c([ke ? c(Ae) : Ae, Ne])];\n          return ge.body ? ce.push(\" \", le(\"body\")) : ce.push(U.semi ? \";\" : \"\"), ce;\n        }\n\n        function Q(z, U, le, ge) {\n          let Ae = z.getValue(),\n              Ne = [];\n          if (Ae.async && Ne.push(\"async \"), W(z, U)) Ne.push(le([\"params\", 0]));else {\n            let ce = ge && (ge.expandLastArg || ge.expandFirstArg),\n                pe = X(z, le, U);\n\n            if (ce) {\n              if (w(pe)) throw new T();\n              pe = c(h(pe));\n            }\n\n            Ne.push(c([j(z, le, U, ce, !0), pe]));\n          }\n          let ke = s(z, U, !0, ce => {\n            let pe = u(U.originalText, ce, M);\n            return pe !== !1 && U.originalText.slice(pe, pe + 2) === \"=>\";\n          });\n          return ke && Ne.push(\" \", ke), Ne;\n        }\n\n        function ee(z, U, le, ge, Ae, Ne) {\n          let ke = z.getName(),\n              ce = z.getParentNode(),\n              pe = y(ce) && ke === \"callee\",\n              de = Boolean(U && U.assignmentLayout),\n              ae = Ne.body.type !== \"BlockStatement\" && Ne.body.type !== \"ObjectExpression\" && Ne.body.type !== \"SequenceExpression\",\n              ve = pe && ae || U && U.assignmentLayout === \"chain-tail-arrow-chain\",\n              K = Symbol(\"arrow-chain\");\n          return Ne.body.type === \"SequenceExpression\" && (Ae = c([\"(\", v([o, Ae]), o, \")\"])), c([c(v([pe || de ? o : \"\", c(p([\" =>\", i], le), {\n            shouldBreak: ge\n          })]), {\n            id: K,\n            shouldBreak: ve\n          }), \" =>\", f(ae ? v([i, Ae]) : [\" \", Ae], {\n            groupId: K\n          }), pe ? m(o, \"\", {\n            groupId: K\n          }) : \"\"]);\n        }\n\n        function te(z, U, le, ge) {\n          let Ae = z.getValue(),\n              Ne = [],\n              ke = [],\n              ce = !1;\n          if (function K() {\n            let he = Q(z, U, le, ge);\n            if (Ne.length === 0) Ne.push(he);else {\n              let _a4 = a(z, U),\n                  ye = _a4.leading,\n                  Ce = _a4.trailing;\n\n              Ne.push([ye, he]), ke.unshift(Ce);\n            }\n            ce = ce || Ae.returnType && A(Ae).length > 0 || Ae.typeParameters || A(Ae).some(ye => ye.type !== \"Identifier\"), Ae.body.type !== \"ArrowFunctionExpression\" || ge && ge.expandLastArg ? ke.unshift(le(\"body\", ge)) : (Ae = Ae.body, z.call(K, \"body\"));\n          }(), Ne.length > 1) return ee(z, ge, Ne, ce, ke, Ae);\n          let pe = Ne;\n          if (pe.push(\" =>\"), !S(U.originalText, Ae.body) && (Ae.body.type === \"ArrayExpression\" || Ae.body.type === \"ObjectExpression\" || Ae.body.type === \"BlockStatement\" || I(Ae.body) || k(Ae.body, U.originalText) || Ae.body.type === \"ArrowFunctionExpression\" || Ae.body.type === \"DoExpression\")) return c([...pe, \" \", ke]);\n          if (Ae.body.type === \"SequenceExpression\") return c([...pe, c([\" (\", v([o, ke]), o, \")\"])]);\n          let de = (ge && ge.expandLastArg || z.getParentNode().type === \"JSXExpressionContainer\") && !F(Ae),\n              ae = ge && ge.expandLastArg && P(U, \"all\"),\n              ve = Ae.body.type === \"ConditionalExpression\" && !C(Ae.body, !1);\n          return c([...pe, c([v([i, ve ? m(\"\", \"(\") : \"\", ke, ve ? m(\"\", \")\") : \"\"]), de ? [m(ae ? \",\" : \"\"), o] : \"\"])]);\n        }\n\n        function oe(z) {\n          let U = A(z);\n          return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === \"Identifier\" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;\n        }\n\n        function W(z, U) {\n          if (U.arrowParens === \"always\") return !1;\n\n          if (U.arrowParens === \"avoid\") {\n            let le = z.getValue();\n            return oe(le);\n          }\n\n          return !1;\n        }\n\n        function X(z, U, le) {\n          let ge = z.getValue(),\n              Ae = U(\"returnType\");\n          if (ge.returnType && B(le.originalText, ge.returnType)) return [\" /*: \", Ae, \" */\"];\n          let Ne = [Ae];\n          return ge.returnType && ge.returnType.typeAnnotation && Ne.unshift(\": \"), ge.predicate && Ne.push(ge.returnType ? \" \" : \": \", U(\"predicate\")), Ne;\n        }\n\n        function ue(z, U, le) {\n          let ge = z.getValue(),\n              Ae = U.semi ? \";\" : \"\",\n              Ne = [];\n          ge.argument && (G(U, ge.argument) ? Ne.push([\" (\", v([d, le(\"argument\")]), d, \")\"]) : D(ge.argument) || ge.argument.type === \"SequenceExpression\" ? Ne.push(c([m(\" (\", \" \"), v([o, le(\"argument\")]), o, m(\")\")])) : Ne.push(\" \", le(\"argument\")));\n          let ke = l(ge),\n              ce = r(ke),\n              pe = ce && g(ce);\n          return pe && Ne.push(Ae), F(ge, E.Dangling) && Ne.push(\" \", s(z, U, !0)), pe || Ne.push(Ae), Ne;\n        }\n\n        function De(z, U, le) {\n          return [\"return\", ue(z, U, le)];\n        }\n\n        function ie(z, U, le) {\n          return [\"throw\", ue(z, U, le)];\n        }\n\n        function G(z, U) {\n          if (S(z.originalText, U)) return !0;\n\n          if (b(U)) {\n            let le = U,\n                ge;\n\n            for (; ge = L(le);) if (le = ge, S(z.originalText, le)) return !0;\n          }\n\n          return !1;\n        }\n\n        n.exports = {\n          printFunction: Y,\n          printArrowFunction: te,\n          printMethod: H,\n          printReturnStatement: De,\n          printThrowStatement: ie,\n          printMethodInternal: R,\n          shouldPrintParamsWithoutParens: W\n        };\n      }\n\n    }),\n        Un = Z({\n      \"src/language-js/print/decorators.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue20 = Ue(),\n            t = _Ue20.isNonEmptyArray,\n            s = _Ue20.hasNewline,\n            _Oe25 = Oe(),\n            _Oe25$builders = _Oe25.builders,\n            a = _Oe25$builders.line,\n            r = _Oe25$builders.hardline,\n            u = _Oe25$builders.join,\n            i = _Oe25$builders.breakParent,\n            o = _Oe25$builders.group,\n            _st8 = st(),\n            c = _st8.locStart,\n            v = _st8.locEnd,\n            _Ke20 = Ke(),\n            m = _Ke20.getParentExportDeclaration;\n\n        function d(T, A, S) {\n          let B = T.getValue();\n          return o([u(a, T.map(S, \"decorators\")), h(B, A) ? r : a]);\n        }\n\n        function p(T, A, S) {\n          return [u(r, T.map(S, \"declaration\", \"decorators\")), r];\n        }\n\n        function f(T, A, S) {\n          let B = T.getValue(),\n              I = B.decorators;\n          if (!t(I) || w(T.getParentNode())) return;\n          let k = B.type === \"ClassExpression\" || B.type === \"ClassDeclaration\" || h(B, A);\n          return [m(T) ? r : k ? i : \"\", u(a, T.map(S, \"decorators\")), a];\n        }\n\n        function h(T, A) {\n          return T.decorators.some(S => s(A.originalText, v(S)));\n        }\n\n        function w(T) {\n          if (T.type !== \"ExportDefaultDeclaration\" && T.type !== \"ExportNamedDeclaration\" && T.type !== \"DeclareExportDeclaration\") return !1;\n          let A = T.declaration && T.declaration.decorators;\n          return t(A) && c(T, {\n            ignoreDecorators: !0\n          }) > c(A[0]);\n        }\n\n        n.exports = {\n          printDecorators: f,\n          printClassMemberDecorators: d,\n          printDecoratorsBeforeExport: p,\n          hasDecoratorsBeforeExport: w\n        };\n      }\n\n    }),\n        Zt = Z({\n      \"src/language-js/print/class.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue21 = Ue(),\n            t = _Ue21.isNonEmptyArray,\n            s = _Ue21.createGroupIdMapper,\n            _et12 = et(),\n            a = _et12.printComments,\n            r = _et12.printDanglingComments,\n            _Oe26 = Oe(),\n            _Oe26$builders = _Oe26.builders,\n            u = _Oe26$builders.join,\n            i = _Oe26$builders.line,\n            o = _Oe26$builders.hardline,\n            c = _Oe26$builders.softline,\n            v = _Oe26$builders.group,\n            m = _Oe26$builders.indent,\n            d = _Oe26$builders.ifBreak,\n            _Ke21 = Ke(),\n            p = _Ke21.hasComment,\n            f = _Ke21.CommentCheckFlags,\n            _Ir = Ir(),\n            h = _Ir.getTypeParametersGroupId,\n            _Lr = Lr(),\n            w = _Lr.printMethod,\n            _ct7 = ct(),\n            T = _ct7.printOptionalToken,\n            A = _ct7.printTypeAnnotation,\n            S = _ct7.printDefiniteToken,\n            _Qt2 = Qt(),\n            B = _Qt2.printPropertyKey,\n            _Yt4 = Yt(),\n            I = _Yt4.printAssignment,\n            _Un = Un(),\n            k = _Un.printClassMemberDecorators;\n\n        function P(x, b, L) {\n          let M = x.getValue(),\n              j = [];\n          M.declare && j.push(\"declare \"), M.abstract && j.push(\"abstract \"), j.push(\"class\");\n          let $ = M.id && p(M.id, f.Trailing) || M.typeParameters && p(M.typeParameters, f.Trailing) || M.superClass && p(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements),\n              V = [],\n              q = [];\n\n          if (M.id && V.push(\" \", L(\"id\")), V.push(L(\"typeParameters\")), M.superClass) {\n            let Y = [E(x, b, L), L(\"superTypeParameters\")],\n                H = x.call(R => [\"extends \", a(R, Y, b)], \"superClass\");\n            $ ? q.push(i, v(H)) : q.push(\" \", H);\n          } else q.push(l(x, b, L, \"extends\"));\n\n          if (q.push(l(x, b, L, \"mixins\"), l(x, b, L, \"implements\")), $) {\n            let Y;\n            F(M) ? Y = [...V, m(q)] : Y = m([...V, q]), j.push(v(Y, {\n              id: C(M)\n            }));\n          } else j.push(...V, ...q);\n\n          return j.push(\" \", L(\"body\")), j;\n        }\n\n        var C = s(\"heritageGroup\");\n\n        function D(x) {\n          return d(o, \"\", {\n            groupId: C(x)\n          });\n        }\n\n        function g(x) {\n          return [\"superClass\", \"extends\", \"mixins\", \"implements\"].filter(b => Boolean(x[b])).length > 1;\n        }\n\n        function F(x) {\n          return x.typeParameters && !p(x.typeParameters, f.Trailing | f.Line) && !g(x);\n        }\n\n        function l(x, b, L, M) {\n          let j = x.getValue();\n          if (!t(j[M])) return \"\";\n          let $ = r(x, b, !0, V => {\n            let q = V.marker;\n            return q === M;\n          });\n          return [F(j) ? d(\" \", i, {\n            groupId: h(j.typeParameters)\n          }) : i, $, $ && o, M, v(m([i, u([\",\", i], x.map(L, M))]))];\n        }\n\n        function E(x, b, L) {\n          let M = L(\"superClass\");\n          return x.getParentNode().type === \"AssignmentExpression\" ? v(d([\"(\", m([c, M]), c, \")\"], M)) : M;\n        }\n\n        function y(x, b, L) {\n          let M = x.getValue(),\n              j = [];\n          return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + \" \"), M.readonly && j.push(\"readonly \"), M.declare && j.push(\"declare \"), M.static && j.push(\"static \"), (M.type === \"TSAbstractMethodDefinition\" || M.abstract) && j.push(\"abstract \"), M.override && j.push(\"override \"), j.push(w(x, b, L)), j;\n        }\n\n        function N(x, b, L) {\n          let M = x.getValue(),\n              j = [],\n              $ = b.semi ? \";\" : \"\";\n          return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + \" \"), M.declare && j.push(\"declare \"), M.static && j.push(\"static \"), (M.type === \"TSAbstractPropertyDefinition\" || M.abstract) && j.push(\"abstract \"), M.override && j.push(\"override \"), M.readonly && j.push(\"readonly \"), M.variance && j.push(L(\"variance\")), M.type === \"ClassAccessorProperty\" && j.push(\"accessor \"), j.push(B(x, b, L), T(x), S(x), A(x, b, L)), [I(x, b, L, j, \" =\", \"value\"), $];\n        }\n\n        n.exports = {\n          printClass: P,\n          printClassMethod: y,\n          printClassProperty: N,\n          printHardlineAfterHeritage: D\n        };\n      }\n\n    }),\n        lo = Z({\n      \"src/language-js/print/interface.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue22 = Ue(),\n            t = _Ue22.isNonEmptyArray,\n            _Oe27 = Oe(),\n            _Oe27$builders = _Oe27.builders,\n            s = _Oe27$builders.join,\n            a = _Oe27$builders.line,\n            r = _Oe27$builders.group,\n            u = _Oe27$builders.indent,\n            i = _Oe27$builders.ifBreak,\n            _Ke22 = Ke(),\n            o = _Ke22.hasComment,\n            c = _Ke22.identity,\n            v = _Ke22.CommentCheckFlags,\n            _Ir2 = Ir(),\n            m = _Ir2.getTypeParametersGroupId,\n            _ct8 = ct(),\n            d = _ct8.printTypeScriptModifiers;\n\n        function p(f, h, w) {\n          let T = f.getValue(),\n              A = [];\n          T.declare && A.push(\"declare \"), T.type === \"TSInterfaceDeclaration\" && A.push(T.abstract ? \"abstract \" : \"\", d(f, h, w)), A.push(\"interface\");\n          let S = [],\n              B = [];\n          T.type !== \"InterfaceTypeAnnotation\" && S.push(\" \", w(\"id\"), w(\"typeParameters\"));\n          let I = T.typeParameters && !o(T.typeParameters, v.Trailing | v.Line);\n          return t(T.extends) && B.push(I ? i(\" \", a, {\n            groupId: m(T.typeParameters)\n          }) : a, \"extends \", (T.extends.length === 1 ? c : u)(s([\",\", a], f.map(w, \"extends\")))), T.id && o(T.id, v.Trailing) || t(T.extends) ? I ? A.push(r([...S, u(B)])) : A.push(r(u([...S, ...B]))) : A.push(...S, ...B), A.push(\" \", w(\"body\")), r(A);\n        }\n\n        n.exports = {\n          printInterface: p\n        };\n      }\n\n    }),\n        co = Z({\n      \"src/language-js/print/module.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue23 = Ue(),\n            t = _Ue23.isNonEmptyArray,\n            _Oe28 = Oe(),\n            _Oe28$builders = _Oe28.builders,\n            s = _Oe28$builders.softline,\n            a = _Oe28$builders.group,\n            r = _Oe28$builders.indent,\n            u = _Oe28$builders.join,\n            i = _Oe28$builders.line,\n            o = _Oe28$builders.ifBreak,\n            c = _Oe28$builders.hardline,\n            _et13 = et(),\n            v = _et13.printDanglingComments,\n            _Ke23 = Ke(),\n            m = _Ke23.hasComment,\n            d = _Ke23.CommentCheckFlags,\n            p = _Ke23.shouldPrintComma,\n            f = _Ke23.needsHardlineAfterDanglingComment,\n            h = _Ke23.isStringLiteral,\n            w = _Ke23.rawText,\n            _st9 = st(),\n            T = _st9.locStart,\n            A = _st9.hasSameLoc,\n            _Un2 = Un(),\n            S = _Un2.hasDecoratorsBeforeExport,\n            B = _Un2.printDecoratorsBeforeExport;\n\n        function I(N, x, b) {\n          let L = N.getValue(),\n              M = x.semi ? \";\" : \"\",\n              j = [],\n              $ = L.importKind;\n          return j.push(\"import\"), $ && $ !== \"value\" && j.push(\" \", $), j.push(g(N, x, b), D(N, x, b), l(N, x, b), M), j;\n        }\n\n        function k(N, x, b) {\n          let L = N.getValue(),\n              M = [];\n          S(L) && M.push(B(N, x, b));\n          let j = L.type,\n              $ = L.exportKind,\n              V = L.declaration;\n          return M.push(\"export\"), (L.default || j === \"ExportDefaultDeclaration\") && M.push(\" default\"), m(L, d.Dangling) && (M.push(\" \", v(N, x, !0)), f(L) && M.push(c)), V ? M.push(\" \", b(\"declaration\")) : M.push($ === \"type\" ? \" type\" : \"\", g(N, x, b), D(N, x, b), l(N, x, b)), C(L, x) && M.push(\";\"), M;\n        }\n\n        function P(N, x, b) {\n          let L = N.getValue(),\n              M = x.semi ? \";\" : \"\",\n              j = [],\n              $ = L.exportKind,\n              V = L.exported;\n          return j.push(\"export\"), $ === \"type\" && j.push(\" type\"), j.push(\" *\"), V && j.push(\" as \", b(\"exported\")), j.push(D(N, x, b), l(N, x, b), M), j;\n        }\n\n        function C(N, x) {\n          if (!x.semi) return !1;\n          let b = N.type,\n              L = N.declaration,\n              M = N.default || b === \"ExportDefaultDeclaration\";\n          if (!L) return !0;\n          let j = L.type;\n          return !!(M && j !== \"ClassDeclaration\" && j !== \"FunctionDeclaration\" && j !== \"TSInterfaceDeclaration\" && j !== \"DeclareClass\" && j !== \"DeclareFunction\" && j !== \"TSDeclareFunction\" && j !== \"EnumDeclaration\");\n        }\n\n        function D(N, x, b) {\n          let L = N.getValue();\n          if (!L.source) return \"\";\n          let M = [];\n          return F(L, x) || M.push(\" from\"), M.push(\" \", b(\"source\")), M;\n        }\n\n        function g(N, x, b) {\n          let L = N.getValue();\n          if (F(L, x)) return \"\";\n          let M = [\" \"];\n\n          if (t(L.specifiers)) {\n            let j = [],\n                $ = [];\n            N.each(() => {\n              let V = N.getValue().type;\n              if (V === \"ExportNamespaceSpecifier\" || V === \"ExportDefaultSpecifier\" || V === \"ImportNamespaceSpecifier\" || V === \"ImportDefaultSpecifier\") j.push(b());else if (V === \"ExportSpecifier\" || V === \"ImportSpecifier\") $.push(b());else throw new Error(\"Unknown specifier type \".concat(JSON.stringify(V)));\n            }, \"specifiers\"), M.push(u(\", \", j)), $.length > 0 && (j.length > 0 && M.push(\", \"), $.length > 1 || j.length > 0 || L.specifiers.some(q => m(q)) ? M.push(a([\"{\", r([x.bracketSpacing ? i : s, u([\",\", i], $)]), o(p(x) ? \",\" : \"\"), x.bracketSpacing ? i : s, \"}\"])) : M.push([\"{\", x.bracketSpacing ? \" \" : \"\", ...$, x.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else M.push(\"{}\");\n\n          return M;\n        }\n\n        function F(N, x) {\n          let b = N.type,\n              L = N.importKind,\n              M = N.source,\n              j = N.specifiers;\n          return b !== \"ImportDeclaration\" || t(j) || L === \"type\" ? !1 : !/{\\s*}/.test(x.originalText.slice(T(N), T(M)));\n        }\n\n        function l(N, x, b) {\n          let L = N.getNode();\n          return t(L.assertions) ? [\" assert {\", x.bracketSpacing ? \" \" : \"\", u(\", \", N.map(b, \"assertions\")), x.bracketSpacing ? \" \" : \"\", \"}\"] : \"\";\n        }\n\n        function E(N, x, b) {\n          let L = N.getNode(),\n              M = L.type,\n              j = [],\n              $ = M === \"ImportSpecifier\" ? L.importKind : L.exportKind;\n          $ && $ !== \"value\" && j.push($, \" \");\n          let V = M.startsWith(\"Import\"),\n              q = V ? \"imported\" : \"local\",\n              Y = V ? \"local\" : \"exported\",\n              H = L[q],\n              R = L[Y],\n              Q = \"\",\n              ee = \"\";\n          return M === \"ExportNamespaceSpecifier\" || M === \"ImportNamespaceSpecifier\" ? Q = \"*\" : H && (Q = b(q)), R && !y(L) && (ee = b(Y)), j.push(Q, Q && ee ? \" as \" : \"\", ee), j;\n        }\n\n        function y(N) {\n          if (N.type !== \"ImportSpecifier\" && N.type !== \"ExportSpecifier\") return !1;\n          let x = N.local,\n              b = N[N.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"];\n          if (x.type !== b.type || !A(x, b)) return !1;\n          if (h(x)) return x.value === b.value && w(x) === w(b);\n\n          switch (x.type) {\n            case \"Identifier\":\n              return x.name === b.name;\n\n            default:\n              return !1;\n          }\n        }\n\n        n.exports = {\n          printImportDeclaration: I,\n          printExportDeclaration: k,\n          printExportAllDeclaration: P,\n          printModuleSpecifier: E\n        };\n      }\n\n    }),\n        zn = Z({\n      \"src/language-js/print/object.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et14 = et(),\n            t = _et14.printDanglingComments,\n            _Oe29 = Oe(),\n            _Oe29$builders = _Oe29.builders,\n            s = _Oe29$builders.line,\n            a = _Oe29$builders.softline,\n            r = _Oe29$builders.group,\n            u = _Oe29$builders.indent,\n            i = _Oe29$builders.ifBreak,\n            o = _Oe29$builders.hardline,\n            _Ue24 = Ue(),\n            c = _Ue24.getLast,\n            v = _Ue24.hasNewlineInRange,\n            m = _Ue24.hasNewline,\n            d = _Ue24.isNonEmptyArray,\n            _Ke24 = Ke(),\n            p = _Ke24.shouldPrintComma,\n            f = _Ke24.hasComment,\n            h = _Ke24.getComments,\n            w = _Ke24.CommentCheckFlags,\n            T = _Ke24.isNextLineEmpty,\n            _st10 = st(),\n            A = _st10.locStart,\n            S = _st10.locEnd,\n            _ct9 = ct(),\n            B = _ct9.printOptionalToken,\n            I = _ct9.printTypeAnnotation,\n            _Pr3 = Pr(),\n            k = _Pr3.shouldHugFunctionParameters,\n            _kr2 = kr(),\n            P = _kr2.shouldHugType,\n            _Zt = Zt(),\n            C = _Zt.printHardlineAfterHeritage;\n\n        function D(g, F, l) {\n          let E = F.semi ? \";\" : \"\",\n              y = g.getValue(),\n              N;\n          y.type === \"TSTypeLiteral\" ? N = \"members\" : y.type === \"TSInterfaceBody\" ? N = \"body\" : N = \"properties\";\n          let x = y.type === \"ObjectTypeAnnotation\",\n              b = [N];\n          x && b.push(\"indexers\", \"callProperties\", \"internalSlots\");\n          let L = b.map(W => y[W][0]).sort((W, X) => A(W) - A(X))[0],\n              M = g.getParentNode(0),\n              j = x && M && (M.type === \"InterfaceDeclaration\" || M.type === \"DeclareInterface\" || M.type === \"DeclareClass\") && g.getName() === \"body\",\n              $ = y.type === \"TSInterfaceBody\" || j || y.type === \"ObjectPattern\" && M.type !== \"FunctionDeclaration\" && M.type !== \"FunctionExpression\" && M.type !== \"ArrowFunctionExpression\" && M.type !== \"ObjectMethod\" && M.type !== \"ClassMethod\" && M.type !== \"ClassPrivateMethod\" && M.type !== \"AssignmentPattern\" && M.type !== \"CatchClause\" && y.properties.some(W => W.value && (W.value.type === \"ObjectPattern\" || W.value.type === \"ArrayPattern\")) || y.type !== \"ObjectPattern\" && L && v(F.originalText, A(y), A(L)),\n              V = j ? \";\" : y.type === \"TSInterfaceBody\" || y.type === \"TSTypeLiteral\" ? i(E, \";\") : \",\",\n              q = y.type === \"RecordExpression\" ? \"#{\" : y.exact ? \"{|\" : \"{\",\n              Y = y.exact ? \"|}\" : \"}\",\n              H = [];\n\n          for (let W of b) g.each(X => {\n            let ue = X.getValue();\n            H.push({\n              node: ue,\n              printed: l(),\n              loc: A(ue)\n            });\n          }, W);\n\n          b.length > 1 && H.sort((W, X) => W.loc - X.loc);\n          let R = [],\n              Q = H.map(W => {\n            let X = [...R, r(W.printed)];\n            return R = [V, s], (W.node.type === \"TSPropertySignature\" || W.node.type === \"TSMethodSignature\" || W.node.type === \"TSConstructSignatureDeclaration\") && f(W.node, w.PrettierIgnore) && R.shift(), T(W.node, F) && R.push(o), X;\n          });\n\n          if (y.inexact) {\n            let W;\n\n            if (f(y, w.Dangling)) {\n              let X = f(y, w.Line);\n              W = [t(g, F, !0), X || m(F.originalText, S(c(h(y)))) ? o : s, \"...\"];\n            } else W = [\"...\"];\n\n            Q.push([...R, ...W]);\n          }\n\n          let ee = c(y[N]),\n              te = !(y.inexact || ee && ee.type === \"RestElement\" || ee && (ee.type === \"TSPropertySignature\" || ee.type === \"TSCallSignatureDeclaration\" || ee.type === \"TSMethodSignature\" || ee.type === \"TSConstructSignatureDeclaration\") && f(ee, w.PrettierIgnore)),\n              oe;\n\n          if (Q.length === 0) {\n            if (!f(y, w.Dangling)) return [q, Y, I(g, F, l)];\n            oe = r([q, t(g, F), a, Y, B(g), I(g, F, l)]);\n          } else oe = [j && d(y.properties) ? C(M) : \"\", q, u([F.bracketSpacing ? s : a, ...Q]), i(te && (V !== \",\" || p(F)) ? V : \"\"), F.bracketSpacing ? s : a, Y, B(g), I(g, F, l)];\n\n          return g.match(W => W.type === \"ObjectPattern\" && !W.decorators, (W, X, ue) => k(W) && (X === \"params\" || X === \"parameters\" || X === \"this\" || X === \"rest\") && ue === 0) || g.match(P, (W, X) => X === \"typeAnnotation\", (W, X) => X === \"typeAnnotation\", (W, X, ue) => k(W) && (X === \"params\" || X === \"parameters\" || X === \"this\" || X === \"rest\") && ue === 0) || !$ && g.match(W => W.type === \"ObjectPattern\", W => W.type === \"AssignmentExpression\" || W.type === \"VariableDeclarator\") ? oe : r(oe, {\n            shouldBreak: $\n          });\n        }\n\n        n.exports = {\n          printObject: D\n        };\n      }\n\n    }),\n        Um = Z({\n      \"src/language-js/print/flow.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Xt(),\n            _et15 = et(),\n            s = _et15.printDanglingComments,\n            _Ue25 = Ue(),\n            a = _Ue25.printString,\n            r = _Ue25.printNumber,\n            _Oe30 = Oe(),\n            _Oe30$builders = _Oe30.builders,\n            u = _Oe30$builders.hardline,\n            i = _Oe30$builders.softline,\n            o = _Oe30$builders.group,\n            c = _Oe30$builders.indent,\n            _Ke25 = Ke(),\n            v = _Ke25.getParentExportDeclaration,\n            m = _Ke25.isFunctionNotation,\n            d = _Ke25.isGetterOrSetter,\n            p = _Ke25.rawText,\n            f = _Ke25.shouldPrintComma,\n            _st11 = st(),\n            h = _st11.locStart,\n            w = _st11.locEnd,\n            _Zt2 = Zt(),\n            T = _Zt2.printClass,\n            _kr3 = kr(),\n            A = _kr3.printOpaqueType,\n            S = _kr3.printTypeAlias,\n            B = _kr3.printIntersectionType,\n            I = _kr3.printUnionType,\n            k = _kr3.printFunctionType,\n            P = _kr3.printTupleType,\n            C = _kr3.printIndexedAccessType,\n            _lo = lo(),\n            D = _lo.printInterface,\n            _Ir3 = Ir(),\n            g = _Ir3.printTypeParameter,\n            F = _Ir3.printTypeParameters,\n            _co = co(),\n            l = _co.printExportDeclaration,\n            E = _co.printExportAllDeclaration,\n            _Kt3 = Kt(),\n            y = _Kt3.printArrayItems,\n            _zn = zn(),\n            N = _zn.printObject,\n            _Qt3 = Qt(),\n            x = _Qt3.printPropertyKey,\n            _ct10 = ct(),\n            b = _ct10.printOptionalToken,\n            L = _ct10.printTypeAnnotation,\n            M = _ct10.printRestSpread;\n\n        function j(V, q, Y) {\n          let H = V.getValue(),\n              R = q.semi ? \";\" : \"\",\n              Q = [];\n\n          switch (H.type) {\n            case \"DeclareClass\":\n              return $(V, T(V, q, Y));\n\n            case \"DeclareFunction\":\n              return $(V, [\"function \", Y(\"id\"), H.predicate ? \" \" : \"\", Y(\"predicate\"), R]);\n\n            case \"DeclareModule\":\n              return $(V, [\"module \", Y(\"id\"), \" \", Y(\"body\")]);\n\n            case \"DeclareModuleExports\":\n              return $(V, [\"module.exports\", \": \", Y(\"typeAnnotation\"), R]);\n\n            case \"DeclareVariable\":\n              return $(V, [\"var \", Y(\"id\"), R]);\n\n            case \"DeclareOpaqueType\":\n              return $(V, A(V, q, Y));\n\n            case \"DeclareInterface\":\n              return $(V, D(V, q, Y));\n\n            case \"DeclareTypeAlias\":\n              return $(V, S(V, q, Y));\n\n            case \"DeclareExportDeclaration\":\n              return $(V, l(V, q, Y));\n\n            case \"DeclareExportAllDeclaration\":\n              return $(V, E(V, q, Y));\n\n            case \"OpaqueType\":\n              return A(V, q, Y);\n\n            case \"TypeAlias\":\n              return S(V, q, Y);\n\n            case \"IntersectionTypeAnnotation\":\n              return B(V, q, Y);\n\n            case \"UnionTypeAnnotation\":\n              return I(V, q, Y);\n\n            case \"FunctionTypeAnnotation\":\n              return k(V, q, Y);\n\n            case \"TupleTypeAnnotation\":\n              return P(V, q, Y);\n\n            case \"GenericTypeAnnotation\":\n              return [Y(\"id\"), F(V, q, Y, \"typeParameters\")];\n\n            case \"IndexedAccessType\":\n            case \"OptionalIndexedAccessType\":\n              return C(V, q, Y);\n\n            case \"TypeAnnotation\":\n              return Y(\"typeAnnotation\");\n\n            case \"TypeParameter\":\n              return g(V, q, Y);\n\n            case \"TypeofTypeAnnotation\":\n              return [\"typeof \", Y(\"argument\")];\n\n            case \"ExistsTypeAnnotation\":\n              return \"*\";\n\n            case \"EmptyTypeAnnotation\":\n              return \"empty\";\n\n            case \"MixedTypeAnnotation\":\n              return \"mixed\";\n\n            case \"ArrayTypeAnnotation\":\n              return [Y(\"elementType\"), \"[]\"];\n\n            case \"BooleanLiteralTypeAnnotation\":\n              return String(H.value);\n\n            case \"EnumDeclaration\":\n              return [\"enum \", Y(\"id\"), \" \", Y(\"body\")];\n\n            case \"EnumBooleanBody\":\n            case \"EnumNumberBody\":\n            case \"EnumStringBody\":\n            case \"EnumSymbolBody\":\n              {\n                if (H.type === \"EnumSymbolBody\" || H.explicitType) {\n                  let ee = null;\n\n                  switch (H.type) {\n                    case \"EnumBooleanBody\":\n                      ee = \"boolean\";\n                      break;\n\n                    case \"EnumNumberBody\":\n                      ee = \"number\";\n                      break;\n\n                    case \"EnumStringBody\":\n                      ee = \"string\";\n                      break;\n\n                    case \"EnumSymbolBody\":\n                      ee = \"symbol\";\n                      break;\n                  }\n\n                  Q.push(\"of \", ee, \" \");\n                }\n\n                if (H.members.length === 0 && !H.hasUnknownMembers) Q.push(o([\"{\", s(V, q), i, \"}\"]));else {\n                  let ee = H.members.length > 0 ? [u, y(V, q, \"members\", Y), H.hasUnknownMembers || f(q) ? \",\" : \"\"] : [];\n                  Q.push(o([\"{\", c([...ee, ...(H.hasUnknownMembers ? [u, \"...\"] : [])]), s(V, q, !0), u, \"}\"]));\n                }\n                return Q;\n              }\n\n            case \"EnumBooleanMember\":\n            case \"EnumNumberMember\":\n            case \"EnumStringMember\":\n              return [Y(\"id\"), \" = \", typeof H.init == \"object\" ? Y(\"init\") : String(H.init)];\n\n            case \"EnumDefaultedMember\":\n              return Y(\"id\");\n\n            case \"FunctionTypeParam\":\n              {\n                let ee = H.name ? Y(\"name\") : V.getParentNode().this === H ? \"this\" : \"\";\n                return [ee, b(V), ee ? \": \" : \"\", Y(\"typeAnnotation\")];\n              }\n\n            case \"InterfaceDeclaration\":\n            case \"InterfaceTypeAnnotation\":\n              return D(V, q, Y);\n\n            case \"ClassImplements\":\n            case \"InterfaceExtends\":\n              return [Y(\"id\"), Y(\"typeParameters\")];\n\n            case \"NullableTypeAnnotation\":\n              return [\"?\", Y(\"typeAnnotation\")];\n\n            case \"Variance\":\n              {\n                let ee = H.kind;\n                return t.ok(ee === \"plus\" || ee === \"minus\"), ee === \"plus\" ? \"+\" : \"-\";\n              }\n\n            case \"ObjectTypeCallProperty\":\n              return H.static && Q.push(\"static \"), Q.push(Y(\"value\")), Q;\n\n            case \"ObjectTypeIndexer\":\n              return [H.static ? \"static \" : \"\", H.variance ? Y(\"variance\") : \"\", \"[\", Y(\"id\"), H.id ? \": \" : \"\", Y(\"key\"), \"]: \", Y(\"value\")];\n\n            case \"ObjectTypeProperty\":\n              {\n                let ee = \"\";\n                return H.proto ? ee = \"proto \" : H.static && (ee = \"static \"), [ee, d(H) ? H.kind + \" \" : \"\", H.variance ? Y(\"variance\") : \"\", x(V, q, Y), b(V), m(H) ? \"\" : \": \", Y(\"value\")];\n              }\n\n            case \"ObjectTypeAnnotation\":\n              return N(V, q, Y);\n\n            case \"ObjectTypeInternalSlot\":\n              return [H.static ? \"static \" : \"\", \"[[\", Y(\"id\"), \"]]\", b(V), H.method ? \"\" : \": \", Y(\"value\")];\n\n            case \"ObjectTypeSpreadProperty\":\n              return M(V, q, Y);\n\n            case \"QualifiedTypeofIdentifier\":\n            case \"QualifiedTypeIdentifier\":\n              return [Y(\"qualification\"), \".\", Y(\"id\")];\n\n            case \"StringLiteralTypeAnnotation\":\n              return a(p(H), q);\n\n            case \"NumberLiteralTypeAnnotation\":\n              t.strictEqual(typeof H.value, \"number\");\n\n            case \"BigIntLiteralTypeAnnotation\":\n              return H.extra ? r(H.extra.raw) : r(H.raw);\n\n            case \"TypeCastExpression\":\n              return [\"(\", Y(\"expression\"), L(V, q, Y), \")\"];\n\n            case \"TypeParameterDeclaration\":\n            case \"TypeParameterInstantiation\":\n              {\n                let ee = F(V, q, Y, \"params\");\n\n                if (q.parser === \"flow\") {\n                  let te = h(H),\n                      oe = w(H),\n                      W = q.originalText.lastIndexOf(\"/*\", te),\n                      X = q.originalText.indexOf(\"*/\", oe);\n\n                  if (W !== -1 && X !== -1) {\n                    let ue = q.originalText.slice(W + 2, X).trim();\n                    if (ue.startsWith(\"::\") && !ue.includes(\"/*\") && !ue.includes(\"*/\")) return [\"/*:: \", ee, \" */\"];\n                  }\n                }\n\n                return ee;\n              }\n\n            case \"InferredPredicate\":\n              return \"%checks\";\n\n            case \"DeclaredPredicate\":\n              return [\"%checks(\", Y(\"value\"), \")\"];\n\n            case \"AnyTypeAnnotation\":\n              return \"any\";\n\n            case \"BooleanTypeAnnotation\":\n              return \"boolean\";\n\n            case \"BigIntTypeAnnotation\":\n              return \"bigint\";\n\n            case \"NullLiteralTypeAnnotation\":\n              return \"null\";\n\n            case \"NumberTypeAnnotation\":\n              return \"number\";\n\n            case \"SymbolTypeAnnotation\":\n              return \"symbol\";\n\n            case \"StringTypeAnnotation\":\n              return \"string\";\n\n            case \"VoidTypeAnnotation\":\n              return \"void\";\n\n            case \"ThisTypeAnnotation\":\n              return \"this\";\n\n            case \"Node\":\n            case \"Printable\":\n            case \"SourceLocation\":\n            case \"Position\":\n            case \"Statement\":\n            case \"Function\":\n            case \"Pattern\":\n            case \"Expression\":\n            case \"Declaration\":\n            case \"Specifier\":\n            case \"NamedSpecifier\":\n            case \"Comment\":\n            case \"MemberTypeAnnotation\":\n            case \"Type\":\n              throw new Error(\"unprintable type: \" + JSON.stringify(H.type));\n          }\n        }\n\n        function $(V, q) {\n          let Y = v(V);\n          return Y ? (t.strictEqual(Y.type, \"DeclareExportDeclaration\"), q) : [\"declare \", q];\n        }\n\n        n.exports = {\n          printFlow: j\n        };\n      }\n\n    }),\n        zm = Z({\n      \"src/language-js/utils/is-ts-keyword-type.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s) {\n          let a = s.type;\n          return a.startsWith(\"TS\") && a.endsWith(\"Keyword\");\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        po = Z({\n      \"src/language-js/print/ternary.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue26 = Ue(),\n            t = _Ue26.hasNewlineInRange,\n            _Ke26 = Ke(),\n            s = _Ke26.isJsxNode,\n            a = _Ke26.getComments,\n            r = _Ke26.isCallExpression,\n            u = _Ke26.isMemberExpression,\n            _st12 = st(),\n            i = _st12.locStart,\n            o = _st12.locEnd,\n            c = It(),\n            _Oe31 = Oe(),\n            _Oe31$builders = _Oe31.builders,\n            v = _Oe31$builders.line,\n            m = _Oe31$builders.softline,\n            d = _Oe31$builders.group,\n            p = _Oe31$builders.indent,\n            f = _Oe31$builders.align,\n            h = _Oe31$builders.ifBreak,\n            w = _Oe31$builders.dedent,\n            T = _Oe31$builders.breakParent;\n\n        function A(P) {\n          let C = [P];\n\n          for (let D = 0; D < C.length; D++) {\n            let g = C[D];\n\n            for (let F of [\"test\", \"consequent\", \"alternate\"]) {\n              let l = g[F];\n              if (s(l)) return !0;\n              l.type === \"ConditionalExpression\" && C.push(l);\n            }\n          }\n\n          return !1;\n        }\n\n        function S(P, C, D) {\n          let g = P.getValue(),\n              F = g.type === \"ConditionalExpression\",\n              l = F ? \"alternate\" : \"falseType\",\n              E = P.getParentNode(),\n              y = F ? D(\"test\") : [D(\"checkType\"), \" \", \"extends\", \" \", D(\"extendsType\")];\n          return E.type === g.type && E[l] === g ? f(2, y) : y;\n        }\n\n        var B = new Map([[\"AssignmentExpression\", \"right\"], [\"VariableDeclarator\", \"init\"], [\"ReturnStatement\", \"argument\"], [\"ThrowStatement\", \"argument\"], [\"UnaryExpression\", \"argument\"], [\"YieldExpression\", \"argument\"]]);\n\n        function I(P) {\n          let C = P.getValue();\n          if (C.type !== \"ConditionalExpression\") return !1;\n          let D,\n              g = C;\n\n          for (let F = 0; !D; F++) {\n            let l = P.getParentNode(F);\n\n            if (r(l) && l.callee === g || u(l) && l.object === g || l.type === \"TSNonNullExpression\" && l.expression === g) {\n              g = l;\n              continue;\n            }\n\n            l.type === \"NewExpression\" && l.callee === g || l.type === \"TSAsExpression\" && l.expression === g ? (D = P.getParentNode(F + 1), g = l) : D = l;\n          }\n\n          return g === C ? !1 : D[B.get(D.type)] === g;\n        }\n\n        function k(P, C, D) {\n          let g = P.getValue(),\n              F = g.type === \"ConditionalExpression\",\n              l = F ? \"consequent\" : \"trueType\",\n              E = F ? \"alternate\" : \"falseType\",\n              y = F ? [\"test\"] : [\"checkType\", \"extendsType\"],\n              N = g[l],\n              x = g[E],\n              b = [],\n              L = !1,\n              M = P.getParentNode(),\n              j = M.type === g.type && y.some(ue => M[ue] === g),\n              $ = M.type === g.type && !j,\n              V,\n              q,\n              Y = 0;\n\n          do q = V || g, V = P.getParentNode(Y), Y++; while (V && V.type === g.type && y.every(ue => V[ue] !== q));\n\n          let H = V || M,\n              R = q;\n\n          if (F && (s(g[y[0]]) || s(N) || s(x) || A(R))) {\n            L = !0, $ = !0;\n\n            let ue = ie => [h(\"(\"), p([m, ie]), m, h(\")\")],\n                De = ie => ie.type === \"NullLiteral\" || ie.type === \"Literal\" && ie.value === null || ie.type === \"Identifier\" && ie.name === \"undefined\";\n\n            b.push(\" ? \", De(N) ? D(l) : ue(D(l)), \" : \", x.type === g.type || De(x) ? D(E) : ue(D(E)));\n          } else {\n            let ue = [v, \"? \", N.type === g.type ? h(\"\", \"(\") : \"\", f(2, D(l)), N.type === g.type ? h(\"\", \")\") : \"\", v, \": \", x.type === g.type ? D(E) : f(2, D(E))];\n            b.push(M.type !== g.type || M[E] === g || j ? ue : C.useTabs ? w(p(ue)) : f(Math.max(0, C.tabWidth - 2), ue));\n          }\n\n          let ee = [...y.map(ue => a(g[ue])), a(N), a(x)].flat().some(ue => c(ue) && t(C.originalText, i(ue), o(ue))),\n              te = ue => M === H ? d(ue, {\n            shouldBreak: ee\n          }) : ee ? [ue, T] : ue,\n              oe = !L && (u(M) || M.type === \"NGPipeExpression\" && M.left === g) && !M.computed,\n              W = I(P),\n              X = te([S(P, C, D), $ ? b : p(b), F && oe && !W ? m : \"\"]);\n\n          return j || W ? d([p([m, X]), m]) : X;\n        }\n\n        n.exports = {\n          printTernary: k\n        };\n      }\n\n    }),\n        fo = Z({\n      \"src/language-js/print/statement.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe32 = Oe(),\n            t = _Oe32.builders.hardline,\n            s = jt(),\n            _Ke27 = Ke(),\n            a = _Ke27.getLeftSidePathName,\n            r = _Ke27.hasNakedLeftSide,\n            u = _Ke27.isJsxNode,\n            i = _Ke27.isTheOnlyJsxElementInMarkdown,\n            o = _Ke27.hasComment,\n            c = _Ke27.CommentCheckFlags,\n            v = _Ke27.isNextLineEmpty,\n            _Lr2 = Lr(),\n            m = _Lr2.shouldPrintParamsWithoutParens;\n\n        function d(B, I, k, P) {\n          let C = B.getValue(),\n              D = [],\n              g = C.type === \"ClassBody\",\n              F = p(C[P]);\n          return B.each((l, E, y) => {\n            let N = l.getValue();\n            if (N.type === \"EmptyStatement\") return;\n            let x = k();\n            !I.semi && !g && !i(I, l) && f(l, I) ? o(N, c.Leading) ? D.push(k([], {\n              needsSemi: !0\n            })) : D.push(\";\", x) : D.push(x), !I.semi && g && A(N) && S(N, y[E + 1]) && D.push(\";\"), N !== F && (D.push(t), v(N, I) && D.push(t));\n          }, P), D;\n        }\n\n        function p(B) {\n          for (let I = B.length - 1; I >= 0; I--) {\n            let k = B[I];\n            if (k.type !== \"EmptyStatement\") return k;\n          }\n        }\n\n        function f(B, I) {\n          return B.getNode().type !== \"ExpressionStatement\" ? !1 : B.call(P => h(P, I), \"expression\");\n        }\n\n        function h(B, I) {\n          let k = B.getValue();\n\n          switch (k.type) {\n            case \"ParenthesizedExpression\":\n            case \"TypeCastExpression\":\n            case \"ArrayExpression\":\n            case \"ArrayPattern\":\n            case \"TemplateLiteral\":\n            case \"TemplateElement\":\n            case \"RegExpLiteral\":\n              return !0;\n\n            case \"ArrowFunctionExpression\":\n              {\n                if (!m(B, I)) return !0;\n                break;\n              }\n\n            case \"UnaryExpression\":\n              {\n                let P = k.prefix,\n                    C = k.operator;\n                if (P && (C === \"+\" || C === \"-\")) return !0;\n                break;\n              }\n\n            case \"BindExpression\":\n              {\n                if (!k.object) return !0;\n                break;\n              }\n\n            case \"Literal\":\n              {\n                if (k.regex) return !0;\n                break;\n              }\n\n            default:\n              if (u(k)) return !0;\n          }\n\n          return s(B, I) ? !0 : r(k) ? B.call(P => h(P, I), ...a(B, k)) : !1;\n        }\n\n        function w(B, I, k) {\n          return d(B, I, k, \"body\");\n        }\n\n        function T(B, I, k) {\n          return d(B, I, k, \"consequent\");\n        }\n\n        var A = B => {\n          let I = B.type;\n          return I === \"ClassProperty\" || I === \"PropertyDefinition\" || I === \"ClassPrivateProperty\" || I === \"ClassAccessorProperty\";\n        };\n\n        function S(B, I) {\n          let k = B.key && B.key.name;\n          if ((k === \"static\" || k === \"get\" || k === \"set\") && !B.value && !B.typeAnnotation) return !0;\n          if (!I || I.static || I.accessibility) return !1;\n\n          if (!I.computed) {\n            let P = I.key && I.key.name;\n            if (P === \"in\" || P === \"instanceof\") return !0;\n          }\n\n          if (A(I) && I.variance && !I.static && !I.declare) return !0;\n\n          switch (I.type) {\n            case \"ClassProperty\":\n            case \"PropertyDefinition\":\n            case \"TSAbstractPropertyDefinition\":\n              return I.computed;\n\n            case \"MethodDefinition\":\n            case \"TSAbstractMethodDefinition\":\n            case \"ClassMethod\":\n            case \"ClassPrivateMethod\":\n              {\n                if ((I.value ? I.value.async : I.async) || I.kind === \"get\" || I.kind === \"set\") return !1;\n                let C = I.value ? I.value.generator : I.generator;\n                return !!(I.computed || C);\n              }\n\n            case \"TSIndexSignature\":\n              return !0;\n          }\n\n          return !1;\n        }\n\n        n.exports = {\n          printBody: w,\n          printSwitchCaseConsequent: T\n        };\n      }\n\n    }),\n        Do = Z({\n      \"src/language-js/print/block.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et16 = et(),\n            t = _et16.printDanglingComments,\n            _Ue27 = Ue(),\n            s = _Ue27.isNonEmptyArray,\n            _Oe33 = Oe(),\n            _Oe33$builders = _Oe33.builders,\n            a = _Oe33$builders.hardline,\n            r = _Oe33$builders.indent,\n            _Ke28 = Ke(),\n            u = _Ke28.hasComment,\n            i = _Ke28.CommentCheckFlags,\n            o = _Ke28.isNextLineEmpty,\n            _Zt3 = Zt(),\n            c = _Zt3.printHardlineAfterHeritage,\n            _fo = fo(),\n            v = _fo.printBody;\n\n        function m(p, f, h) {\n          let w = p.getValue(),\n              T = [];\n\n          if (w.type === \"StaticBlock\" && T.push(\"static \"), w.type === \"ClassBody\" && s(w.body)) {\n            let S = p.getParentNode();\n            T.push(c(S));\n          }\n\n          T.push(\"{\");\n          let A = d(p, f, h);\n          if (A) T.push(r([a, A]), a);else {\n            let S = p.getParentNode(),\n                B = p.getParentNode(1);\n            S.type === \"ArrowFunctionExpression\" || S.type === \"FunctionExpression\" || S.type === \"FunctionDeclaration\" || S.type === \"ObjectMethod\" || S.type === \"ClassMethod\" || S.type === \"ClassPrivateMethod\" || S.type === \"ForStatement\" || S.type === \"WhileStatement\" || S.type === \"DoWhileStatement\" || S.type === \"DoExpression\" || S.type === \"CatchClause\" && !B.finalizer || S.type === \"TSModuleDeclaration\" || S.type === \"TSDeclareFunction\" || w.type === \"StaticBlock\" || w.type === \"ClassBody\" || T.push(a);\n          }\n          return T.push(\"}\"), T;\n        }\n\n        function d(p, f, h) {\n          let w = p.getValue(),\n              T = s(w.directives),\n              A = w.body.some(I => I.type !== \"EmptyStatement\"),\n              S = u(w, i.Dangling);\n          if (!T && !A && !S) return \"\";\n          let B = [];\n\n          if (T && p.each((I, k, P) => {\n            B.push(h()), (k < P.length - 1 || A || S) && (B.push(a), o(I.getValue(), f) && B.push(a));\n          }, \"directives\"), A && B.push(v(p, f, h)), S && B.push(t(p, f, !0)), w.type === \"Program\") {\n            let I = p.getParentNode();\n            (!I || I.type !== \"ModuleExpression\") && B.push(a);\n          }\n\n          return B;\n        }\n\n        n.exports = {\n          printBlock: m,\n          printBlockBody: d\n        };\n      }\n\n    }),\n        Xm = Z({\n      \"src/language-js/print/typescript.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et17 = et(),\n            t = _et17.printDanglingComments,\n            _Ue28 = Ue(),\n            s = _Ue28.hasNewlineInRange,\n            _Oe34 = Oe(),\n            _Oe34$builders = _Oe34.builders,\n            a = _Oe34$builders.join,\n            r = _Oe34$builders.line,\n            u = _Oe34$builders.hardline,\n            i = _Oe34$builders.softline,\n            o = _Oe34$builders.group,\n            c = _Oe34$builders.indent,\n            v = _Oe34$builders.conditionalGroup,\n            m = _Oe34$builders.ifBreak,\n            _Ke29 = Ke(),\n            d = _Ke29.isLiteral,\n            p = _Ke29.getTypeScriptMappedTypeModifier,\n            f = _Ke29.shouldPrintComma,\n            h = _Ke29.isCallExpression,\n            w = _Ke29.isMemberExpression,\n            T = zm(),\n            _st13 = st(),\n            A = _st13.locStart,\n            S = _st13.locEnd,\n            _ct11 = ct(),\n            B = _ct11.printOptionalToken,\n            I = _ct11.printTypeScriptModifiers,\n            _po = po(),\n            k = _po.printTernary,\n            _Pr4 = Pr(),\n            P = _Pr4.printFunctionParameters,\n            C = _Pr4.shouldGroupFunctionParameters,\n            _Lt5 = Lt(),\n            D = _Lt5.printTemplateLiteral,\n            _Kt4 = Kt(),\n            g = _Kt4.printArrayItems,\n            _zn2 = zn(),\n            F = _zn2.printObject,\n            _Zt4 = Zt(),\n            l = _Zt4.printClassProperty,\n            E = _Zt4.printClassMethod,\n            _Ir4 = Ir(),\n            y = _Ir4.printTypeParameter,\n            N = _Ir4.printTypeParameters,\n            _Qt4 = Qt(),\n            x = _Qt4.printPropertyKey,\n            _Lr3 = Lr(),\n            b = _Lr3.printFunction,\n            L = _Lr3.printMethodInternal,\n            _lo2 = lo(),\n            M = _lo2.printInterface,\n            _Do = Do(),\n            j = _Do.printBlock,\n            _kr4 = kr(),\n            $ = _kr4.printTypeAlias,\n            V = _kr4.printIntersectionType,\n            q = _kr4.printUnionType,\n            Y = _kr4.printFunctionType,\n            H = _kr4.printTupleType,\n            R = _kr4.printIndexedAccessType,\n            Q = _kr4.printJSDocType;\n\n        function ee(te, oe, W) {\n          let X = te.getValue();\n          if (!X.type.startsWith(\"TS\")) return;\n          if (T(X)) return X.type.slice(2, -7).toLowerCase();\n          let ue = oe.semi ? \";\" : \"\",\n              De = [];\n\n          switch (X.type) {\n            case \"TSThisType\":\n              return \"this\";\n\n            case \"TSTypeAssertion\":\n              {\n                let ie = !(X.expression.type === \"ArrayExpression\" || X.expression.type === \"ObjectExpression\"),\n                    G = o([\"<\", c([i, W(\"typeAnnotation\")]), i, \">\"]),\n                    z = [m(\"(\"), c([i, W(\"expression\")]), i, m(\")\")];\n                return ie ? v([[G, W(\"expression\")], [G, o(z, {\n                  shouldBreak: !0\n                })], [G, W(\"expression\")]]) : o([G, W(\"expression\")]);\n              }\n\n            case \"TSDeclareFunction\":\n              return b(te, W, oe);\n\n            case \"TSExportAssignment\":\n              return [\"export = \", W(\"expression\"), ue];\n\n            case \"TSModuleBlock\":\n              return j(te, oe, W);\n\n            case \"TSInterfaceBody\":\n            case \"TSTypeLiteral\":\n              return F(te, oe, W);\n\n            case \"TSTypeAliasDeclaration\":\n              return $(te, oe, W);\n\n            case \"TSQualifiedName\":\n              return a(\".\", [W(\"left\"), W(\"right\")]);\n\n            case \"TSAbstractMethodDefinition\":\n            case \"TSDeclareMethod\":\n              return E(te, oe, W);\n\n            case \"TSAbstractPropertyDefinition\":\n              return l(te, oe, W);\n\n            case \"TSInterfaceHeritage\":\n            case \"TSExpressionWithTypeArguments\":\n              return De.push(W(\"expression\")), X.typeParameters && De.push(W(\"typeParameters\")), De;\n\n            case \"TSTemplateLiteralType\":\n              return D(te, W, oe);\n\n            case \"TSNamedTupleMember\":\n              return [W(\"label\"), X.optional ? \"?\" : \"\", \": \", W(\"elementType\")];\n\n            case \"TSRestType\":\n              return [\"...\", W(\"typeAnnotation\")];\n\n            case \"TSOptionalType\":\n              return [W(\"typeAnnotation\"), \"?\"];\n\n            case \"TSInterfaceDeclaration\":\n              return M(te, oe, W);\n\n            case \"TSClassImplements\":\n              return [W(\"expression\"), W(\"typeParameters\")];\n\n            case \"TSTypeParameterDeclaration\":\n            case \"TSTypeParameterInstantiation\":\n              return N(te, oe, W, \"params\");\n\n            case \"TSTypeParameter\":\n              return y(te, oe, W);\n\n            case \"TSAsExpression\":\n              {\n                De.push(W(\"expression\"), \" as \", W(\"typeAnnotation\"));\n                let ie = te.getParentNode();\n                return h(ie) && ie.callee === X || w(ie) && ie.object === X ? o([c([i, ...De]), i]) : De;\n              }\n\n            case \"TSArrayType\":\n              return [W(\"elementType\"), \"[]\"];\n\n            case \"TSPropertySignature\":\n              return X.readonly && De.push(\"readonly \"), De.push(x(te, oe, W), B(te)), X.typeAnnotation && De.push(\": \", W(\"typeAnnotation\")), X.initializer && De.push(\" = \", W(\"initializer\")), De;\n\n            case \"TSParameterProperty\":\n              return X.accessibility && De.push(X.accessibility + \" \"), X.export && De.push(\"export \"), X.static && De.push(\"static \"), X.override && De.push(\"override \"), X.readonly && De.push(\"readonly \"), De.push(W(\"parameter\")), De;\n\n            case \"TSTypeQuery\":\n              return [\"typeof \", W(\"exprName\"), W(\"typeParameters\")];\n\n            case \"TSIndexSignature\":\n              {\n                let ie = te.getParentNode(),\n                    G = X.parameters.length > 1 ? m(f(oe) ? \",\" : \"\") : \"\",\n                    z = o([c([i, a([\", \", i], te.map(W, \"parameters\"))]), G, i]);\n                return [X.export ? \"export \" : \"\", X.accessibility ? [X.accessibility, \" \"] : \"\", X.static ? \"static \" : \"\", X.readonly ? \"readonly \" : \"\", X.declare ? \"declare \" : \"\", \"[\", X.parameters ? z : \"\", X.typeAnnotation ? \"]: \" : \"]\", X.typeAnnotation ? W(\"typeAnnotation\") : \"\", ie.type === \"ClassBody\" ? ue : \"\"];\n              }\n\n            case \"TSTypePredicate\":\n              return [X.asserts ? \"asserts \" : \"\", W(\"parameterName\"), X.typeAnnotation ? [\" is \", W(\"typeAnnotation\")] : \"\"];\n\n            case \"TSNonNullExpression\":\n              return [W(\"expression\"), \"!\"];\n\n            case \"TSImportType\":\n              return [X.isTypeOf ? \"typeof \" : \"\", \"import(\", W(X.parameter ? \"parameter\" : \"argument\"), \")\", X.qualifier ? [\".\", W(\"qualifier\")] : \"\", N(te, oe, W, \"typeParameters\")];\n\n            case \"TSLiteralType\":\n              return W(\"literal\");\n\n            case \"TSIndexedAccessType\":\n              return R(te, oe, W);\n\n            case \"TSConstructSignatureDeclaration\":\n            case \"TSCallSignatureDeclaration\":\n            case \"TSConstructorType\":\n              {\n                if (X.type === \"TSConstructorType\" && X.abstract && De.push(\"abstract \"), X.type !== \"TSCallSignatureDeclaration\" && De.push(\"new \"), De.push(o(P(te, W, oe, !1, !0))), X.returnType || X.typeAnnotation) {\n                  let ie = X.type === \"TSConstructorType\";\n                  De.push(ie ? \" => \" : \": \", W(\"returnType\"), W(\"typeAnnotation\"));\n                }\n\n                return De;\n              }\n\n            case \"TSTypeOperator\":\n              return [X.operator, \" \", W(\"typeAnnotation\")];\n\n            case \"TSMappedType\":\n              {\n                let ie = s(oe.originalText, A(X), S(X));\n                return o([\"{\", c([oe.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, \"readonly\"), \" \"] : \"\", I(te, oe, W), W(\"typeParameter\"), X.optional ? p(X.optional, \"?\") : \"\", X.typeAnnotation ? \": \" : \"\", W(\"typeAnnotation\"), m(ue)]), t(te, oe, !0), oe.bracketSpacing ? r : i, \"}\"], {\n                  shouldBreak: ie\n                });\n              }\n\n            case \"TSMethodSignature\":\n              {\n                let ie = X.kind && X.kind !== \"method\" ? \"\".concat(X.kind, \" \") : \"\";\n                De.push(X.accessibility ? [X.accessibility, \" \"] : \"\", ie, X.export ? \"export \" : \"\", X.static ? \"static \" : \"\", X.readonly ? \"readonly \" : \"\", X.abstract ? \"abstract \" : \"\", X.declare ? \"declare \" : \"\", X.computed ? \"[\" : \"\", W(\"key\"), X.computed ? \"]\" : \"\", B(te));\n                let G = P(te, W, oe, !1, !0),\n                    z = X.returnType ? \"returnType\" : \"typeAnnotation\",\n                    U = X[z],\n                    le = U ? W(z) : \"\",\n                    ge = C(X, le);\n                return De.push(ge ? o(G) : G), U && De.push(\": \", o(le)), o(De);\n              }\n\n            case \"TSNamespaceExportDeclaration\":\n              return De.push(\"export as namespace \", W(\"id\")), oe.semi && De.push(\";\"), o(De);\n\n            case \"TSEnumDeclaration\":\n              return X.declare && De.push(\"declare \"), X.modifiers && De.push(I(te, oe, W)), X.const && De.push(\"const \"), De.push(\"enum \", W(\"id\"), \" \"), X.members.length === 0 ? De.push(o([\"{\", t(te, oe), i, \"}\"])) : De.push(o([\"{\", c([u, g(te, oe, \"members\", W), f(oe, \"es5\") ? \",\" : \"\"]), t(te, oe, !0), u, \"}\"])), De;\n\n            case \"TSEnumMember\":\n              return X.computed ? De.push(\"[\", W(\"id\"), \"]\") : De.push(W(\"id\")), X.initializer && De.push(\" = \", W(\"initializer\")), De;\n\n            case \"TSImportEqualsDeclaration\":\n              return X.isExport && De.push(\"export \"), De.push(\"import \"), X.importKind && X.importKind !== \"value\" && De.push(X.importKind, \" \"), De.push(W(\"id\"), \" = \", W(\"moduleReference\")), oe.semi && De.push(\";\"), o(De);\n\n            case \"TSExternalModuleReference\":\n              return [\"require(\", W(\"expression\"), \")\"];\n\n            case \"TSModuleDeclaration\":\n              {\n                let ie = te.getParentNode(),\n                    G = d(X.id),\n                    z = ie.type === \"TSModuleDeclaration\",\n                    U = X.body && X.body.type === \"TSModuleDeclaration\";\n                if (z) De.push(\".\");else {\n                  X.declare && De.push(\"declare \"), De.push(I(te, oe, W));\n                  let le = oe.originalText.slice(A(X), A(X.id));\n                  X.id.type === \"Identifier\" && X.id.name === \"global\" && !/namespace|module/.test(le) || De.push(G || /(?:^|\\s)module(?:\\s|$)/.test(le) ? \"module \" : \"namespace \");\n                }\n                return De.push(W(\"id\")), U ? De.push(W(\"body\")) : X.body ? De.push(\" \", o(W(\"body\"))) : De.push(ue), De;\n              }\n\n            case \"TSConditionalType\":\n              return k(te, oe, W);\n\n            case \"TSInferType\":\n              return [\"infer\", \" \", W(\"typeParameter\")];\n\n            case \"TSIntersectionType\":\n              return V(te, oe, W);\n\n            case \"TSUnionType\":\n              return q(te, oe, W);\n\n            case \"TSFunctionType\":\n              return Y(te, oe, W);\n\n            case \"TSTupleType\":\n              return H(te, oe, W);\n\n            case \"TSTypeReference\":\n              return [W(\"typeName\"), N(te, oe, W, \"typeParameters\")];\n\n            case \"TSTypeAnnotation\":\n              return W(\"typeAnnotation\");\n\n            case \"TSEmptyBodyFunctionExpression\":\n              return L(te, oe, W);\n\n            case \"TSJSDocAllType\":\n              return \"*\";\n\n            case \"TSJSDocUnknownType\":\n              return \"?\";\n\n            case \"TSJSDocNullableType\":\n              return Q(te, W, \"?\");\n\n            case \"TSJSDocNonNullableType\":\n              return Q(te, W, \"!\");\n\n            case \"TSInstantiationExpression\":\n              return [W(\"expression\"), W(\"typeParameters\")];\n\n            default:\n              throw new Error(\"Unknown TypeScript node type: \".concat(JSON.stringify(X.type), \".\"));\n          }\n        }\n\n        n.exports = {\n          printTypescript: ee\n        };\n      }\n\n    }),\n        Km = Z({\n      \"src/language-js/print/comment.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue29 = Ue(),\n            t = _Ue29.hasNewline,\n            _Oe35 = Oe(),\n            _Oe35$builders = _Oe35.builders,\n            s = _Oe35$builders.join,\n            a = _Oe35$builders.hardline,\n            r = _Oe35.utils.replaceTextEndOfLine,\n            _Ke30 = Ke(),\n            u = _Ke30.isLineComment,\n            _st14 = st(),\n            i = _st14.locStart,\n            o = _st14.locEnd,\n            c = It();\n\n        function v(p, f) {\n          let h = p.getValue();\n          if (u(h)) return f.originalText.slice(i(h), o(h)).trimEnd();\n\n          if (c(h)) {\n            if (m(h)) {\n              let A = d(h);\n              return h.trailing && !t(f.originalText, i(h), {\n                backwards: !0\n              }) ? [a, A] : A;\n            }\n\n            let w = o(h),\n                T = f.originalText.slice(w - 3, w) === \"*-/\";\n            return [\"/*\", r(h.value), T ? \"*-/\" : \"*/\"];\n          }\n\n          throw new Error(\"Not a comment: \" + JSON.stringify(h));\n        }\n\n        function m(p) {\n          let f = \"*\".concat(p.value, \"*\").split(\"\\n\");\n          return f.length > 1 && f.every(h => h.trim()[0] === \"*\");\n        }\n\n        function d(p) {\n          let f = p.value.split(\"\\n\");\n          return [\"/*\", s(a, f.map((h, w) => w === 0 ? h.trimEnd() : \" \" + (w < f.length - 1 ? h.trim() : h.trimStart()))), \"*/\"];\n        }\n\n        n.exports = {\n          printComment: v\n        };\n      }\n\n    }),\n        Ym = Z({\n      \"src/language-js/print/literal.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue30 = Ue(),\n            t = _Ue30.printString,\n            s = _Ue30.printNumber;\n\n        function a(i, o) {\n          let c = i.getNode();\n\n          switch (c.type) {\n            case \"RegExpLiteral\":\n              return u(c);\n\n            case \"BigIntLiteral\":\n              return r(c.bigint || c.extra.raw);\n\n            case \"NumericLiteral\":\n              return s(c.extra.raw);\n\n            case \"StringLiteral\":\n              return t(c.extra.raw, o);\n\n            case \"NullLiteral\":\n              return \"null\";\n\n            case \"BooleanLiteral\":\n              return String(c.value);\n\n            case \"DecimalLiteral\":\n              return s(c.value) + \"m\";\n\n            case \"Literal\":\n              {\n                if (c.regex) return u(c.regex);\n                if (c.bigint) return r(c.raw);\n                if (c.decimal) return s(c.decimal) + \"m\";\n                let v = c.value;\n                return typeof v == \"number\" ? s(c.raw) : typeof v == \"string\" ? t(c.raw, o) : String(v);\n              }\n          }\n        }\n\n        function r(i) {\n          return i.toLowerCase();\n        }\n\n        function u(i) {\n          let o = i.pattern,\n              c = i.flags;\n          return c = [...c].sort().join(\"\"), \"/\".concat(o, \"/\").concat(c);\n        }\n\n        n.exports = {\n          printLiteral: a\n        };\n      }\n\n    }),\n        Qm = Z({\n      \"src/language-js/printer-estree.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _et18 = et(),\n            t = _et18.printDanglingComments,\n            _Ue31 = Ue(),\n            s = _Ue31.hasNewline,\n            _Oe36 = Oe(),\n            _Oe36$builders = _Oe36.builders,\n            a = _Oe36$builders.join,\n            r = _Oe36$builders.line,\n            u = _Oe36$builders.hardline,\n            i = _Oe36$builders.softline,\n            o = _Oe36$builders.group,\n            c = _Oe36$builders.indent,\n            v = _Oe36.utils.replaceTextEndOfLine,\n            m = Im(),\n            d = Lm(),\n            _no = no(),\n            p = _no.insertPragma,\n            f = uo(),\n            h = jt(),\n            w = so(),\n            _Ke31 = Ke(),\n            T = _Ke31.hasFlowShorthandAnnotationComment,\n            A = _Ke31.hasComment,\n            S = _Ke31.CommentCheckFlags,\n            B = _Ke31.isTheOnlyJsxElementInMarkdown,\n            I = _Ke31.isLineComment,\n            k = _Ke31.isNextLineEmpty,\n            P = _Ke31.needsHardlineAfterDanglingComment,\n            C = _Ke31.rawText,\n            D = _Ke31.hasIgnoreComment,\n            g = _Ke31.isCallExpression,\n            F = _Ke31.isMemberExpression,\n            l = _Ke31.markerForIfWithoutBlockAndSameLineComment,\n            _st15 = st(),\n            E = _st15.locStart,\n            y = _st15.locEnd,\n            N = It(),\n            _$m = $m(),\n            x = _$m.printHtmlBinding,\n            b = _$m.isVueEventBindingExpression,\n            _Hm = Hm(),\n            L = _Hm.printAngular,\n            _Gm = Gm(),\n            M = _Gm.printJsx,\n            j = _Gm.hasJsxIgnoreComment,\n            _Um = Um(),\n            $ = _Um.printFlow,\n            _Xm = Xm(),\n            V = _Xm.printTypescript,\n            _ct12 = ct(),\n            q = _ct12.printOptionalToken,\n            Y = _ct12.printBindExpressionCallee,\n            H = _ct12.printTypeAnnotation,\n            R = _ct12.adjustClause,\n            Q = _ct12.printRestSpread,\n            ee = _ct12.printDefiniteToken,\n            _co2 = co(),\n            te = _co2.printImportDeclaration,\n            oe = _co2.printExportDeclaration,\n            W = _co2.printExportAllDeclaration,\n            X = _co2.printModuleSpecifier,\n            _po2 = po(),\n            ue = _po2.printTernary,\n            _Lt6 = Lt(),\n            De = _Lt6.printTemplateLiteral,\n            _Kt5 = Kt(),\n            ie = _Kt5.printArray,\n            _zn3 = zn(),\n            G = _zn3.printObject,\n            _Zt5 = Zt(),\n            z = _Zt5.printClass,\n            U = _Zt5.printClassMethod,\n            le = _Zt5.printClassProperty,\n            _Qt5 = Qt(),\n            ge = _Qt5.printProperty,\n            _Lr4 = Lr(),\n            Ae = _Lr4.printFunction,\n            Ne = _Lr4.printArrowFunction,\n            ke = _Lr4.printMethod,\n            ce = _Lr4.printReturnStatement,\n            pe = _Lr4.printThrowStatement,\n            _oo2 = oo(),\n            de = _oo2.printCallExpression,\n            _Yt5 = Yt(),\n            ae = _Yt5.printVariableDeclarator,\n            ve = _Yt5.printAssignmentExpression,\n            _Jn3 = Jn(),\n            K = _Jn3.printBinaryishExpression,\n            _fo2 = fo(),\n            he = _fo2.printSwitchCaseConsequent,\n            _ao2 = ao(),\n            ye = _ao2.printMemberExpression,\n            _Do2 = Do(),\n            Ce = _Do2.printBlock,\n            Ie = _Do2.printBlockBody,\n            _Km = Km(),\n            Fe = _Km.printComment,\n            _Ym = Ym(),\n            me = _Ym.printLiteral,\n            _Un3 = Un(),\n            _ = _Un3.printDecorators;\n\n        function J(Be, Pe, Se, Qe) {\n          let xe = ne(Be, Pe, Se, Qe);\n          if (!xe) return \"\";\n          let Xe = Be.getValue(),\n              _e = Xe.type;\n          if (_e === \"ClassMethod\" || _e === \"ClassPrivateMethod\" || _e === \"ClassProperty\" || _e === \"ClassAccessorProperty\" || _e === \"PropertyDefinition\" || _e === \"TSAbstractPropertyDefinition\" || _e === \"ClassPrivateProperty\" || _e === \"MethodDefinition\" || _e === \"TSAbstractMethodDefinition\" || _e === \"TSDeclareMethod\") return xe;\n\n          let je = [xe],\n              Re = _(Be, Pe, Se),\n              be = Xe.type === \"ClassExpression\" && Re;\n\n          if (Re && (je = [...Re, xe], !be)) return o(je);\n          if (!h(Be, Pe)) return Qe && Qe.needsSemi && je.unshift(\";\"), je.length === 1 && je[0] === xe ? xe : je;\n\n          if (be && (je = [c([r, ...je])]), je.unshift(\"(\"), Qe && Qe.needsSemi && je.unshift(\";\"), T(Xe)) {\n            let _Xe$trailingComments = _slicedToArray(Xe.trailingComments, 1),\n                qe = _Xe$trailingComments[0];\n\n            je.push(\" /*\", qe.value.trimStart(), \"*/\"), qe.printed = !0;\n          }\n\n          return be && je.push(r), je.push(\")\"), je;\n        }\n\n        function ne(Be, Pe, Se, Qe) {\n          let xe = Be.getValue(),\n              Xe = Pe.semi ? \";\" : \"\";\n          if (!xe) return \"\";\n          if (typeof xe == \"string\") return xe;\n\n          for (let je of [me, x, L, M, $, V]) {\n            let Re = je(Be, Pe, Se);\n            if (typeof Re < \"u\") return Re;\n          }\n\n          let _e = [];\n\n          switch (xe.type) {\n            case \"JsExpressionRoot\":\n              return Se(\"node\");\n\n            case \"JsonRoot\":\n              return [Se(\"node\"), u];\n\n            case \"File\":\n              return xe.program && xe.program.interpreter && _e.push(Se([\"program\", \"interpreter\"])), _e.push(Se(\"program\")), _e;\n\n            case \"Program\":\n              return Ie(Be, Pe, Se);\n\n            case \"EmptyStatement\":\n              return \"\";\n\n            case \"ExpressionStatement\":\n              {\n                if (xe.directive) return [Ee(xe.expression, Pe), Xe];\n\n                if (Pe.parser === \"__vue_event_binding\" || Pe.parser === \"__vue_ts_event_binding\") {\n                  let Re = Be.getParentNode();\n                  if (Re.type === \"Program\" && Re.body.length === 1 && Re.body[0] === xe) return [Se(\"expression\"), b(xe.expression) ? \";\" : \"\"];\n                }\n\n                let je = t(Be, Pe, !0, Re => {\n                  let be = Re.marker;\n                  return be === l;\n                });\n                return [Se(\"expression\"), B(Pe, Be) ? \"\" : Xe, je ? [\" \", je] : \"\"];\n              }\n\n            case \"ParenthesizedExpression\":\n              return !A(xe.expression) && (xe.expression.type === \"ObjectExpression\" || xe.expression.type === \"ArrayExpression\") ? [\"(\", Se(\"expression\"), \")\"] : o([\"(\", c([i, Se(\"expression\")]), i, \")\"]);\n\n            case \"AssignmentExpression\":\n              return ve(Be, Pe, Se);\n\n            case \"VariableDeclarator\":\n              return ae(Be, Pe, Se);\n\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n              return K(Be, Pe, Se);\n\n            case \"AssignmentPattern\":\n              return [Se(\"left\"), \" = \", Se(\"right\")];\n\n            case \"OptionalMemberExpression\":\n            case \"MemberExpression\":\n              return ye(Be, Pe, Se);\n\n            case \"MetaProperty\":\n              return [Se(\"meta\"), \".\", Se(\"property\")];\n\n            case \"BindExpression\":\n              return xe.object && _e.push(Se(\"object\")), _e.push(o(c([i, Y(Be, Pe, Se)]))), _e;\n\n            case \"Identifier\":\n              return [xe.name, q(Be), ee(Be), H(Be, Pe, Se)];\n\n            case \"V8IntrinsicIdentifier\":\n              return [\"%\", xe.name];\n\n            case \"SpreadElement\":\n            case \"SpreadElementPattern\":\n            case \"SpreadProperty\":\n            case \"SpreadPropertyPattern\":\n            case \"RestElement\":\n              return Q(Be, Pe, Se);\n\n            case \"FunctionDeclaration\":\n            case \"FunctionExpression\":\n              return Ae(Be, Se, Pe, Qe);\n\n            case \"ArrowFunctionExpression\":\n              return Ne(Be, Pe, Se, Qe);\n\n            case \"YieldExpression\":\n              return _e.push(\"yield\"), xe.delegate && _e.push(\"*\"), xe.argument && _e.push(\" \", Se(\"argument\")), _e;\n\n            case \"AwaitExpression\":\n              {\n                if (_e.push(\"await\"), xe.argument) {\n                  _e.push(\" \", Se(\"argument\"));\n\n                  let je = Be.getParentNode();\n\n                  if (g(je) && je.callee === xe || F(je) && je.object === xe) {\n                    _e = [c([i, ..._e]), i];\n                    let Re = Be.findAncestor(be => be.type === \"AwaitExpression\" || be.type === \"BlockStatement\");\n                    if (!Re || Re.type !== \"AwaitExpression\") return o(_e);\n                  }\n                }\n\n                return _e;\n              }\n\n            case \"ExportDefaultDeclaration\":\n            case \"ExportNamedDeclaration\":\n              return oe(Be, Pe, Se);\n\n            case \"ExportAllDeclaration\":\n              return W(Be, Pe, Se);\n\n            case \"ImportDeclaration\":\n              return te(Be, Pe, Se);\n\n            case \"ImportSpecifier\":\n            case \"ExportSpecifier\":\n            case \"ImportNamespaceSpecifier\":\n            case \"ExportNamespaceSpecifier\":\n            case \"ImportDefaultSpecifier\":\n            case \"ExportDefaultSpecifier\":\n              return X(Be, Pe, Se);\n\n            case \"ImportAttribute\":\n              return [Se(\"key\"), \": \", Se(\"value\")];\n\n            case \"Import\":\n              return \"import\";\n\n            case \"BlockStatement\":\n            case \"StaticBlock\":\n            case \"ClassBody\":\n              return Ce(Be, Pe, Se);\n\n            case \"ThrowStatement\":\n              return pe(Be, Pe, Se);\n\n            case \"ReturnStatement\":\n              return ce(Be, Pe, Se);\n\n            case \"NewExpression\":\n            case \"ImportExpression\":\n            case \"OptionalCallExpression\":\n            case \"CallExpression\":\n              return de(Be, Pe, Se);\n\n            case \"ObjectExpression\":\n            case \"ObjectPattern\":\n            case \"RecordExpression\":\n              return G(Be, Pe, Se);\n\n            case \"ObjectProperty\":\n            case \"Property\":\n              return xe.method || xe.kind === \"get\" || xe.kind === \"set\" ? ke(Be, Pe, Se) : ge(Be, Pe, Se);\n\n            case \"ObjectMethod\":\n              return ke(Be, Pe, Se);\n\n            case \"Decorator\":\n              return [\"@\", Se(\"expression\")];\n\n            case \"ArrayExpression\":\n            case \"ArrayPattern\":\n            case \"TupleExpression\":\n              return ie(Be, Pe, Se);\n\n            case \"SequenceExpression\":\n              {\n                let je = Be.getParentNode(0);\n\n                if (je.type === \"ExpressionStatement\" || je.type === \"ForStatement\") {\n                  let Re = [];\n                  return Be.each((be, Le) => {\n                    Le === 0 ? Re.push(Se()) : Re.push(\",\", c([r, Se()]));\n                  }, \"expressions\"), o(Re);\n                }\n\n                return o(a([\",\", r], Be.map(Se, \"expressions\")));\n              }\n\n            case \"ThisExpression\":\n              return \"this\";\n\n            case \"Super\":\n              return \"super\";\n\n            case \"Directive\":\n              return [Se(\"value\"), Xe];\n\n            case \"DirectiveLiteral\":\n              return Ee(xe, Pe);\n\n            case \"UnaryExpression\":\n              return _e.push(xe.operator), /[a-z]$/.test(xe.operator) && _e.push(\" \"), A(xe.argument) ? _e.push(o([\"(\", c([i, Se(\"argument\")]), i, \")\"])) : _e.push(Se(\"argument\")), _e;\n\n            case \"UpdateExpression\":\n              return _e.push(Se(\"argument\"), xe.operator), xe.prefix && _e.reverse(), _e;\n\n            case \"ConditionalExpression\":\n              return ue(Be, Pe, Se);\n\n            case \"VariableDeclaration\":\n              {\n                let je = Be.map(Se, \"declarations\"),\n                    Re = Be.getParentNode(),\n                    be = Re.type === \"ForStatement\" || Re.type === \"ForInStatement\" || Re.type === \"ForOfStatement\",\n                    Le = xe.declarations.some(se => se.init),\n                    qe;\n                return je.length === 1 && !A(xe.declarations[0]) ? qe = je[0] : je.length > 0 && (qe = c(je[0])), _e = [xe.declare ? \"declare \" : \"\", xe.kind, qe ? [\" \", qe] : \"\", c(je.slice(1).map(se => [\",\", Le && !be ? u : r, se]))], be && Re.body !== xe || _e.push(Xe), o(_e);\n              }\n\n            case \"WithStatement\":\n              return o([\"with (\", Se(\"object\"), \")\", R(xe.body, Se(\"body\"))]);\n\n            case \"IfStatement\":\n              {\n                let je = R(xe.consequent, Se(\"consequent\")),\n                    Re = o([\"if (\", o([c([i, Se(\"test\")]), i]), \")\", je]);\n\n                if (_e.push(Re), xe.alternate) {\n                  let be = A(xe.consequent, S.Trailing | S.Line) || P(xe),\n                      Le = xe.consequent.type === \"BlockStatement\" && !be;\n                  _e.push(Le ? \" \" : u), A(xe, S.Dangling) && _e.push(t(Be, Pe, !0), be ? u : \" \"), _e.push(\"else\", o(R(xe.alternate, Se(\"alternate\"), xe.alternate.type === \"IfStatement\")));\n                }\n\n                return _e;\n              }\n\n            case \"ForStatement\":\n              {\n                let je = R(xe.body, Se(\"body\")),\n                    Re = t(Be, Pe, !0),\n                    be = Re ? [Re, i] : \"\";\n                return !xe.init && !xe.test && !xe.update ? [be, o([\"for (;;)\", je])] : [be, o([\"for (\", o([c([i, Se(\"init\"), \";\", r, Se(\"test\"), \";\", r, Se(\"update\")]), i]), \")\", je])];\n              }\n\n            case \"WhileStatement\":\n              return o([\"while (\", o([c([i, Se(\"test\")]), i]), \")\", R(xe.body, Se(\"body\"))]);\n\n            case \"ForInStatement\":\n              return o([\"for (\", Se(\"left\"), \" in \", Se(\"right\"), \")\", R(xe.body, Se(\"body\"))]);\n\n            case \"ForOfStatement\":\n              return o([\"for\", xe.await ? \" await\" : \"\", \" (\", Se(\"left\"), \" of \", Se(\"right\"), \")\", R(xe.body, Se(\"body\"))]);\n\n            case \"DoWhileStatement\":\n              {\n                let je = R(xe.body, Se(\"body\"));\n                return _e = [o([\"do\", je])], xe.body.type === \"BlockStatement\" ? _e.push(\" \") : _e.push(u), _e.push(\"while (\", o([c([i, Se(\"test\")]), i]), \")\", Xe), _e;\n              }\n\n            case \"DoExpression\":\n              return [xe.async ? \"async \" : \"\", \"do \", Se(\"body\")];\n\n            case \"BreakStatement\":\n              return _e.push(\"break\"), xe.label && _e.push(\" \", Se(\"label\")), _e.push(Xe), _e;\n\n            case \"ContinueStatement\":\n              return _e.push(\"continue\"), xe.label && _e.push(\" \", Se(\"label\")), _e.push(Xe), _e;\n\n            case \"LabeledStatement\":\n              return xe.body.type === \"EmptyStatement\" ? [Se(\"label\"), \":;\"] : [Se(\"label\"), \": \", Se(\"body\")];\n\n            case \"TryStatement\":\n              return [\"try \", Se(\"block\"), xe.handler ? [\" \", Se(\"handler\")] : \"\", xe.finalizer ? [\" finally \", Se(\"finalizer\")] : \"\"];\n\n            case \"CatchClause\":\n              if (xe.param) {\n                let je = A(xe.param, be => !N(be) || be.leading && s(Pe.originalText, y(be)) || be.trailing && s(Pe.originalText, E(be), {\n                  backwards: !0\n                })),\n                    Re = Se(\"param\");\n                return [\"catch \", je ? [\"(\", c([i, Re]), i, \") \"] : [\"(\", Re, \") \"], Se(\"body\")];\n              }\n\n              return [\"catch \", Se(\"body\")];\n\n            case \"SwitchStatement\":\n              return [o([\"switch (\", c([i, Se(\"discriminant\")]), i, \")\"]), \" {\", xe.cases.length > 0 ? c([u, a(u, Be.map((je, Re, be) => {\n                let Le = je.getValue();\n                return [Se(), Re !== be.length - 1 && k(Le, Pe) ? u : \"\"];\n              }, \"cases\"))]) : \"\", u, \"}\"];\n\n            case \"SwitchCase\":\n              {\n                xe.test ? _e.push(\"case \", Se(\"test\"), \":\") : _e.push(\"default:\"), A(xe, S.Dangling) && _e.push(\" \", t(Be, Pe, !0));\n                let je = xe.consequent.filter(Re => Re.type !== \"EmptyStatement\");\n\n                if (je.length > 0) {\n                  let Re = he(Be, Pe, Se);\n\n                  _e.push(je.length === 1 && je[0].type === \"BlockStatement\" ? [\" \", Re] : c([u, Re]));\n                }\n\n                return _e;\n              }\n\n            case \"DebuggerStatement\":\n              return [\"debugger\", Xe];\n\n            case \"ClassDeclaration\":\n            case \"ClassExpression\":\n              return z(Be, Pe, Se);\n\n            case \"ClassMethod\":\n            case \"ClassPrivateMethod\":\n            case \"MethodDefinition\":\n              return U(Be, Pe, Se);\n\n            case \"ClassProperty\":\n            case \"PropertyDefinition\":\n            case \"ClassPrivateProperty\":\n            case \"ClassAccessorProperty\":\n              return le(Be, Pe, Se);\n\n            case \"TemplateElement\":\n              return v(xe.value.raw);\n\n            case \"TemplateLiteral\":\n              return De(Be, Se, Pe);\n\n            case \"TaggedTemplateExpression\":\n              return [Se(\"tag\"), Se(\"typeParameters\"), Se(\"quasi\")];\n\n            case \"PrivateIdentifier\":\n              return [\"#\", Se(\"name\")];\n\n            case \"PrivateName\":\n              return [\"#\", Se(\"id\")];\n\n            case \"InterpreterDirective\":\n              return _e.push(\"#!\", xe.value, u), k(xe, Pe) && _e.push(u), _e;\n\n            case \"TopicReference\":\n              return \"%\";\n\n            case \"ArgumentPlaceholder\":\n              return \"?\";\n\n            case \"ModuleExpression\":\n              {\n                _e.push(\"module {\");\n\n                let je = Se(\"body\");\n                return je && _e.push(c([u, je]), u), _e.push(\"}\"), _e;\n              }\n\n            default:\n              throw new Error(\"unknown type: \" + JSON.stringify(xe.type));\n          }\n        }\n\n        function Ee(Be, Pe) {\n          let Se = C(Be),\n              Qe = Se.slice(1, -1);\n          if (Qe.includes('\"') || Qe.includes(\"'\")) return Se;\n          let xe = Pe.singleQuote ? \"'\" : '\"';\n          return xe + Qe + xe;\n        }\n\n        function We(Be) {\n          return Be.type && !N(Be) && !I(Be) && Be.type !== \"EmptyStatement\" && Be.type !== \"TemplateElement\" && Be.type !== \"Import\" && Be.type !== \"TSEmptyBodyFunctionExpression\";\n        }\n\n        n.exports = {\n          preprocess: w,\n          print: J,\n          embed: m,\n          insertPragma: p,\n          massageAstNode: d,\n\n          hasPrettierIgnore(Be) {\n            return D(Be) || j(Be);\n          },\n\n          willPrintOwnComments: f.willPrintOwnComments,\n          canAttachComment: We,\n          printComment: Fe,\n          isBlockComment: N,\n          handleComments: {\n            avoidAstMutation: !0,\n            ownLine: f.handleOwnLineComment,\n            endOfLine: f.handleEndOfLineComment,\n            remaining: f.handleRemainingComment\n          },\n          getCommentChildNodes: f.getCommentChildNodes\n        };\n      }\n\n    }),\n        Zm = Z({\n      \"src/language-js/printer-estree-json.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe37 = Oe(),\n            _Oe37$builders = _Oe37.builders,\n            t = _Oe37$builders.hardline,\n            s = _Oe37$builders.indent,\n            a = _Oe37$builders.join,\n            r = so();\n\n        function u(c, v, m) {\n          let d = c.getValue();\n\n          switch (d.type) {\n            case \"JsonRoot\":\n              return [m(\"node\"), t];\n\n            case \"ArrayExpression\":\n              {\n                if (d.elements.length === 0) return \"[]\";\n                let p = c.map(() => c.getValue() === null ? \"null\" : m(), \"elements\");\n                return [\"[\", s([t, a([\",\", t], p)]), t, \"]\"];\n              }\n\n            case \"ObjectExpression\":\n              return d.properties.length === 0 ? \"{}\" : [\"{\", s([t, a([\",\", t], c.map(m, \"properties\"))]), t, \"}\"];\n\n            case \"ObjectProperty\":\n              return [m(\"key\"), \": \", m(\"value\")];\n\n            case \"UnaryExpression\":\n              return [d.operator === \"+\" ? \"\" : d.operator, m(\"argument\")];\n\n            case \"NullLiteral\":\n              return \"null\";\n\n            case \"BooleanLiteral\":\n              return d.value ? \"true\" : \"false\";\n\n            case \"StringLiteral\":\n            case \"NumericLiteral\":\n              return JSON.stringify(d.value);\n\n            case \"Identifier\":\n              {\n                let p = c.getParentNode();\n                return p && p.type === \"ObjectProperty\" && p.key === d ? JSON.stringify(d.name) : d.name;\n              }\n\n            case \"TemplateLiteral\":\n              return m([\"quasis\", 0]);\n\n            case \"TemplateElement\":\n              return JSON.stringify(d.value.cooked);\n\n            default:\n              throw new Error(\"unknown type: \" + JSON.stringify(d.type));\n          }\n        }\n\n        var i = new Set([\"start\", \"end\", \"extra\", \"loc\", \"comments\", \"leadingComments\", \"trailingComments\", \"innerComments\", \"errors\", \"range\", \"tokens\"]);\n\n        function o(c, v) {\n          let m = c.type;\n\n          if (m === \"ObjectProperty\" && c.key.type === \"Identifier\") {\n            v.key = {\n              type: \"StringLiteral\",\n              value: c.key.name\n            };\n            return;\n          }\n\n          if (m === \"UnaryExpression\" && c.operator === \"+\") return v.argument;\n\n          if (m === \"ArrayExpression\") {\n            for (let _ref33 of c.elements.entries()) {\n              var _ref34 = _slicedToArray(_ref33, 2);\n\n              let d = _ref34[0];\n              let p = _ref34[1];\n              p === null && v.elements.splice(d, 0, {\n                type: \"NullLiteral\"\n              });\n            }\n\n            return;\n          }\n\n          if (m === \"TemplateLiteral\") return {\n            type: \"StringLiteral\",\n            value: c.quasis[0].value.cooked\n          };\n        }\n\n        o.ignoredProperties = i, n.exports = {\n          preprocess: r,\n          print: u,\n          massageAstNode: o\n        };\n      }\n\n    }),\n        Ot = Z({\n      \"src/common/common-options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = \"Common\";\n        n.exports = {\n          bracketSpacing: {\n            since: \"0.0.0\",\n            category: t,\n            type: \"boolean\",\n            default: !0,\n            description: \"Print spaces between brackets.\",\n            oppositeDescription: \"Do not print spaces between brackets.\"\n          },\n          singleQuote: {\n            since: \"0.0.0\",\n            category: t,\n            type: \"boolean\",\n            default: !1,\n            description: \"Use single quotes instead of double quotes.\"\n          },\n          proseWrap: {\n            since: \"1.8.2\",\n            category: t,\n            type: \"choice\",\n            default: [{\n              since: \"1.8.2\",\n              value: !0\n            }, {\n              since: \"1.9.0\",\n              value: \"preserve\"\n            }],\n            description: \"How to wrap prose.\",\n            choices: [{\n              since: \"1.9.0\",\n              value: \"always\",\n              description: \"Wrap prose if it exceeds the print width.\"\n            }, {\n              since: \"1.9.0\",\n              value: \"never\",\n              description: \"Do not wrap prose.\"\n            }, {\n              since: \"1.9.0\",\n              value: \"preserve\",\n              description: \"Wrap prose as-is.\"\n            }]\n          },\n          bracketSameLine: {\n            since: \"2.4.0\",\n            category: t,\n            type: \"boolean\",\n            default: !1,\n            description: \"Put > of opening tags on the last line instead of on a new line.\"\n          },\n          singleAttributePerLine: {\n            since: \"2.6.0\",\n            category: t,\n            type: \"boolean\",\n            default: !1,\n            description: \"Enforce single attribute per line in HTML, Vue and JSX.\"\n          }\n        };\n      }\n\n    }),\n        ed = Z({\n      \"src/language-js/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot(),\n            s = \"JavaScript\";\n        n.exports = {\n          arrowParens: {\n            since: \"1.9.0\",\n            category: s,\n            type: \"choice\",\n            default: [{\n              since: \"1.9.0\",\n              value: \"avoid\"\n            }, {\n              since: \"2.0.0\",\n              value: \"always\"\n            }],\n            description: \"Include parentheses around a sole arrow function parameter.\",\n            choices: [{\n              value: \"always\",\n              description: \"Always include parens. Example: `(x) => x`\"\n            }, {\n              value: \"avoid\",\n              description: \"Omit parens when possible. Example: `x => x`\"\n            }]\n          },\n          bracketSameLine: t.bracketSameLine,\n          bracketSpacing: t.bracketSpacing,\n          jsxBracketSameLine: {\n            since: \"0.17.0\",\n            category: s,\n            type: \"boolean\",\n            description: \"Put > on the last line instead of at a new line.\",\n            deprecated: \"2.4.0\"\n          },\n          semi: {\n            since: \"1.0.0\",\n            category: s,\n            type: \"boolean\",\n            default: !0,\n            description: \"Print semicolons.\",\n            oppositeDescription: \"Do not print semicolons, except at the beginning of lines which may need them.\"\n          },\n          singleQuote: t.singleQuote,\n          jsxSingleQuote: {\n            since: \"1.15.0\",\n            category: s,\n            type: \"boolean\",\n            default: !1,\n            description: \"Use single quotes in JSX.\"\n          },\n          quoteProps: {\n            since: \"1.17.0\",\n            category: s,\n            type: \"choice\",\n            default: \"as-needed\",\n            description: \"Change when properties in objects are quoted.\",\n            choices: [{\n              value: \"as-needed\",\n              description: \"Only add quotes around object properties where required.\"\n            }, {\n              value: \"consistent\",\n              description: \"If at least one property in an object requires quotes, quote all properties.\"\n            }, {\n              value: \"preserve\",\n              description: \"Respect the input use of quotes in object properties.\"\n            }]\n          },\n          trailingComma: {\n            since: \"0.0.0\",\n            category: s,\n            type: \"choice\",\n            default: [{\n              since: \"0.0.0\",\n              value: !1\n            }, {\n              since: \"0.19.0\",\n              value: \"none\"\n            }, {\n              since: \"2.0.0\",\n              value: \"es5\"\n            }],\n            description: \"Print trailing commas wherever possible when multi-line.\",\n            choices: [{\n              value: \"es5\",\n              description: \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"\n            }, {\n              value: \"none\",\n              description: \"No trailing commas.\"\n            }, {\n              value: \"all\",\n              description: \"Trailing commas wherever possible (including function arguments).\"\n            }]\n          },\n          singleAttributePerLine: t.singleAttributePerLine\n        };\n      }\n\n    }),\n        td = Z({\n      \"src/language-js/parse/parsers.js\"() {\n        re();\n      }\n\n    }),\n        Sn = Z({\n      \"node_modules/linguist-languages/data/JavaScript.json\"(e, n) {\n        n.exports = {\n          name: \"JavaScript\",\n          type: \"programming\",\n          tmScope: \"source.js\",\n          aceMode: \"javascript\",\n          codemirrorMode: \"javascript\",\n          codemirrorMimeType: \"text/javascript\",\n          color: \"#f1e05a\",\n          aliases: [\"js\", \"node\"],\n          extensions: [\".js\", \"._js\", \".bones\", \".cjs\", \".es\", \".es6\", \".frag\", \".gs\", \".jake\", \".javascript\", \".jsb\", \".jscad\", \".jsfl\", \".jslib\", \".jsm\", \".jspre\", \".jss\", \".jsx\", \".mjs\", \".njs\", \".pac\", \".sjs\", \".ssjs\", \".xsjs\", \".xsjslib\"],\n          filenames: [\"Jakefile\"],\n          interpreters: [\"chakra\", \"d8\", \"gjs\", \"js\", \"node\", \"nodejs\", \"qjs\", \"rhino\", \"v8\", \"v8-shell\"],\n          languageId: 183\n        };\n      }\n\n    }),\n        rd = Z({\n      \"node_modules/linguist-languages/data/TypeScript.json\"(e, n) {\n        n.exports = {\n          name: \"TypeScript\",\n          type: \"programming\",\n          color: \"#3178c6\",\n          aliases: [\"ts\"],\n          interpreters: [\"deno\", \"ts-node\"],\n          extensions: [\".ts\", \".cts\", \".mts\"],\n          tmScope: \"source.ts\",\n          aceMode: \"typescript\",\n          codemirrorMode: \"javascript\",\n          codemirrorMimeType: \"application/typescript\",\n          languageId: 378\n        };\n      }\n\n    }),\n        nd = Z({\n      \"node_modules/linguist-languages/data/TSX.json\"(e, n) {\n        n.exports = {\n          name: \"TSX\",\n          type: \"programming\",\n          color: \"#3178c6\",\n          group: \"TypeScript\",\n          extensions: [\".tsx\"],\n          tmScope: \"source.tsx\",\n          aceMode: \"javascript\",\n          codemirrorMode: \"jsx\",\n          codemirrorMimeType: \"text/jsx\",\n          languageId: 94901924\n        };\n      }\n\n    }),\n        ma = Z({\n      \"node_modules/linguist-languages/data/JSON.json\"(e, n) {\n        n.exports = {\n          name: \"JSON\",\n          type: \"data\",\n          color: \"#292929\",\n          tmScope: \"source.json\",\n          aceMode: \"json\",\n          codemirrorMode: \"javascript\",\n          codemirrorMimeType: \"application/json\",\n          aliases: [\"geojson\", \"jsonl\", \"topojson\"],\n          extensions: [\".json\", \".4DForm\", \".4DProject\", \".avsc\", \".geojson\", \".gltf\", \".har\", \".ice\", \".JSON-tmLanguage\", \".jsonl\", \".mcmeta\", \".tfstate\", \".tfstate.backup\", \".topojson\", \".webapp\", \".webmanifest\", \".yy\", \".yyp\"],\n          filenames: [\".arcconfig\", \".auto-changelog\", \".c8rc\", \".htmlhintrc\", \".imgbotconfig\", \".nycrc\", \".tern-config\", \".tern-project\", \".watchmanconfig\", \"Pipfile.lock\", \"composer.lock\", \"mcmod.info\"],\n          languageId: 174\n        };\n      }\n\n    }),\n        ud = Z({\n      \"node_modules/linguist-languages/data/JSON with Comments.json\"(e, n) {\n        n.exports = {\n          name: \"JSON with Comments\",\n          type: \"data\",\n          color: \"#292929\",\n          group: \"JSON\",\n          tmScope: \"source.js\",\n          aceMode: \"javascript\",\n          codemirrorMode: \"javascript\",\n          codemirrorMimeType: \"text/javascript\",\n          aliases: [\"jsonc\"],\n          extensions: [\".jsonc\", \".code-snippets\", \".sublime-build\", \".sublime-commands\", \".sublime-completions\", \".sublime-keymap\", \".sublime-macro\", \".sublime-menu\", \".sublime-mousemap\", \".sublime-project\", \".sublime-settings\", \".sublime-theme\", \".sublime-workspace\", \".sublime_metrics\", \".sublime_session\"],\n          filenames: [\".babelrc\", \".devcontainer.json\", \".eslintrc.json\", \".jscsrc\", \".jshintrc\", \".jslintrc\", \"api-extractor.json\", \"devcontainer.json\", \"jsconfig.json\", \"language-configuration.json\", \"tsconfig.json\", \"tslint.json\"],\n          languageId: 423\n        };\n      }\n\n    }),\n        sd = Z({\n      \"node_modules/linguist-languages/data/JSON5.json\"(e, n) {\n        n.exports = {\n          name: \"JSON5\",\n          type: \"data\",\n          color: \"#267CB9\",\n          extensions: [\".json5\"],\n          tmScope: \"source.js\",\n          aceMode: \"javascript\",\n          codemirrorMode: \"javascript\",\n          codemirrorMimeType: \"application/json\",\n          languageId: 175\n        };\n      }\n\n    }),\n        id = Z({\n      \"src/language-js/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = Qm(),\n            a = Zm(),\n            r = ed(),\n            u = td(),\n            i = [t(Sn(), c => ({\n          since: \"0.0.0\",\n          parsers: [\"babel\", \"acorn\", \"espree\", \"meriyah\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\"],\n          vscodeLanguageIds: [\"javascript\", \"mongo\"],\n          interpreters: [...c.interpreters, \"zx\"],\n          extensions: [...c.extensions.filter(v => v !== \".jsx\"), \".wxs\"]\n        })), t(Sn(), () => ({\n          name: \"Flow\",\n          since: \"0.0.0\",\n          parsers: [\"flow\", \"babel-flow\"],\n          vscodeLanguageIds: [\"javascript\"],\n          aliases: [],\n          filenames: [],\n          extensions: [\".js.flow\"]\n        })), t(Sn(), () => ({\n          name: \"JSX\",\n          since: \"0.0.0\",\n          parsers: [\"babel\", \"babel-flow\", \"babel-ts\", \"flow\", \"typescript\", \"espree\", \"meriyah\"],\n          vscodeLanguageIds: [\"javascriptreact\"],\n          aliases: void 0,\n          filenames: void 0,\n          extensions: [\".jsx\"],\n          group: \"JavaScript\",\n          interpreters: void 0,\n          tmScope: \"source.js.jsx\",\n          aceMode: \"javascript\",\n          codemirrorMode: \"jsx\",\n          codemirrorMimeType: \"text/jsx\",\n          color: void 0\n        })), t(rd(), () => ({\n          since: \"1.4.0\",\n          parsers: [\"typescript\", \"babel-ts\"],\n          vscodeLanguageIds: [\"typescript\"]\n        })), t(nd(), () => ({\n          since: \"1.4.0\",\n          parsers: [\"typescript\", \"babel-ts\"],\n          vscodeLanguageIds: [\"typescriptreact\"]\n        })), t(ma(), () => ({\n          name: \"JSON.stringify\",\n          since: \"1.13.0\",\n          parsers: [\"json-stringify\"],\n          vscodeLanguageIds: [\"json\"],\n          extensions: [\".importmap\"],\n          filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"]\n        })), t(ma(), c => ({\n          since: \"1.5.0\",\n          parsers: [\"json\"],\n          vscodeLanguageIds: [\"json\"],\n          extensions: c.extensions.filter(v => v !== \".jsonl\")\n        })), t(ud(), c => ({\n          since: \"1.5.0\",\n          parsers: [\"json\"],\n          vscodeLanguageIds: [\"jsonc\"],\n          filenames: [...c.filenames, \".eslintrc\", \".swcrc\"]\n        })), t(sd(), () => ({\n          since: \"1.13.0\",\n          parsers: [\"json5\"],\n          vscodeLanguageIds: [\"json5\"]\n        }))],\n            o = {\n          estree: s,\n          \"estree-json\": a\n        };\n        n.exports = {\n          languages: i,\n          options: r,\n          printers: o,\n          parsers: u\n        };\n      }\n\n    }),\n        ad = Z({\n      \"src/language-css/clean.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue32 = Ue(),\n            t = _Ue32.isFrontMatterNode,\n            s = it(),\n            a = new Set([\"raw\", \"raws\", \"sourceIndex\", \"source\", \"before\", \"after\", \"trailingComma\"]);\n\n        function r(i, o, c) {\n          if (t(i) && i.lang === \"yaml\" && delete o.value, i.type === \"css-comment\" && c.type === \"css-root\" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete o.text, /^\\*\\s*@(?:format|prettier)\\s*$/.test(i.text)) || c.type === \"css-root\" && s(c.nodes) === i)) return null;\n\n          if (i.type === \"value-root\" && delete o.text, (i.type === \"media-query\" || i.type === \"media-query-list\" || i.type === \"media-feature-expression\") && delete o.value, i.type === \"css-rule\" && delete o.params, i.type === \"selector-combinator\" && (o.value = o.value.replace(/\\s+/g, \" \")), i.type === \"media-feature\" && (o.value = o.value.replace(/ /g, \"\")), (i.type === \"value-word\" && (i.isColor && i.isHex || [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(o.value.replace().toLowerCase())) || i.type === \"media-feature\" || i.type === \"selector-root-invalid\" || i.type === \"selector-pseudo\") && (o.value = o.value.toLowerCase()), i.type === \"css-decl\" && (o.prop = o.prop.toLowerCase()), (i.type === \"css-atrule\" || i.type === \"css-import\") && (o.name = o.name.toLowerCase()), i.type === \"value-number\" && (o.unit = o.unit.toLowerCase()), (i.type === \"media-feature\" || i.type === \"media-keyword\" || i.type === \"media-type\" || i.type === \"media-unknown\" || i.type === \"media-url\" || i.type === \"media-value\" || i.type === \"selector-attribute\" || i.type === \"selector-string\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"value-string\") && o.value && (o.value = u(o.value)), i.type === \"selector-attribute\" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == \"string\" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = !0)), o.value && (o.value = o.value.trim().replace(/^[\"']|[\"']$/g, \"\"), delete o.quoted)), (i.type === \"media-value\" || i.type === \"media-type\" || i.type === \"value-number\" || i.type === \"selector-root-invalid\" || i.type === \"selector-class\" || i.type === \"selector-combinator\" || i.type === \"selector-tag\") && o.value && (o.value = o.value.replace(/([\\d+.Ee-]+)([A-Za-z]*)/g, (v, m, d) => {\n            let p = Number(m);\n            return Number.isNaN(p) ? v : p + d.toLowerCase();\n          })), i.type === \"selector-tag\") {\n            let v = i.value.toLowerCase();\n            [\"from\", \"to\"].includes(v) && (o.value = v);\n          }\n\n          if (i.type === \"css-atrule\" && i.name.toLowerCase() === \"supports\" && delete o.value, i.type === \"selector-unknown\" && delete o.value, i.type === \"value-comma_group\") {\n            let v = i.groups.findIndex(m => m.type === \"value-number\" && m.unit === \"...\");\n            v !== -1 && (o.groups[v].unit = \"\", o.groups.splice(v + 1, 0, {\n              type: \"value-word\",\n              value: \"...\",\n              isColor: !1,\n              isHex: !1\n            }));\n          }\n        }\n\n        r.ignoredProperties = a;\n\n        function u(i) {\n          return i.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");\n        }\n\n        n.exports = r;\n      }\n\n    }),\n        Xn = Z({\n      \"src/utils/front-matter/print.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe38 = Oe(),\n            _Oe38$builders = _Oe38.builders,\n            t = _Oe38$builders.hardline,\n            s = _Oe38$builders.markAsRoot;\n\n        function a(r, u) {\n          if (r.lang === \"yaml\") {\n            let i = r.value.trim(),\n                o = i ? u(i, {\n              parser: \"yaml\"\n            }, {\n              stripTrailingHardline: !0\n            }) : \"\";\n            return s([r.startDelimiter, t, o, o ? t : \"\", r.endDelimiter]);\n          }\n        }\n\n        n.exports = a;\n      }\n\n    }),\n        od = Z({\n      \"src/language-css/embed.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe39 = Oe(),\n            t = _Oe39.builders.hardline,\n            s = Xn();\n\n        function a(r, u, i) {\n          let o = r.getValue();\n\n          if (o.type === \"front-matter\") {\n            let c = s(o, i);\n            return c ? [c, t] : \"\";\n          }\n        }\n\n        n.exports = a;\n      }\n\n    }),\n        mo = Z({\n      \"src/utils/front-matter/parse.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = new RegExp(\"^(?<startDelimiter>-{3}|\\\\+{3})(?<language>[^\\\\n]*)\\\\n(?:|(?<value>.*?)\\\\n)(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})[^\\\\S\\\\n]*(?:\\\\n|$)\", \"s\");\n\n        function s(a) {\n          let r = a.match(t);\n          if (!r) return {\n            content: a\n          };\n          let _r$groups = r.groups,\n              u = _r$groups.startDelimiter,\n              i = _r$groups.language,\n              _r$groups$value = _r$groups.value,\n              o = _r$groups$value === void 0 ? \"\" : _r$groups$value,\n              c = _r$groups.endDelimiter,\n              v = i.trim() || \"yaml\";\n          if (u === \"+++\" && (v = \"toml\"), v !== \"yaml\" && u !== c) return {\n            content: a\n          };\n\n          let _r3 = _slicedToArray(r, 1),\n              m = _r3[0];\n\n          return {\n            frontMatter: {\n              type: \"front-matter\",\n              lang: v,\n              value: o,\n              startDelimiter: u,\n              endDelimiter: c,\n              raw: m.replace(/\\n$/, \"\")\n            },\n            content: m.replace(/[^\\n]/g, \" \") + a.slice(m.length)\n          };\n        }\n\n        n.exports = s;\n      }\n\n    }),\n        ld = Z({\n      \"src/language-css/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = no(),\n            s = mo();\n\n        function a(u) {\n          return t.hasPragma(s(u).content);\n        }\n\n        function r(u) {\n          let _s2 = s(u),\n              i = _s2.frontMatter,\n              o = _s2.content;\n\n          return (i ? i.raw + \"\\n\\n\" : \"\") + t.insertPragma(o);\n        }\n\n        n.exports = {\n          hasPragma: a,\n          insertPragma: r\n        };\n      }\n\n    }),\n        cd = Z({\n      \"src/language-css/utils/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = new Set([\"red\", \"green\", \"blue\", \"alpha\", \"a\", \"rgb\", \"hue\", \"h\", \"saturation\", \"s\", \"lightness\", \"l\", \"whiteness\", \"w\", \"blackness\", \"b\", \"tint\", \"shade\", \"blend\", \"blenda\", \"contrast\", \"hsl\", \"hsla\", \"hwb\", \"hwba\"]);\n\n        function s(G, z) {\n          let U = Array.isArray(z) ? z : [z],\n              le = -1,\n              ge;\n\n          for (; ge = G.getParentNode(++le);) if (U.includes(ge.type)) return le;\n\n          return -1;\n        }\n\n        function a(G, z) {\n          let U = s(G, z);\n          return U === -1 ? null : G.getParentNode(U);\n        }\n\n        function r(G) {\n          var z;\n          let U = a(G, \"css-decl\");\n          return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();\n        }\n\n        var u = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);\n\n        function i(G) {\n          return u.has(G.toLowerCase());\n        }\n\n        function o(G, z) {\n          let U = a(G, \"css-atrule\");\n          return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith(\"keyframes\") && [\"from\", \"to\"].includes(z.toLowerCase());\n        }\n\n        function c(G) {\n          return G.includes(\"$\") || G.includes(\"@\") || G.includes(\"#\") || G.startsWith(\"%\") || G.startsWith(\"--\") || G.startsWith(\":--\") || G.includes(\"(\") && G.includes(\")\") ? G : G.toLowerCase();\n        }\n\n        function v(G, z) {\n          var U;\n          let le = a(G, \"value-func\");\n          return (le == null || (U = le.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;\n        }\n\n        function m(G) {\n          var z;\n          let U = a(G, \"css-rule\"),\n              le = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;\n          return le && (le.startsWith(\":import\") || le.startsWith(\":export\"));\n        }\n\n        function d(G, z) {\n          let U = Array.isArray(z) ? z : [z],\n              le = a(G, \"css-atrule\");\n          return le && U.includes(le.name.toLowerCase());\n        }\n\n        function p(G) {\n          let z = G.getValue(),\n              U = a(G, \"css-atrule\");\n          return (U == null ? void 0 : U.name) === \"import\" && z.groups[0].value === \"url\" && z.groups.length === 2;\n        }\n\n        function f(G) {\n          return G.type === \"value-func\" && G.value.toLowerCase() === \"url\";\n        }\n\n        function h(G, z) {\n          var U;\n          let le = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;\n          return le && le.indexOf(z) === le.length - 1;\n        }\n\n        function w(G) {\n          let z = G.selector;\n          return z ? typeof z == \"string\" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : !1;\n        }\n\n        function T(G) {\n          return G.type === \"value-word\" && [\"from\", \"through\", \"end\"].includes(G.value);\n        }\n\n        function A(G) {\n          return G.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(G.value);\n        }\n\n        function S(G) {\n          return G.type === \"value-word\" && G.value === \"in\";\n        }\n\n        function B(G) {\n          return G.type === \"value-operator\" && G.value === \"*\";\n        }\n\n        function I(G) {\n          return G.type === \"value-operator\" && G.value === \"/\";\n        }\n\n        function k(G) {\n          return G.type === \"value-operator\" && G.value === \"+\";\n        }\n\n        function P(G) {\n          return G.type === \"value-operator\" && G.value === \"-\";\n        }\n\n        function C(G) {\n          return G.type === \"value-operator\" && G.value === \"%\";\n        }\n\n        function D(G) {\n          return B(G) || I(G) || k(G) || P(G) || C(G);\n        }\n\n        function g(G) {\n          return G.type === \"value-word\" && [\"==\", \"!=\"].includes(G.value);\n        }\n\n        function F(G) {\n          return G.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(G.value);\n        }\n\n        function l(G) {\n          return G.type === \"css-atrule\" && [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(G.name);\n        }\n\n        function E(G) {\n          var z;\n          return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\\(\\s*\\)$/.test(G.raws.params);\n        }\n\n        function y(G) {\n          return G.name.startsWith(\"prettier-placeholder\");\n        }\n\n        function N(G) {\n          return G.prop.startsWith(\"@prettier-placeholder\");\n        }\n\n        function x(G, z) {\n          return G.value === \"$$\" && G.type === \"value-func\" && (z == null ? void 0 : z.type) === \"value-word\" && !z.raws.before;\n        }\n\n        function b(G) {\n          var z, U;\n          return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === \"value-root\" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === \"value-value\" && G.prop.toLowerCase() === \"composes\";\n        }\n\n        function L(G) {\n          var z, U, le;\n          return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le = U.group) === null || le === void 0 ? void 0 : le.type) === \"value-paren_group\" && G.value.group.group.open !== null && G.value.group.group.close !== null;\n        }\n\n        function M(G) {\n          var z;\n          return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === \"\";\n        }\n\n        function j(G) {\n          var z, U;\n          return G.type === \"value-comma_group\" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === \"value-colon\";\n        }\n\n        function $(G) {\n          var z;\n          return G.type === \"value-paren_group\" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);\n        }\n\n        function V(G) {\n          var z;\n          let U = G.getValue();\n          if (U.groups.length === 0) return !1;\n          let le = G.getParentNode(1);\n          if (!$(U) && !(le && $(le))) return !1;\n          let ge = a(G, \"css-decl\");\n          return !!(ge != null && (z = ge.prop) !== null && z !== void 0 && z.startsWith(\"$\") || $(le) || le.type === \"value-func\");\n        }\n\n        function q(G) {\n          return G.type === \"value-comment\" && G.inline;\n        }\n\n        function Y(G) {\n          return G.type === \"value-word\" && G.value === \"#\";\n        }\n\n        function H(G) {\n          return G.type === \"value-word\" && G.value === \"{\";\n        }\n\n        function R(G) {\n          return G.type === \"value-word\" && G.value === \"}\";\n        }\n\n        function Q(G) {\n          return [\"value-word\", \"value-atword\"].includes(G.type);\n        }\n\n        function ee(G) {\n          return (G == null ? void 0 : G.type) === \"value-colon\";\n        }\n\n        function te(G, z) {\n          if (!j(z)) return !1;\n          let U = z.groups,\n              le = U.indexOf(G);\n          return le === -1 ? !1 : ee(U[le + 1]);\n        }\n\n        function oe(G) {\n          return G.value && [\"not\", \"and\", \"or\"].includes(G.value.toLowerCase());\n        }\n\n        function W(G) {\n          return G.type !== \"value-func\" ? !1 : t.has(G.value.toLowerCase());\n        }\n\n        function X(G) {\n          return /\\/\\//.test(G.split(/[\\n\\r]/).pop());\n        }\n\n        function ue(G) {\n          return (G == null ? void 0 : G.type) === \"value-atword\" && G.value.startsWith(\"prettier-placeholder-\");\n        }\n\n        function De(G, z) {\n          var U, le;\n          if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== \"(\" || ((le = G.close) === null || le === void 0 ? void 0 : le.value) !== \")\" || G.groups.some(ge => ge.type !== \"value-comma_group\")) return !1;\n\n          if (z.type === \"value-comma_group\") {\n            let ge = z.groups.indexOf(G) - 1,\n                Ae = z.groups[ge];\n            if ((Ae == null ? void 0 : Ae.type) === \"value-word\" && Ae.value === \"with\") return !0;\n          }\n\n          return !1;\n        }\n\n        function ie(G) {\n          var z, U;\n          return G.type === \"value-paren_group\" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === \"(\" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === \")\";\n        }\n\n        n.exports = {\n          getAncestorCounter: s,\n          getAncestorNode: a,\n          getPropOfDeclNode: r,\n          maybeToLowerCase: c,\n          insideValueFunctionNode: v,\n          insideICSSRuleNode: m,\n          insideAtRuleNode: d,\n          insideURLFunctionInImportAtRuleNode: p,\n          isKeyframeAtRuleKeywords: o,\n          isWideKeywords: i,\n          isLastNode: h,\n          isSCSSControlDirectiveNode: l,\n          isDetachedRulesetDeclarationNode: w,\n          isRelationalOperatorNode: F,\n          isEqualityOperatorNode: g,\n          isMultiplicationNode: B,\n          isDivisionNode: I,\n          isAdditionNode: k,\n          isSubtractionNode: P,\n          isModuloNode: C,\n          isMathOperatorNode: D,\n          isEachKeywordNode: S,\n          isForKeywordNode: T,\n          isURLFunctionNode: f,\n          isIfElseKeywordNode: A,\n          hasComposesNode: b,\n          hasParensAroundNode: L,\n          hasEmptyRawBefore: M,\n          isDetachedRulesetCallNode: E,\n          isTemplatePlaceholderNode: y,\n          isTemplatePropNode: N,\n          isPostcssSimpleVarNode: x,\n          isKeyValuePairNode: j,\n          isKeyValuePairInParenGroupNode: $,\n          isKeyInValuePairNode: te,\n          isSCSSMapItemNode: V,\n          isInlineValueCommentNode: q,\n          isHashNode: Y,\n          isLeftCurlyBraceNode: H,\n          isRightCurlyBraceNode: R,\n          isWordNode: Q,\n          isColonNode: ee,\n          isMediaAndSupportsKeywords: oe,\n          isColorAdjusterFuncNode: W,\n          lastLineHasInlineComment: X,\n          isAtWordPlaceholderNode: ue,\n          isConfigurationNode: De,\n          isParenGroupNode: ie\n        };\n      }\n\n    }),\n        pd = Z({\n      \"src/utils/line-column-to-index.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = function (t, s) {\n          let a = 0;\n\n          for (let r = 0; r < t.line - 1; ++r) a = s.indexOf(\"\\n\", a) + 1;\n\n          return a + t.column;\n        };\n      }\n\n    }),\n        fd = Z({\n      \"src/language-css/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Nr4 = Nr(),\n            t = _Nr4.skipEverythingButNewLine,\n            s = it(),\n            a = pd();\n\n        function r(p, f) {\n          return typeof p.sourceIndex == \"number\" ? p.sourceIndex : p.source ? a(p.source.start, f) - 1 : null;\n        }\n\n        function u(p, f) {\n          if (p.type === \"css-comment\" && p.inline) return t(f, p.source.startOffset);\n          let h = p.nodes && s(p.nodes);\n          return h && p.source && !p.source.end && (p = h), p.source && p.source.end ? a(p.source.end, f) : null;\n        }\n\n        function i(p, f) {\n          p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));\n\n          for (let h in p) {\n            let w = p[h];\n            h === \"source\" || !w || typeof w != \"object\" || (w.type === \"value-root\" || w.type === \"value-unknown\" ? o(w, c(p), w.text || w.value) : i(w, f));\n          }\n        }\n\n        function o(p, f, h) {\n          p.source && (p.source.startOffset = r(p, h) + f, p.source.endOffset = u(p, h) + f);\n\n          for (let w in p) {\n            let T = p[w];\n            w === \"source\" || !T || typeof T != \"object\" || o(T, f, h);\n          }\n        }\n\n        function c(p) {\n          let f = p.source.startOffset;\n          return typeof p.prop == \"string\" && (f += p.prop.length), p.type === \"css-atrule\" && typeof p.name == \"string\" && (f += 1 + p.name.length + p.raws.afterName.match(/^\\s*:?\\s*/)[0].length), p.type !== \"css-atrule\" && p.raws && typeof p.raws.between == \"string\" && (f += p.raws.between.length), f;\n        }\n\n        function v(p) {\n          let f = \"initial\",\n              h = \"initial\",\n              w,\n              T = !1,\n              A = [];\n\n          for (let S = 0; S < p.length; S++) {\n            let B = p[S];\n\n            switch (f) {\n              case \"initial\":\n                if (B === \"'\") {\n                  f = \"single-quotes\";\n                  continue;\n                }\n\n                if (B === '\"') {\n                  f = \"double-quotes\";\n                  continue;\n                }\n\n                if ((B === \"u\" || B === \"U\") && p.slice(S, S + 4).toLowerCase() === \"url(\") {\n                  f = \"url\", S += 3;\n                  continue;\n                }\n\n                if (B === \"*\" && p[S - 1] === \"/\") {\n                  f = \"comment-block\";\n                  continue;\n                }\n\n                if (B === \"/\" && p[S - 1] === \"/\") {\n                  f = \"comment-inline\", w = S - 1;\n                  continue;\n                }\n\n                continue;\n\n              case \"single-quotes\":\n                if (B === \"'\" && p[S - 1] !== \"\\\\\" && (f = h, h = \"initial\"), B === \"\\n\" || B === \"\\r\") return p;\n                continue;\n\n              case \"double-quotes\":\n                if (B === '\"' && p[S - 1] !== \"\\\\\" && (f = h, h = \"initial\"), B === \"\\n\" || B === \"\\r\") return p;\n                continue;\n\n              case \"url\":\n                if (B === \")\" && (f = \"initial\"), B === \"\\n\" || B === \"\\r\") return p;\n\n                if (B === \"'\") {\n                  f = \"single-quotes\", h = \"url\";\n                  continue;\n                }\n\n                if (B === '\"') {\n                  f = \"double-quotes\", h = \"url\";\n                  continue;\n                }\n\n                continue;\n\n              case \"comment-block\":\n                B === \"/\" && p[S - 1] === \"*\" && (f = \"initial\");\n                continue;\n\n              case \"comment-inline\":\n                (B === '\"' || B === \"'\" || B === \"*\") && (T = !0), (B === \"\\n\" || B === \"\\r\") && (T && A.push([w, S]), f = \"initial\", T = !1);\n                continue;\n            }\n          }\n\n          for (let _ref35 of A) {\n            var _ref36 = _slicedToArray(_ref35, 2);\n\n            let S = _ref36[0];\n            let B = _ref36[1];\n            p = p.slice(0, S) + p.slice(S, B).replace(/[\"'*]/g, \" \") + p.slice(B);\n          }\n\n          return p;\n        }\n\n        function m(p) {\n          return p.source.startOffset;\n        }\n\n        function d(p) {\n          return p.source.endOffset;\n        }\n\n        n.exports = {\n          locStart: m,\n          locEnd: d,\n          calculateLoc: i,\n          replaceQuotesInInlineComments: v\n        };\n      }\n\n    }),\n        Dd = Z({\n      \"src/language-css/utils/is-less-parser.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s) {\n          return s.parser === \"css\" || s.parser === \"less\";\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        md = Z({\n      \"src/language-css/utils/is-scss.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a) {\n          return s === \"less\" || s === \"scss\" ? s === \"scss\" : /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/.test(a);\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        dd = Z({\n      \"src/language-css/utils/css-units.evaluate.js\"(e, n) {\n        n.exports = {\n          em: \"em\",\n          rem: \"rem\",\n          ex: \"ex\",\n          rex: \"rex\",\n          cap: \"cap\",\n          rcap: \"rcap\",\n          ch: \"ch\",\n          rch: \"rch\",\n          ic: \"ic\",\n          ric: \"ric\",\n          lh: \"lh\",\n          rlh: \"rlh\",\n          vw: \"vw\",\n          svw: \"svw\",\n          lvw: \"lvw\",\n          dvw: \"dvw\",\n          vh: \"vh\",\n          svh: \"svh\",\n          lvh: \"lvh\",\n          dvh: \"dvh\",\n          vi: \"vi\",\n          svi: \"svi\",\n          lvi: \"lvi\",\n          dvi: \"dvi\",\n          vb: \"vb\",\n          svb: \"svb\",\n          lvb: \"lvb\",\n          dvb: \"dvb\",\n          vmin: \"vmin\",\n          svmin: \"svmin\",\n          lvmin: \"lvmin\",\n          dvmin: \"dvmin\",\n          vmax: \"vmax\",\n          svmax: \"svmax\",\n          lvmax: \"lvmax\",\n          dvmax: \"dvmax\",\n          cm: \"cm\",\n          mm: \"mm\",\n          q: \"Q\",\n          in: \"in\",\n          pt: \"pt\",\n          pc: \"pc\",\n          px: \"px\",\n          deg: \"deg\",\n          grad: \"grad\",\n          rad: \"rad\",\n          turn: \"turn\",\n          s: \"s\",\n          ms: \"ms\",\n          hz: \"Hz\",\n          khz: \"kHz\",\n          dpi: \"dpi\",\n          dpcm: \"dpcm\",\n          dppx: \"dppx\",\n          x: \"x\"\n        };\n      }\n\n    }),\n        gd = Z({\n      \"src/language-css/utils/print-unit.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = dd();\n\n        function s(a) {\n          let r = a.toLowerCase();\n          return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;\n        }\n\n        n.exports = s;\n      }\n\n    }),\n        yd = Z({\n      \"src/language-css/printer-postcss.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = it(),\n            _Ue33 = Ue(),\n            s = _Ue33.printNumber,\n            a = _Ue33.printString,\n            r = _Ue33.hasNewline,\n            u = _Ue33.isFrontMatterNode,\n            i = _Ue33.isNextLineEmpty,\n            o = _Ue33.isNonEmptyArray,\n            _Oe40 = Oe(),\n            _Oe40$builders = _Oe40.builders,\n            c = _Oe40$builders.join,\n            v = _Oe40$builders.line,\n            m = _Oe40$builders.hardline,\n            d = _Oe40$builders.softline,\n            p = _Oe40$builders.group,\n            f = _Oe40$builders.fill,\n            h = _Oe40$builders.indent,\n            w = _Oe40$builders.dedent,\n            T = _Oe40$builders.ifBreak,\n            A = _Oe40$builders.breakParent,\n            _Oe40$utils = _Oe40.utils,\n            S = _Oe40$utils.removeLines,\n            B = _Oe40$utils.getDocParts,\n            I = ad(),\n            k = od(),\n            _ld = ld(),\n            P = _ld.insertPragma,\n            _cd = cd(),\n            C = _cd.getAncestorNode,\n            D = _cd.getPropOfDeclNode,\n            g = _cd.maybeToLowerCase,\n            F = _cd.insideValueFunctionNode,\n            l = _cd.insideICSSRuleNode,\n            E = _cd.insideAtRuleNode,\n            y = _cd.insideURLFunctionInImportAtRuleNode,\n            N = _cd.isKeyframeAtRuleKeywords,\n            x = _cd.isWideKeywords,\n            b = _cd.isLastNode,\n            L = _cd.isSCSSControlDirectiveNode,\n            M = _cd.isDetachedRulesetDeclarationNode,\n            j = _cd.isRelationalOperatorNode,\n            $ = _cd.isEqualityOperatorNode,\n            V = _cd.isMultiplicationNode,\n            q = _cd.isDivisionNode,\n            Y = _cd.isAdditionNode,\n            H = _cd.isSubtractionNode,\n            R = _cd.isMathOperatorNode,\n            Q = _cd.isEachKeywordNode,\n            ee = _cd.isForKeywordNode,\n            te = _cd.isURLFunctionNode,\n            oe = _cd.isIfElseKeywordNode,\n            W = _cd.hasComposesNode,\n            X = _cd.hasParensAroundNode,\n            ue = _cd.hasEmptyRawBefore,\n            De = _cd.isKeyValuePairNode,\n            ie = _cd.isKeyInValuePairNode,\n            G = _cd.isDetachedRulesetCallNode,\n            z = _cd.isTemplatePlaceholderNode,\n            U = _cd.isTemplatePropNode,\n            le = _cd.isPostcssSimpleVarNode,\n            ge = _cd.isSCSSMapItemNode,\n            Ae = _cd.isInlineValueCommentNode,\n            Ne = _cd.isHashNode,\n            ke = _cd.isLeftCurlyBraceNode,\n            ce = _cd.isRightCurlyBraceNode,\n            pe = _cd.isWordNode,\n            de = _cd.isColonNode,\n            ae = _cd.isMediaAndSupportsKeywords,\n            ve = _cd.isColorAdjusterFuncNode,\n            K = _cd.lastLineHasInlineComment,\n            he = _cd.isAtWordPlaceholderNode,\n            ye = _cd.isConfigurationNode,\n            Ce = _cd.isParenGroupNode,\n            _fd = fd(),\n            Ie = _fd.locStart,\n            Fe = _fd.locEnd,\n            me = Dd(),\n            _ = md(),\n            J = gd();\n\n        function ne(be) {\n          return be.trailingComma === \"es5\" || be.trailingComma === \"all\";\n        }\n\n        function Ee(be, Le, qe) {\n          let se = be.getValue();\n          if (!se) return \"\";\n          if (typeof se == \"string\") return se;\n\n          switch (se.type) {\n            case \"front-matter\":\n              return [se.raw, m];\n\n            case \"css-root\":\n              {\n                let He = We(be, Le, qe),\n                    Me = se.raws.after.trim();\n                return [He, Me ? \" \".concat(Me) : \"\", B(He).length > 0 ? m : \"\"];\n              }\n\n            case \"css-comment\":\n              {\n                let He = se.inline || se.raws.inline,\n                    Me = Le.originalText.slice(Ie(se), Fe(se));\n                return He ? Me.trimEnd() : Me;\n              }\n\n            case \"css-rule\":\n              return [qe(\"selector\"), se.important ? \" !important\" : \"\", se.nodes ? [se.selector && se.selector.type === \"selector-unknown\" && K(se.selector.value) ? v : \" \", \"{\", se.nodes.length > 0 ? h([m, We(be, Le, qe)]) : \"\", m, \"}\", M(se) ? \";\" : \"\"] : \";\"];\n\n            case \"css-decl\":\n              {\n                let He = be.getParentNode(),\n                    Me = se.raws.between,\n                    ze = Me.trim(),\n                    nt = ze === \":\",\n                    tt = W(se) ? S(qe(\"value\")) : qe(\"value\");\n                return !nt && K(ze) && (tt = h([m, w(tt)])), [se.raws.before.replace(/[\\s;]/g, \"\"), l(be) ? se.prop : g(se.prop), ze.startsWith(\"//\") ? \" \" : \"\", ze, se.extend ? \"\" : \" \", me(Le) && se.extend && se.selector ? [\"extend(\", qe(\"selector\"), \")\"] : \"\", tt, se.raws.important ? se.raws.important.replace(/\\s*!\\s*important/i, \" !important\") : se.important ? \" !important\" : \"\", se.raws.scssDefault ? se.raws.scssDefault.replace(/\\s*!default/i, \" !default\") : se.scssDefault ? \" !default\" : \"\", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\\s*!global/i, \" !global\") : se.scssGlobal ? \" !global\" : \"\", se.nodes ? [\" {\", h([d, We(be, Le, qe)]), d, \"}\"] : U(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== \";\" ? \"\" : Le.__isHTMLStyleAttribute && b(be, se) ? T(\";\") : \";\"];\n              }\n\n            case \"css-atrule\":\n              {\n                let He = be.getParentNode(),\n                    Me = z(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== \";\";\n\n                if (me(Le)) {\n                  if (se.mixin) return [qe(\"selector\"), se.important ? \" !important\" : \"\", Me ? \"\" : \";\"];\n                  if (se.function) return [se.name, qe(\"params\"), Me ? \"\" : \";\"];\n                  if (se.variable) return [\"@\", se.name, \": \", se.value ? qe(\"value\") : \"\", se.raws.between.trim() ? se.raws.between.trim() + \" \" : \"\", se.nodes ? [\"{\", h([se.nodes.length > 0 ? d : \"\", We(be, Le, qe)]), d, \"}\"] : \"\", Me ? \"\" : \";\"];\n                }\n\n                return [\"@\", G(se) || se.name.endsWith(\":\") ? se.name : g(se.name), se.params ? [G(se) ? \"\" : z(se) ? se.raws.afterName === \"\" ? \"\" : se.name.endsWith(\":\") ? \" \" : /^\\s*\\n\\s*\\n/.test(se.raws.afterName) ? [m, m] : /^\\s*\\n/.test(se.raws.afterName) ? m : \" \" : \" \", qe(\"params\")] : \"\", se.selector ? h([\" \", qe(\"selector\")]) : \"\", se.value ? p([\" \", qe(\"value\"), L(se) ? X(se) ? \" \" : v : \"\"]) : se.name === \"else\" ? \" \" : \"\", se.nodes ? [L(se) ? \"\" : se.selector && !se.selector.nodes && typeof se.selector.value == \"string\" && K(se.selector.value) || !se.selector && typeof se.params == \"string\" && K(se.params) ? v : \" \", \"{\", h([se.nodes.length > 0 ? d : \"\", We(be, Le, qe)]), d, \"}\"] : Me ? \"\" : \";\"];\n              }\n\n            case \"media-query-list\":\n              {\n                let He = [];\n                return be.each(Me => {\n                  let ze = Me.getValue();\n                  ze.type === \"media-query\" && ze.value === \"\" || He.push(qe());\n                }, \"nodes\"), p(h(c(v, He)));\n              }\n\n            case \"media-query\":\n              return [c(\" \", be.map(qe, \"nodes\")), b(be, se) ? \"\" : \",\"];\n\n            case \"media-type\":\n              return je(Xe(se.value, Le));\n\n            case \"media-feature-expression\":\n              return se.nodes ? [\"(\", ...be.map(qe, \"nodes\"), \")\"] : se.value;\n\n            case \"media-feature\":\n              return g(Xe(se.value.replace(/ +/g, \" \"), Le));\n\n            case \"media-colon\":\n              return [se.value, \" \"];\n\n            case \"media-value\":\n              return je(Xe(se.value, Le));\n\n            case \"media-keyword\":\n              return Xe(se.value, Le);\n\n            case \"media-url\":\n              return Xe(se.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/g, \")\"), Le);\n\n            case \"media-unknown\":\n              return se.value;\n\n            case \"selector-root\":\n              return p([E(be, \"custom-selector\") ? [C(be, \"css-atrule\").customSelector, v] : \"\", c([\",\", E(be, [\"extend\", \"custom-selector\", \"nest\"]) ? v : m], be.map(qe, \"nodes\"))]);\n\n            case \"selector-selector\":\n              return p(h(be.map(qe, \"nodes\")));\n\n            case \"selector-comment\":\n              return se.value;\n\n            case \"selector-string\":\n              return Xe(se.value, Le);\n\n            case \"selector-tag\":\n              {\n                let He = be.getParentNode(),\n                    Me = He && He.nodes.indexOf(se),\n                    ze = Me && He.nodes[Me - 1];\n                return [se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", ze.type === \"selector-nesting\" ? se.value : je(N(be, se.value) ? se.value.toLowerCase() : se.value)];\n              }\n\n            case \"selector-id\":\n              return [\"#\", se.value];\n\n            case \"selector-class\":\n              return [\".\", je(Xe(se.value, Le))];\n\n            case \"selector-attribute\":\n              return [\"[\", se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", se.attribute.trim(), se.operator ? se.operator : \"\", se.value ? _e(Xe(se.value.trim(), Le), Le) : \"\", se.insensitive ? \" i\" : \"\", \"]\"];\n\n            case \"selector-combinator\":\n              {\n                if (se.value === \"+\" || se.value === \">\" || se.value === \"~\" || se.value === \">>>\") {\n                  let ze = be.getParentNode();\n                  return [ze.type === \"selector-selector\" && ze.nodes[0] === se ? \"\" : v, se.value, b(be, se) ? \"\" : \" \"];\n                }\n\n                let He = se.value.trim().startsWith(\"(\") ? v : \"\",\n                    Me = je(Xe(se.value.trim(), Le)) || v;\n                return [He, Me];\n              }\n\n            case \"selector-universal\":\n              return [se.namespace ? [se.namespace === !0 ? \"\" : se.namespace.trim(), \"|\"] : \"\", se.value];\n\n            case \"selector-pseudo\":\n              return [g(se.value), o(se.nodes) ? [\"(\", c(\", \", be.map(qe, \"nodes\")), \")\"] : \"\"];\n\n            case \"selector-nesting\":\n              return se.value;\n\n            case \"selector-unknown\":\n              {\n                let He = C(be, \"css-rule\");\n                if (He && He.isSCSSNesterProperty) return je(Xe(g(se.value), Le));\n                let Me = be.getParentNode();\n\n                if (Me.raws && Me.raws.selector) {\n                  let nt = Ie(Me),\n                      tt = nt + Me.raws.selector.length;\n                  return Le.originalText.slice(nt, tt).trim();\n                }\n\n                let ze = be.getParentNode(1);\n\n                if (Me.type === \"value-paren_group\" && ze && ze.type === \"value-func\" && ze.value === \"selector\") {\n                  let nt = Fe(Me.open) + 1,\n                      tt = Ie(Me.close),\n                      pt = Le.originalText.slice(nt, tt).trim();\n                  return K(pt) ? [A, pt] : pt;\n                }\n\n                return se.value;\n              }\n\n            case \"value-value\":\n            case \"value-root\":\n              return qe(\"group\");\n\n            case \"value-comment\":\n              return Le.originalText.slice(Ie(se), Fe(se));\n\n            case \"value-comma_group\":\n              {\n                let He = be.getParentNode(),\n                    Me = be.getParentNode(1),\n                    ze = D(be),\n                    nt = ze && He.type === \"value-value\" && (ze === \"grid\" || ze.startsWith(\"grid-template\")),\n                    tt = C(be, \"css-atrule\"),\n                    pt = tt && L(tt),\n                    O = se.groups.some(ut => Ae(ut)),\n                    fe = be.map(qe, \"groups\"),\n                    Te = [],\n                    $e = F(be, \"url\"),\n                    Je = !1,\n                    Ze = !1;\n\n                for (let ut = 0; ut < se.groups.length; ++ut) {\n                  Te.push(fe[ut]);\n                  let rt = se.groups[ut - 1],\n                      Ve = se.groups[ut],\n                      Ge = se.groups[ut + 1],\n                      tr = se.groups[ut + 2];\n\n                  if ($e) {\n                    (Ge && Y(Ge) || Y(Ve)) && Te.push(\" \");\n                    continue;\n                  }\n\n                  if (E(be, \"forward\") && Ve.type === \"value-word\" && Ve.value && rt !== void 0 && rt.type === \"value-word\" && rt.value === \"as\" && Ge.type === \"value-operator\" && Ge.value === \"*\" || !Ge || Ve.type === \"value-word\" && Ve.value.endsWith(\"-\") && he(Ge)) continue;\n                  let Eo = Ve.type === \"value-string\" && Ve.value.startsWith(\"#{\"),\n                      Fo = Je && Ge.type === \"value-string\" && Ge.value.endsWith(\"}\");\n\n                  if (Eo || Fo) {\n                    Je = !Je;\n                    continue;\n                  }\n\n                  if (Je || de(Ve) || de(Ge) || Ve.type === \"value-atword\" && Ve.value === \"\" || Ve.value === \"~\" || Ve.value && Ve.value.includes(\"\\\\\") && Ge && Ge.type !== \"value-comment\" || rt && rt.value && rt.value.indexOf(\"\\\\\") === rt.value.length - 1 && Ve.type === \"value-operator\" && Ve.value === \"/\" || Ve.value === \"\\\\\" || le(Ve, Ge) || Ne(Ve) || ke(Ve) || ce(Ge) || ke(Ge) && ue(Ge) || ce(Ve) && ue(Ge) || Ve.value === \"--\" && Ne(Ge)) continue;\n                  let Qn = R(Ve),\n                      Zn = R(Ge);\n                  if ((Qn && Ne(Ge) || Zn && ce(Ve)) && ue(Ge) || !rt && q(Ve) || F(be, \"calc\") && (Y(Ve) || Y(Ge) || H(Ve) || H(Ge)) && ue(Ge)) continue;\n                  let Ao = (Y(Ve) || H(Ve)) && ut === 0 && (Ge.type === \"value-number\" || Ge.isHex) && Me && ve(Me) && !ue(Ge),\n                      eu = tr && tr.type === \"value-func\" || tr && pe(tr) || Ve.type === \"value-func\" || pe(Ve),\n                      tu = Ge.type === \"value-func\" || pe(Ge) || rt && rt.type === \"value-func\" || rt && pe(rt);\n\n                  if (!(!(V(Ge) || V(Ve)) && !F(be, \"calc\") && !Ao && (q(Ge) && !eu || q(Ve) && !tu || Y(Ge) && !eu || Y(Ve) && !tu || H(Ge) || H(Ve)) && (ue(Ge) || Qn && (!rt || rt && R(rt))))) {\n                    if (Ae(Ve)) {\n                      if (He.type === \"value-paren_group\") {\n                        Te.push(w(m));\n                        continue;\n                      }\n\n                      Te.push(m);\n                      continue;\n                    }\n\n                    if (pt && ($(Ge) || j(Ge) || oe(Ge) || Q(Ve) || ee(Ve))) {\n                      Te.push(\" \");\n                      continue;\n                    }\n\n                    if (tt && tt.name.toLowerCase() === \"namespace\") {\n                      Te.push(\" \");\n                      continue;\n                    }\n\n                    if (nt) {\n                      Ve.source && Ge.source && Ve.source.start.line !== Ge.source.start.line ? (Te.push(m), Ze = !0) : Te.push(\" \");\n                      continue;\n                    }\n\n                    if (Zn) {\n                      Te.push(\" \");\n                      continue;\n                    }\n\n                    if (!(Ge && Ge.value === \"...\") && !(he(Ve) && he(Ge) && Fe(Ve) === Ie(Ge))) {\n                      if (he(Ve) && Ce(Ge) && Fe(Ve) === Ie(Ge.open)) {\n                        Te.push(d);\n                        continue;\n                      }\n\n                      if (Ve.value === \"with\" && Ce(Ge)) {\n                        Te.push(\" \");\n                        continue;\n                      }\n\n                      Te.push(v);\n                    }\n                  }\n                }\n\n                return O && Te.push(A), Ze && Te.unshift(m), pt ? p(h(Te)) : y(be) ? p(f(Te)) : p(h(f(Te)));\n              }\n\n            case \"value-paren_group\":\n              {\n                let He = be.getParentNode();\n                if (He && te(He) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === \"value-comma_group\" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === \"value-word\" && se.groups[0].groups[0].value.startsWith(\"data:\"))) return [se.open ? qe(\"open\") : \"\", c(\",\", be.map(qe, \"groups\")), se.close ? qe(\"close\") : \"\"];\n\n                if (!se.open) {\n                  let $e = be.map(qe, \"groups\"),\n                      Je = [];\n\n                  for (let Ze = 0; Ze < $e.length; Ze++) Ze !== 0 && Je.push([\",\", v]), Je.push($e[Ze]);\n\n                  return p(h(f(Je)));\n                }\n\n                let Me = ge(be),\n                    ze = t(se.groups),\n                    nt = ze && ze.type === \"value-comment\",\n                    tt = ie(se, He),\n                    pt = ye(se, He),\n                    O = pt || Me && !tt,\n                    fe = pt || tt,\n                    Te = p([se.open ? qe(\"open\") : \"\", h([d, c([v], be.map(($e, Je) => {\n                  let Ze = $e.getValue(),\n                      ut = Je === se.groups.length - 1,\n                      rt = [qe(), ut ? \"\" : \",\"];\n\n                  if (De(Ze) && Ze.type === \"value-comma_group\" && Ze.groups && Ze.groups[0].type !== \"value-paren_group\" && Ze.groups[2] && Ze.groups[2].type === \"value-paren_group\") {\n                    let Ve = B(rt[0].contents.contents);\n                    return Ve[1] = p(Ve[1]), p(w(rt));\n                  }\n\n                  if (!ut && Ze.type === \"value-comma_group\" && o(Ze.groups)) {\n                    let Ve = t(Ze.groups);\n                    Ve.source && i(Le.originalText, Ve, Fe) && rt.push(m);\n                  }\n\n                  return rt;\n                }, \"groups\"))]), T(!nt && _(Le.parser, Le.originalText) && Me && ne(Le) ? \",\" : \"\"), d, se.close ? qe(\"close\") : \"\"], {\n                  shouldBreak: O\n                });\n                return fe ? w(Te) : Te;\n              }\n\n            case \"value-func\":\n              return [se.value, E(be, \"supports\") && ae(se) ? \" \" : \"\", qe(\"group\")];\n\n            case \"value-paren\":\n              return se.value;\n\n            case \"value-number\":\n              return [Re(se.value), J(se.unit)];\n\n            case \"value-operator\":\n              return se.value;\n\n            case \"value-word\":\n              return se.isColor && se.isHex || x(se.value) ? se.value.toLowerCase() : se.value;\n\n            case \"value-colon\":\n              {\n                let He = be.getParentNode(),\n                    Me = He && He.groups.indexOf(se),\n                    ze = Me && He.groups[Me - 1];\n                return [se.value, ze && typeof ze.value == \"string\" && t(ze.value) === \"\\\\\" || F(be, \"url\") ? \"\" : v];\n              }\n\n            case \"value-comma\":\n              return [se.value, \" \"];\n\n            case \"value-string\":\n              return a(se.raws.quote + se.value + se.raws.quote, Le);\n\n            case \"value-atword\":\n              return [\"@\", se.value];\n\n            case \"value-unicode-range\":\n              return se.value;\n\n            case \"value-unknown\":\n              return se.value;\n\n            default:\n              throw new Error(\"Unknown postcss type \".concat(JSON.stringify(se.type)));\n          }\n        }\n\n        function We(be, Le, qe) {\n          let se = [];\n          return be.each((He, Me, ze) => {\n            let nt = ze[Me - 1];\n\n            if (nt && nt.type === \"css-comment\" && nt.text.trim() === \"prettier-ignore\") {\n              let tt = He.getValue();\n              se.push(Le.originalText.slice(Ie(tt), Fe(tt)));\n            } else se.push(qe());\n\n            Me !== ze.length - 1 && (ze[Me + 1].type === \"css-comment\" && !r(Le.originalText, Ie(ze[Me + 1]), {\n              backwards: !0\n            }) && !u(ze[Me]) || ze[Me + 1].type === \"css-atrule\" && ze[Me + 1].name === \"else\" && ze[Me].type !== \"css-comment\" ? se.push(\" \") : (se.push(Le.__isHTMLStyleAttribute ? v : m), i(Le.originalText, He.getValue(), Fe) && !u(ze[Me]) && se.push(m)));\n          }, \"nodes\"), se;\n        }\n\n        var Be = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs,\n            Pe = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g,\n            Se = /[A-Za-z]+/g,\n            Qe = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g,\n            xe = new RegExp(Be.source + \"|(\".concat(Qe.source, \")?(\").concat(Pe.source, \")(\").concat(Se.source, \")?\"), \"g\");\n\n        function Xe(be, Le) {\n          return be.replace(Be, qe => a(qe, Le));\n        }\n\n        function _e(be, Le) {\n          let qe = Le.singleQuote ? \"'\" : '\"';\n          return be.includes('\"') || be.includes(\"'\") ? be : qe + be + qe;\n        }\n\n        function je(be) {\n          return be.replace(xe, (Le, qe, se, He, Me) => !se && He ? Re(He) + g(Me || \"\") : Le);\n        }\n\n        function Re(be) {\n          return s(be).replace(/\\.0(?=$|e)/, \"\");\n        }\n\n        n.exports = {\n          print: Ee,\n          embed: k,\n          insertPragma: P,\n          massageAstNode: I\n        };\n      }\n\n    }),\n        hd = Z({\n      \"src/language-css/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot();\n        n.exports = {\n          singleQuote: t.singleQuote\n        };\n      }\n\n    }),\n        vd = Z({\n      \"src/language-css/parsers.js\"() {\n        re();\n      }\n\n    }),\n        Cd = Z({\n      \"node_modules/linguist-languages/data/CSS.json\"(e, n) {\n        n.exports = {\n          name: \"CSS\",\n          type: \"markup\",\n          tmScope: \"source.css\",\n          aceMode: \"css\",\n          codemirrorMode: \"css\",\n          codemirrorMimeType: \"text/css\",\n          color: \"#563d7c\",\n          extensions: [\".css\"],\n          languageId: 50\n        };\n      }\n\n    }),\n        Ed = Z({\n      \"node_modules/linguist-languages/data/PostCSS.json\"(e, n) {\n        n.exports = {\n          name: \"PostCSS\",\n          type: \"markup\",\n          color: \"#dc3a0c\",\n          tmScope: \"source.postcss\",\n          group: \"CSS\",\n          extensions: [\".pcss\", \".postcss\"],\n          aceMode: \"text\",\n          languageId: 262764437\n        };\n      }\n\n    }),\n        Fd = Z({\n      \"node_modules/linguist-languages/data/Less.json\"(e, n) {\n        n.exports = {\n          name: \"Less\",\n          type: \"markup\",\n          color: \"#1d365d\",\n          aliases: [\"less-css\"],\n          extensions: [\".less\"],\n          tmScope: \"source.css.less\",\n          aceMode: \"less\",\n          codemirrorMode: \"css\",\n          codemirrorMimeType: \"text/css\",\n          languageId: 198\n        };\n      }\n\n    }),\n        Ad = Z({\n      \"node_modules/linguist-languages/data/SCSS.json\"(e, n) {\n        n.exports = {\n          name: \"SCSS\",\n          type: \"markup\",\n          color: \"#c6538c\",\n          tmScope: \"source.css.scss\",\n          aceMode: \"scss\",\n          codemirrorMode: \"css\",\n          codemirrorMimeType: \"text/x-scss\",\n          extensions: [\".scss\"],\n          languageId: 329\n        };\n      }\n\n    }),\n        Sd = Z({\n      \"src/language-css/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = yd(),\n            a = hd(),\n            r = vd(),\n            u = [t(Cd(), o => ({\n          since: \"1.4.0\",\n          parsers: [\"css\"],\n          vscodeLanguageIds: [\"css\"],\n          extensions: [...o.extensions, \".wxss\"]\n        })), t(Ed(), () => ({\n          since: \"1.4.0\",\n          parsers: [\"css\"],\n          vscodeLanguageIds: [\"postcss\"]\n        })), t(Fd(), () => ({\n          since: \"1.4.0\",\n          parsers: [\"less\"],\n          vscodeLanguageIds: [\"less\"]\n        })), t(Ad(), () => ({\n          since: \"1.4.0\",\n          parsers: [\"scss\"],\n          vscodeLanguageIds: [\"scss\"]\n        }))],\n            i = {\n          postcss: s\n        };\n        n.exports = {\n          languages: u,\n          options: a,\n          printers: i,\n          parsers: r\n        };\n      }\n\n    }),\n        xd = Z({\n      \"src/language-handlebars/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return a.loc.start.offset;\n        }\n\n        function s(a) {\n          return a.loc.end.offset;\n        }\n\n        n.exports = {\n          locStart: t,\n          locEnd: s\n        };\n      }\n\n    }),\n        bd = Z({\n      \"src/language-handlebars/clean.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a) {\n          if (s.type === \"TextNode\") {\n            let r = s.chars.trim();\n            if (!r) return null;\n            a.chars = r.replace(/[\\t\\n\\f\\r ]+/g, \" \");\n          }\n\n          s.type === \"AttrNode\" && s.name.toLowerCase() === \"class\" && delete a.value;\n        }\n\n        t.ignoredProperties = new Set([\"loc\", \"selfClosing\"]), n.exports = t;\n      }\n\n    }),\n        Td = Z({\n      \"vendors/html-void-elements.json\"(e, n) {\n        n.exports = {\n          htmlVoidElements: [\"area\", \"base\", \"basefont\", \"bgsound\", \"br\", \"col\", \"command\", \"embed\", \"frame\", \"hr\", \"image\", \"img\", \"input\", \"isindex\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"nextid\", \"param\", \"source\", \"track\", \"wbr\"]\n        };\n      }\n\n    }),\n        Bd = Z({\n      \"src/language-handlebars/utils.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Td = Td(),\n            t = _Td.htmlVoidElements,\n            s = it();\n\n        function a(S) {\n          let B = S.getValue(),\n              I = S.getParentNode(0);\n          return !!(m(S, [\"ElementNode\"]) && s(I.children) === B || m(S, [\"Block\"]) && s(I.body) === B);\n        }\n\n        function r(S) {\n          return S.toUpperCase() === S;\n        }\n\n        function u(S) {\n          return v(S, [\"ElementNode\"]) && typeof S.tag == \"string\" && !S.tag.startsWith(\":\") && (r(S.tag[0]) || S.tag.includes(\".\"));\n        }\n\n        var i = new Set(t);\n\n        function o(S) {\n          return i.has(S.tag) || u(S) && S.children.every(B => c(B));\n        }\n\n        function c(S) {\n          return v(S, [\"TextNode\"]) && !/\\S/.test(S.chars);\n        }\n\n        function v(S, B) {\n          return S && B.includes(S.type);\n        }\n\n        function m(S, B) {\n          let I = S.getParentNode(0);\n          return v(I, B);\n        }\n\n        function d(S, B) {\n          let I = h(S);\n          return v(I, B);\n        }\n\n        function p(S, B) {\n          let I = w(S);\n          return v(I, B);\n        }\n\n        function f(S, B) {\n          var I, k, P, C;\n          let D = S.getValue(),\n              g = (I = S.getParentNode(0)) !== null && I !== void 0 ? I : {},\n              F = (k = (P = (C = g.children) !== null && C !== void 0 ? C : g.body) !== null && P !== void 0 ? P : g.parts) !== null && k !== void 0 ? k : [],\n              l = F.indexOf(D);\n          return l !== -1 && F[l + B];\n        }\n\n        function h(S) {\n          let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n          return f(S, -B);\n        }\n\n        function w(S) {\n          return f(S, 1);\n        }\n\n        function T(S) {\n          return v(S, [\"MustacheCommentStatement\"]) && typeof S.value == \"string\" && S.value.trim() === \"prettier-ignore\";\n        }\n\n        function A(S) {\n          let B = S.getValue(),\n              I = h(S, 2);\n          return T(B) || T(I);\n        }\n\n        n.exports = {\n          getNextNode: w,\n          getPreviousNode: h,\n          hasPrettierIgnore: A,\n          isLastNodeOfSiblings: a,\n          isNextNodeOfSomeType: p,\n          isNodeOfSomeType: v,\n          isParentOfSomeType: m,\n          isPreviousNodeOfSomeType: d,\n          isVoid: o,\n          isWhitespaceNode: c\n        };\n      }\n\n    }),\n        Nd = Z({\n      \"src/language-handlebars/printer-glimmer.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe41 = Oe(),\n            _Oe41$builders = _Oe41.builders,\n            t = _Oe41$builders.dedent,\n            s = _Oe41$builders.fill,\n            a = _Oe41$builders.group,\n            r = _Oe41$builders.hardline,\n            u = _Oe41$builders.ifBreak,\n            i = _Oe41$builders.indent,\n            o = _Oe41$builders.join,\n            c = _Oe41$builders.line,\n            v = _Oe41$builders.softline,\n            _Oe41$utils = _Oe41.utils,\n            m = _Oe41$utils.getDocParts,\n            d = _Oe41$utils.replaceTextEndOfLine,\n            _Ue34 = Ue(),\n            p = _Ue34.getPreferredQuote,\n            f = _Ue34.isNonEmptyArray,\n            _xd = xd(),\n            h = _xd.locStart,\n            w = _xd.locEnd,\n            T = bd(),\n            _Bd = Bd(),\n            A = _Bd.getNextNode,\n            S = _Bd.getPreviousNode,\n            B = _Bd.hasPrettierIgnore,\n            I = _Bd.isLastNodeOfSiblings,\n            k = _Bd.isNextNodeOfSomeType,\n            P = _Bd.isNodeOfSomeType,\n            C = _Bd.isParentOfSomeType,\n            D = _Bd.isPreviousNodeOfSomeType,\n            g = _Bd.isVoid,\n            F = _Bd.isWhitespaceNode,\n            l = 2;\n\n        function E(K, he, ye) {\n          let Ce = K.getValue();\n          if (!Ce) return \"\";\n          if (B(K)) return he.originalText.slice(h(Ce), w(Ce));\n          let Ie = he.singleQuote ? \"'\" : '\"';\n\n          switch (Ce.type) {\n            case \"Block\":\n            case \"Program\":\n            case \"Template\":\n              return a(K.map(ye, \"body\"));\n\n            case \"ElementNode\":\n              {\n                let Fe = a(N(K, ye)),\n                    me = he.htmlWhitespaceSensitivity === \"ignore\" && k(K, [\"ElementNode\"]) ? v : \"\";\n                if (g(Ce)) return [Fe, me];\n                let _ = [\"</\", Ce.tag, \">\"];\n                return Ce.children.length === 0 ? [Fe, i(_), me] : he.htmlWhitespaceSensitivity === \"ignore\" ? [Fe, i(x(K, he, ye)), r, i(_), me] : [Fe, i(a(x(K, he, ye))), i(_), me];\n              }\n\n            case \"BlockStatement\":\n              {\n                let Fe = K.getParentNode(1);\n                return Fe && Fe.inverse && Fe.inverse.body.length === 1 && Fe.inverse.body[0] === Ce && Fe.inverse.body[0].path.parts[0] === \"if\" ? [ee(K, ye), ue(K, ye, he), De(K, ye, he)] : [R(K, ye), a([ue(K, ye, he), De(K, ye, he), te(K, ye, he)])];\n              }\n\n            case \"ElementModifierStatement\":\n              return a([\"{{\", pe(K, ye), \"}}\"]);\n\n            case \"MustacheStatement\":\n              return a([L(Ce), pe(K, ye), M(Ce)]);\n\n            case \"SubExpression\":\n              return a([\"(\", ce(K, ye), v, \")\"]);\n\n            case \"AttrNode\":\n              {\n                let Fe = Ce.value.type === \"TextNode\";\n                if (Fe && Ce.value.chars === \"\" && h(Ce.value) === w(Ce.value)) return Ce.name;\n\n                let _ = Fe ? p(Ce.value.chars, Ie).quote : Ce.value.type === \"ConcatStatement\" ? p(Ce.value.parts.filter(ne => ne.type === \"TextNode\").map(ne => ne.chars).join(\"\"), Ie).quote : \"\",\n                    J = ye(\"value\");\n\n                return [Ce.name, \"=\", _, Ce.name === \"class\" && _ ? a(i(J)) : J, _];\n              }\n\n            case \"ConcatStatement\":\n              return K.map(ye, \"parts\");\n\n            case \"Hash\":\n              return o(c, K.map(ye, \"pairs\"));\n\n            case \"HashPair\":\n              return [Ce.key, \"=\", ye(\"value\")];\n\n            case \"TextNode\":\n              {\n                let Fe = Ce.chars.replace(/{{/g, \"\\\\{{\"),\n                    me = z(K);\n\n                if (me) {\n                  if (me === \"class\") {\n                    let xe = Fe.trim().split(/\\s+/).join(\" \"),\n                        Xe = !1,\n                        _e = !1;\n\n                    return C(K, [\"ConcatStatement\"]) && (D(K, [\"MustacheStatement\"]) && /^\\s/.test(Fe) && (Xe = !0), k(K, [\"MustacheStatement\"]) && /\\s$/.test(Fe) && xe !== \"\" && (_e = !0)), [Xe ? c : \"\", xe, _e ? c : \"\"];\n                  }\n\n                  return d(Fe);\n                }\n\n                let J = /^[\\t\\n\\f\\r ]*$/.test(Fe),\n                    ne = !S(K),\n                    Ee = !A(K);\n\n                if (he.htmlWhitespaceSensitivity !== \"ignore\") {\n                  let xe = /^[\\t\\n\\f\\r ]*/,\n                      Xe = /[\\t\\n\\f\\r ]*$/,\n                      _e = Ee && C(K, [\"Template\"]),\n                      je = ne && C(K, [\"Template\"]);\n\n                  if (J) {\n                    if (je || _e) return \"\";\n                    let se = [c],\n                        He = U(Fe);\n                    return He && (se = Ae(He)), I(K) && (se = se.map(Me => t(Me))), se;\n                  }\n\n                  let _Fe$match = Fe.match(xe),\n                      _Fe$match2 = _slicedToArray(_Fe$match, 1),\n                      Re = _Fe$match2[0],\n                      _Fe$match3 = Fe.match(Xe),\n                      _Fe$match4 = _slicedToArray(_Fe$match3, 1),\n                      be = _Fe$match4[0],\n                      Le = [];\n\n                  if (Re) {\n                    Le = [c];\n                    let se = U(Re);\n                    se && (Le = Ae(se)), Fe = Fe.replace(xe, \"\");\n                  }\n\n                  let qe = [];\n\n                  if (be) {\n                    if (!_e) {\n                      qe = [c];\n                      let se = U(be);\n                      se && (qe = Ae(se)), I(K) && (qe = qe.map(He => t(He)));\n                    }\n\n                    Fe = Fe.replace(Xe, \"\");\n                  }\n\n                  return [...Le, s(ie(Fe)), ...qe];\n                }\n\n                let We = U(Fe),\n                    Be = le(Fe),\n                    Pe = ge(Fe);\n                if ((ne || Ee) && J && C(K, [\"Block\", \"ElementNode\", \"Template\"])) return \"\";\n                J && We ? (Be = Math.min(We, l), Pe = 0) : (k(K, [\"BlockStatement\", \"ElementNode\"]) && (Pe = Math.max(Pe, 1)), D(K, [\"BlockStatement\", \"ElementNode\"]) && (Be = Math.max(Be, 1)));\n                let Se = \"\",\n                    Qe = \"\";\n                return Pe === 0 && k(K, [\"MustacheStatement\"]) && (Qe = \" \"), Be === 0 && D(K, [\"MustacheStatement\"]) && (Se = \" \"), ne && (Be = 0, Se = \"\"), Ee && (Pe = 0, Qe = \"\"), Fe = Fe.replace(/^[\\t\\n\\f\\r ]+/g, Se).replace(/[\\t\\n\\f\\r ]+$/, Qe), [...Ae(Be), s(ie(Fe)), ...Ae(Pe)];\n              }\n\n            case \"MustacheCommentStatement\":\n              {\n                let Fe = h(Ce),\n                    me = w(Ce),\n                    _ = he.originalText.charAt(Fe + 2) === \"~\",\n                    J = he.originalText.charAt(me - 3) === \"~\",\n                    ne = Ce.value.includes(\"}}\") ? \"--\" : \"\";\n\n                return [\"{{\", _ ? \"~\" : \"\", \"!\", ne, Ce.value, ne, J ? \"~\" : \"\", \"}}\"];\n              }\n\n            case \"PathExpression\":\n              return Ce.original;\n\n            case \"BooleanLiteral\":\n              return String(Ce.value);\n\n            case \"CommentStatement\":\n              return [\"<!--\", Ce.value, \"-->\"];\n\n            case \"StringLiteral\":\n              {\n                if (ke(K)) {\n                  let Fe = he.singleQuote ? '\"' : \"'\";\n                  return Ne(Ce.value, Fe);\n                }\n\n                return Ne(Ce.value, Ie);\n              }\n\n            case \"NumberLiteral\":\n              return String(Ce.value);\n\n            case \"UndefinedLiteral\":\n              return \"undefined\";\n\n            case \"NullLiteral\":\n              return \"null\";\n\n            default:\n              throw new Error(\"unknown glimmer type: \" + JSON.stringify(Ce.type));\n          }\n        }\n\n        function y(K, he) {\n          return h(K) - h(he);\n        }\n\n        function N(K, he) {\n          let ye = K.getValue(),\n              Ce = [\"attributes\", \"modifiers\", \"comments\"].filter(Fe => f(ye[Fe])),\n              Ie = Ce.flatMap(Fe => ye[Fe]).sort(y);\n\n          for (let Fe of Ce) K.each(me => {\n            let _ = Ie.indexOf(me.getValue());\n\n            Ie.splice(_, 1, [c, he()]);\n          }, Fe);\n\n          return f(ye.blockParams) && Ie.push(c, ve(ye)), [\"<\", ye.tag, i(Ie), b(ye)];\n        }\n\n        function x(K, he, ye) {\n          let Ie = K.getValue().children.every(Fe => F(Fe));\n          return he.htmlWhitespaceSensitivity === \"ignore\" && Ie ? \"\" : K.map((Fe, me) => {\n            let _ = ye();\n\n            return me === 0 && he.htmlWhitespaceSensitivity === \"ignore\" ? [v, _] : _;\n          }, \"children\");\n        }\n\n        function b(K) {\n          return g(K) ? u([v, \"/>\"], [\" />\", v]) : u([v, \">\"], \">\");\n        }\n\n        function L(K) {\n          let he = K.escaped === !1 ? \"{{{\" : \"{{\",\n              ye = K.strip && K.strip.open ? \"~\" : \"\";\n          return [he, ye];\n        }\n\n        function M(K) {\n          let he = K.escaped === !1 ? \"}}}\" : \"}}\";\n          return [K.strip && K.strip.close ? \"~\" : \"\", he];\n        }\n\n        function j(K) {\n          let he = L(K),\n              ye = K.openStrip.open ? \"~\" : \"\";\n          return [he, ye, \"#\"];\n        }\n\n        function $(K) {\n          let he = M(K);\n          return [K.openStrip.close ? \"~\" : \"\", he];\n        }\n\n        function V(K) {\n          let he = L(K),\n              ye = K.closeStrip.open ? \"~\" : \"\";\n          return [he, ye, \"/\"];\n        }\n\n        function q(K) {\n          let he = M(K);\n          return [K.closeStrip.close ? \"~\" : \"\", he];\n        }\n\n        function Y(K) {\n          let he = L(K),\n              ye = K.inverseStrip.open ? \"~\" : \"\";\n          return [he, ye];\n        }\n\n        function H(K) {\n          let he = M(K);\n          return [K.inverseStrip.close ? \"~\" : \"\", he];\n        }\n\n        function R(K, he) {\n          let ye = K.getValue(),\n              Ce = j(ye),\n              Ie = $(ye),\n              Fe = [de(K, he)],\n              me = ae(K, he);\n\n          if (me && Fe.push(c, me), f(ye.program.blockParams)) {\n            let _ = ve(ye.program);\n\n            Fe.push(c, _);\n          }\n\n          return a([Ce, i(Fe), v, Ie]);\n        }\n\n        function Q(K, he) {\n          return [he.htmlWhitespaceSensitivity === \"ignore\" ? r : \"\", Y(K), \"else\", H(K)];\n        }\n\n        function ee(K, he) {\n          let ye = K.getParentNode(1);\n          return [Y(ye), \"else if \", ae(K, he), H(ye)];\n        }\n\n        function te(K, he, ye) {\n          let Ce = K.getValue();\n          return ye.htmlWhitespaceSensitivity === \"ignore\" ? [oe(Ce) ? v : r, V(Ce), he(\"path\"), q(Ce)] : [V(Ce), he(\"path\"), q(Ce)];\n        }\n\n        function oe(K) {\n          return P(K, [\"BlockStatement\"]) && K.program.body.every(he => F(he));\n        }\n\n        function W(K) {\n          return X(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], [\"BlockStatement\"]) && K.inverse.body[0].path.parts[0] === \"if\";\n        }\n\n        function X(K) {\n          return P(K, [\"BlockStatement\"]) && K.inverse;\n        }\n\n        function ue(K, he, ye) {\n          let Ce = K.getValue();\n          if (oe(Ce)) return \"\";\n          let Ie = he(\"program\");\n          return ye.htmlWhitespaceSensitivity === \"ignore\" ? i([r, Ie]) : i(Ie);\n        }\n\n        function De(K, he, ye) {\n          let Ce = K.getValue(),\n              Ie = he(\"inverse\"),\n              Fe = ye.htmlWhitespaceSensitivity === \"ignore\" ? [r, Ie] : Ie;\n          return W(Ce) ? Fe : X(Ce) ? [Q(Ce, ye), i(Fe)] : \"\";\n        }\n\n        function ie(K) {\n          return m(o(c, G(K)));\n        }\n\n        function G(K) {\n          return K.split(/[\\t\\n\\f\\r ]+/);\n        }\n\n        function z(K) {\n          for (let he = 0; he < 2; he++) {\n            let ye = K.getParentNode(he);\n            if (ye && ye.type === \"AttrNode\") return ye.name.toLowerCase();\n          }\n        }\n\n        function U(K) {\n          return K = typeof K == \"string\" ? K : \"\", K.split(\"\\n\").length - 1;\n        }\n\n        function le(K) {\n          K = typeof K == \"string\" ? K : \"\";\n          let he = (K.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";\n          return U(he);\n        }\n\n        function ge(K) {\n          K = typeof K == \"string\" ? K : \"\";\n          let he = (K.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";\n          return U(he);\n        }\n\n        function Ae() {\n          let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n          return Array.from({\n            length: Math.min(K, l)\n          }).fill(r);\n        }\n\n        function Ne(K, he) {\n          let _p2 = p(K, he),\n              ye = _p2.quote,\n              Ce = _p2.regex;\n\n          return [ye, K.replace(Ce, \"\\\\\".concat(ye)), ye];\n        }\n\n        function ke(K) {\n          let he = 0,\n              ye = K.getParentNode(he);\n\n          for (; ye && P(ye, [\"SubExpression\"]);) he++, ye = K.getParentNode(he);\n\n          return !!(ye && P(K.getParentNode(he + 1), [\"ConcatStatement\"]) && P(K.getParentNode(he + 2), [\"AttrNode\"]));\n        }\n\n        function ce(K, he) {\n          let ye = de(K, he),\n              Ce = ae(K, he);\n          return Ce ? i([ye, c, a(Ce)]) : ye;\n        }\n\n        function pe(K, he) {\n          let ye = de(K, he),\n              Ce = ae(K, he);\n          return Ce ? [i([ye, c, Ce]), v] : ye;\n        }\n\n        function de(K, he) {\n          return he(\"path\");\n        }\n\n        function ae(K, he) {\n          let ye = K.getValue(),\n              Ce = [];\n\n          if (ye.params.length > 0) {\n            let Ie = K.map(he, \"params\");\n            Ce.push(...Ie);\n          }\n\n          if (ye.hash && ye.hash.pairs.length > 0) {\n            let Ie = he(\"hash\");\n            Ce.push(Ie);\n          }\n\n          return Ce.length === 0 ? \"\" : o(c, Ce);\n        }\n\n        function ve(K) {\n          return [\"as |\", K.blockParams.join(\" \"), \"|\"];\n        }\n\n        n.exports = {\n          print: E,\n          massageAstNode: T\n        };\n      }\n\n    }),\n        wd = Z({\n      \"src/language-handlebars/parsers.js\"() {\n        re();\n      }\n\n    }),\n        _d = Z({\n      \"node_modules/linguist-languages/data/Handlebars.json\"(e, n) {\n        n.exports = {\n          name: \"Handlebars\",\n          type: \"markup\",\n          color: \"#f7931e\",\n          aliases: [\"hbs\", \"htmlbars\"],\n          extensions: [\".handlebars\", \".hbs\"],\n          tmScope: \"text.html.handlebars\",\n          aceMode: \"handlebars\",\n          languageId: 155\n        };\n      }\n\n    }),\n        Pd = Z({\n      \"src/language-handlebars/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = Nd(),\n            a = wd(),\n            r = [t(_d(), () => ({\n          since: \"2.3.0\",\n          parsers: [\"glimmer\"],\n          vscodeLanguageIds: [\"handlebars\"]\n        }))],\n            u = {\n          glimmer: s\n        };\n        n.exports = {\n          languages: r,\n          printers: u,\n          parsers: a\n        };\n      }\n\n    }),\n        kd = Z({\n      \"src/language-graphql/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(a);\n        }\n\n        function s(a) {\n          return \"# @format\\n\\n\" + a;\n        }\n\n        n.exports = {\n          hasPragma: t,\n          insertPragma: s\n        };\n      }\n\n    }),\n        Id = Z({\n      \"src/language-graphql/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return typeof a.start == \"number\" ? a.start : a.loc && a.loc.start;\n        }\n\n        function s(a) {\n          return typeof a.end == \"number\" ? a.end : a.loc && a.loc.end;\n        }\n\n        n.exports = {\n          locStart: t,\n          locEnd: s\n        };\n      }\n\n    }),\n        Ld = Z({\n      \"src/language-graphql/printer-graphql.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe42 = Oe(),\n            _Oe42$builders = _Oe42.builders,\n            t = _Oe42$builders.join,\n            s = _Oe42$builders.hardline,\n            a = _Oe42$builders.line,\n            r = _Oe42$builders.softline,\n            u = _Oe42$builders.group,\n            i = _Oe42$builders.indent,\n            o = _Oe42$builders.ifBreak,\n            _Ue35 = Ue(),\n            c = _Ue35.isNextLineEmpty,\n            v = _Ue35.isNonEmptyArray,\n            _kd = kd(),\n            m = _kd.insertPragma,\n            _Id = Id(),\n            d = _Id.locStart,\n            p = _Id.locEnd;\n\n        function f(k, P, C) {\n          let D = k.getValue();\n          if (!D) return \"\";\n          if (typeof D == \"string\") return D;\n\n          switch (D.kind) {\n            case \"Document\":\n              {\n                let g = [];\n                return k.each((F, l, E) => {\n                  g.push(C()), l !== E.length - 1 && (g.push(s), c(P.originalText, F.getValue(), p) && g.push(s));\n                }, \"definitions\"), [...g, s];\n              }\n\n            case \"OperationDefinition\":\n              {\n                let g = P.originalText[d(D)] !== \"{\",\n                    F = Boolean(D.name);\n                return [g ? D.operation : \"\", g && F ? [\" \", C(\"name\")] : \"\", g && !F && v(D.variableDefinitions) ? \" \" : \"\", v(D.variableDefinitions) ? u([\"(\", i([r, t([o(\"\", \", \"), r], k.map(C, \"variableDefinitions\"))]), r, \")\"]) : \"\", h(k, C, D), D.selectionSet ? !g && !F ? \"\" : \" \" : \"\", C(\"selectionSet\")];\n              }\n\n            case \"FragmentDefinition\":\n              return [\"fragment \", C(\"name\"), v(D.variableDefinitions) ? u([\"(\", i([r, t([o(\"\", \", \"), r], k.map(C, \"variableDefinitions\"))]), r, \")\"]) : \"\", \" on \", C(\"typeCondition\"), h(k, C, D), \" \", C(\"selectionSet\")];\n\n            case \"SelectionSet\":\n              return [\"{\", i([s, t(s, w(k, P, C, \"selections\"))]), s, \"}\"];\n\n            case \"Field\":\n              return u([D.alias ? [C(\"alias\"), \": \"] : \"\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", h(k, C, D), D.selectionSet ? \" \" : \"\", C(\"selectionSet\")]);\n\n            case \"Name\":\n              return D.value;\n\n            case \"StringValue\":\n              {\n                if (D.block) {\n                  let g = D.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\");\n                  return g.length === 1 && (g[0] = g[0].trim()), g.every(F => F === \"\") && (g.length = 0), t(s, ['\"\"\"', ...g, '\"\"\"']);\n                }\n\n                return ['\"', D.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"), '\"'];\n              }\n\n            case \"IntValue\":\n            case \"FloatValue\":\n            case \"EnumValue\":\n              return D.value;\n\n            case \"BooleanValue\":\n              return D.value ? \"true\" : \"false\";\n\n            case \"NullValue\":\n              return \"null\";\n\n            case \"Variable\":\n              return [\"$\", C(\"name\")];\n\n            case \"ListValue\":\n              return u([\"[\", i([r, t([o(\"\", \", \"), r], k.map(C, \"values\"))]), r, \"]\"]);\n\n            case \"ObjectValue\":\n              return u([\"{\", P.bracketSpacing && D.fields.length > 0 ? \" \" : \"\", i([r, t([o(\"\", \", \"), r], k.map(C, \"fields\"))]), r, o(\"\", P.bracketSpacing && D.fields.length > 0 ? \" \" : \"\"), \"}\"]);\n\n            case \"ObjectField\":\n            case \"Argument\":\n              return [C(\"name\"), \": \", C(\"value\")];\n\n            case \"Directive\":\n              return [\"@\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\"];\n\n            case \"NamedType\":\n              return C(\"name\");\n\n            case \"VariableDefinition\":\n              return [C(\"variable\"), \": \", C(\"type\"), D.defaultValue ? [\" = \", C(\"defaultValue\")] : \"\", h(k, C, D)];\n\n            case \"ObjectTypeExtension\":\n            case \"ObjectTypeDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", D.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\", \"type \", C(\"name\"), D.interfaces.length > 0 ? [\" implements \", ...S(k, P, C)] : \"\", h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n\n            case \"FieldDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", \": \", C(\"type\"), h(k, C, D)];\n\n            case \"DirectiveDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", \"directive \", \"@\", C(\"name\"), D.arguments.length > 0 ? u([\"(\", i([r, t([o(\"\", \", \"), r], w(k, P, C, \"arguments\"))]), r, \")\"]) : \"\", D.repeatable ? \" repeatable\" : \"\", \" on \", t(\" | \", k.map(C, \"locations\"))];\n\n            case \"EnumTypeExtension\":\n            case \"EnumTypeDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", D.kind === \"EnumTypeExtension\" ? \"extend \" : \"\", \"enum \", C(\"name\"), h(k, C, D), D.values.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"values\"))]), s, \"}\"] : \"\"];\n\n            case \"EnumValueDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", C(\"name\"), h(k, C, D)];\n\n            case \"InputValueDefinition\":\n              return [C(\"description\"), D.description ? D.description.block ? s : a : \"\", C(\"name\"), \": \", C(\"type\"), D.defaultValue ? [\" = \", C(\"defaultValue\")] : \"\", h(k, C, D)];\n\n            case \"InputObjectTypeExtension\":\n            case \"InputObjectTypeDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", D.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\", \"input \", C(\"name\"), h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n\n            case \"SchemaExtension\":\n              return [\"extend schema\", h(k, C, D), ...(D.operationTypes.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"operationTypes\"))]), s, \"}\"] : [])];\n\n            case \"SchemaDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", \"schema\", h(k, C, D), \" {\", D.operationTypes.length > 0 ? i([s, t(s, w(k, P, C, \"operationTypes\"))]) : \"\", s, \"}\"];\n\n            case \"OperationTypeDefinition\":\n              return [C(\"operation\"), \": \", C(\"type\")];\n\n            case \"InterfaceTypeExtension\":\n            case \"InterfaceTypeDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", D.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\", \"interface \", C(\"name\"), D.interfaces.length > 0 ? [\" implements \", ...S(k, P, C)] : \"\", h(k, C, D), D.fields.length > 0 ? [\" {\", i([s, t(s, w(k, P, C, \"fields\"))]), s, \"}\"] : \"\"];\n\n            case \"FragmentSpread\":\n              return [\"...\", C(\"name\"), h(k, C, D)];\n\n            case \"InlineFragment\":\n              return [\"...\", D.typeCondition ? [\" on \", C(\"typeCondition\")] : \"\", h(k, C, D), \" \", C(\"selectionSet\")];\n\n            case \"UnionTypeExtension\":\n            case \"UnionTypeDefinition\":\n              return u([C(\"description\"), D.description ? s : \"\", u([D.kind === \"UnionTypeExtension\" ? \"extend \" : \"\", \"union \", C(\"name\"), h(k, C, D), D.types.length > 0 ? [\" =\", o(\"\", \" \"), i([o([a, \"  \"]), t([a, \"| \"], k.map(C, \"types\"))])] : \"\"])]);\n\n            case \"ScalarTypeExtension\":\n            case \"ScalarTypeDefinition\":\n              return [C(\"description\"), D.description ? s : \"\", D.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\", \"scalar \", C(\"name\"), h(k, C, D)];\n\n            case \"NonNullType\":\n              return [C(\"type\"), \"!\"];\n\n            case \"ListType\":\n              return [\"[\", C(\"type\"), \"]\"];\n\n            default:\n              throw new Error(\"unknown graphql type: \" + JSON.stringify(D.kind));\n          }\n        }\n\n        function h(k, P, C) {\n          if (C.directives.length === 0) return \"\";\n          let D = t(a, k.map(P, \"directives\"));\n          return C.kind === \"FragmentDefinition\" || C.kind === \"OperationDefinition\" ? u([a, D]) : [\" \", u(i([r, D]))];\n        }\n\n        function w(k, P, C, D) {\n          return k.map((g, F, l) => {\n            let E = C();\n            return F < l.length - 1 && c(P.originalText, g.getValue(), p) ? [E, s] : E;\n          }, D);\n        }\n\n        function T(k) {\n          return k.kind && k.kind !== \"Comment\";\n        }\n\n        function A(k) {\n          let P = k.getValue();\n          if (P.kind === \"Comment\") return \"#\" + P.value.trimEnd();\n          throw new Error(\"Not a comment: \" + JSON.stringify(P));\n        }\n\n        function S(k, P, C) {\n          let D = k.getNode(),\n              g = [],\n              F = D.interfaces,\n              l = k.map(E => C(E), \"interfaces\");\n\n          for (let E = 0; E < F.length; E++) {\n            let y = F[E];\n            g.push(l[E]);\n            let N = F[E + 1];\n\n            if (N) {\n              let x = P.originalText.slice(y.loc.end, N.loc.start),\n                  b = x.includes(\"#\"),\n                  L = x.replace(/#.*/g, \"\").trim();\n              g.push(L === \",\" ? \",\" : \" &\", b ? a : \" \");\n            }\n          }\n\n          return g;\n        }\n\n        function B(k, P) {\n          k.kind === \"StringValue\" && k.block && !k.value.includes(\"\\n\") && (P.value = P.value.trim());\n        }\n\n        B.ignoredProperties = new Set([\"loc\", \"comments\"]);\n\n        function I(k) {\n          var P;\n          let C = k.getValue();\n          return C == null || (P = C.comments) === null || P === void 0 ? void 0 : P.some(D => D.value.trim() === \"prettier-ignore\");\n        }\n\n        n.exports = {\n          print: f,\n          massageAstNode: B,\n          hasPrettierIgnore: I,\n          insertPragma: m,\n          printComment: A,\n          canAttachComment: T\n        };\n      }\n\n    }),\n        jd = Z({\n      \"src/language-graphql/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot();\n        n.exports = {\n          bracketSpacing: t.bracketSpacing\n        };\n      }\n\n    }),\n        Od = Z({\n      \"src/language-graphql/parsers.js\"() {\n        re();\n      }\n\n    }),\n        qd = Z({\n      \"node_modules/linguist-languages/data/GraphQL.json\"(e, n) {\n        n.exports = {\n          name: \"GraphQL\",\n          type: \"data\",\n          color: \"#e10098\",\n          extensions: [\".graphql\", \".gql\", \".graphqls\"],\n          tmScope: \"source.graphql\",\n          aceMode: \"text\",\n          languageId: 139\n        };\n      }\n\n    }),\n        Md = Z({\n      \"src/language-graphql/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = Ld(),\n            a = jd(),\n            r = Od(),\n            u = [t(qd(), () => ({\n          since: \"1.5.0\",\n          parsers: [\"graphql\"],\n          vscodeLanguageIds: [\"graphql\"]\n        }))],\n            i = {\n          graphql: s\n        };\n        n.exports = {\n          languages: u,\n          options: a,\n          printers: i,\n          parsers: r\n        };\n      }\n\n    }),\n        go = Z({\n      \"src/language-markdown/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return a.position.start.offset;\n        }\n\n        function s(a) {\n          return a.position.end.offset;\n        }\n\n        n.exports = {\n          locStart: t,\n          locEnd: s\n        };\n      }\n\n    }),\n        Rd = Z({\n      \"src/language-markdown/constants.evaluate.js\"(e, n) {\n        n.exports = {\n          cjkPattern: \"(?:[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u2ff0-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d])(?:[\\\\ufe00-\\\\ufe0f]|\\\\udb40[\\\\udd00-\\\\uddef])?\",\n          kPattern: \"[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]\",\n          punctuationPattern: \"[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]\"\n        };\n      }\n\n    }),\n        Kn = Z({\n      \"src/language-markdown/utils.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue36 = Ue(),\n            t = _Ue36.getLast,\n            _go = go(),\n            s = _go.locStart,\n            a = _go.locEnd,\n            _Rd = Rd(),\n            r = _Rd.cjkPattern,\n            u = _Rd.kPattern,\n            i = _Rd.punctuationPattern,\n            o = [\"liquidNode\", \"inlineCode\", \"emphasis\", \"esComment\", \"strong\", \"delete\", \"wikiLink\", \"link\", \"linkReference\", \"image\", \"imageReference\", \"footnote\", \"footnoteReference\", \"sentence\", \"whitespace\", \"word\", \"break\", \"inlineMath\"],\n            c = [...o, \"tableCell\", \"paragraph\", \"heading\"],\n            v = new RegExp(u),\n            m = new RegExp(i);\n\n        function d(A, S) {\n          let B = \"non-cjk\",\n              I = \"cj-letter\",\n              k = \"k-letter\",\n              P = \"cjk-punctuation\",\n              C = [],\n              D = (S.proseWrap === \"preserve\" ? A : A.replace(new RegExp(\"(\".concat(r, \")\\n(\").concat(r, \")\"), \"g\"), \"$1$2\")).split(/([\\t\\n ]+)/);\n\n          for (let _ref37 of D.entries()) {\n            var _ref38 = _slicedToArray(_ref37, 2);\n\n            let F = _ref38[0];\n            let l = _ref38[1];\n\n            if (F % 2 === 1) {\n              C.push({\n                type: \"whitespace\",\n                value: /\\n/.test(l) ? \"\\n\" : \" \"\n              });\n              continue;\n            }\n\n            if ((F === 0 || F === D.length - 1) && l === \"\") continue;\n            let E = l.split(new RegExp(\"(\".concat(r, \")\")));\n\n            for (let _ref39 of E.entries()) {\n              var _ref40 = _slicedToArray(_ref39, 2);\n\n              let y = _ref40[0];\n              let N = _ref40[1];\n\n              if (!((y === 0 || y === E.length - 1) && N === \"\")) {\n                if (y % 2 === 0) {\n                  N !== \"\" && g({\n                    type: \"word\",\n                    value: N,\n                    kind: B,\n                    hasLeadingPunctuation: m.test(N[0]),\n                    hasTrailingPunctuation: m.test(t(N))\n                  });\n                  continue;\n                }\n\n                g(m.test(N) ? {\n                  type: \"word\",\n                  value: N,\n                  kind: P,\n                  hasLeadingPunctuation: !0,\n                  hasTrailingPunctuation: !0\n                } : {\n                  type: \"word\",\n                  value: N,\n                  kind: v.test(N) ? k : I,\n                  hasLeadingPunctuation: !1,\n                  hasTrailingPunctuation: !1\n                });\n              }\n            }\n          }\n\n          return C;\n\n          function g(F) {\n            let l = t(C);\n            l && l.type === \"word\" && (l.kind === B && F.kind === I && !l.hasTrailingPunctuation || l.kind === I && F.kind === B && !F.hasLeadingPunctuation ? C.push({\n              type: \"whitespace\",\n              value: \" \"\n            }) : !E(B, P) && ![l.value, F.value].some(y => /\\u3000/.test(y)) && C.push({\n              type: \"whitespace\",\n              value: \"\"\n            })), C.push(F);\n\n            function E(y, N) {\n              return l.kind === y && F.kind === N || l.kind === N && F.kind === y;\n            }\n          }\n        }\n\n        function p(A, S) {\n          let _S$slice$match = S.slice(A.position.start.offset, A.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/),\n              _S$slice$match2 = _slicedToArray(_S$slice$match, 4),\n              B = _S$slice$match2[1],\n              I = _S$slice$match2[2],\n              k = _S$slice$match2[3];\n\n          return {\n            numberText: B,\n            marker: I,\n            leadingSpaces: k\n          };\n        }\n\n        function f(A, S) {\n          if (!A.ordered || A.children.length < 2) return !1;\n          let B = Number(p(A.children[0], S.originalText).numberText),\n              I = Number(p(A.children[1], S.originalText).numberText);\n\n          if (B === 0 && A.children.length > 2) {\n            let k = Number(p(A.children[2], S.originalText).numberText);\n            return I === 1 && k === 1;\n          }\n\n          return I === 1;\n        }\n\n        function h(A, S) {\n          let B = A.value;\n          return A.position.end.offset === S.length && B.endsWith(\"\\n\") && S.endsWith(\"\\n\") ? B.slice(0, -1) : B;\n        }\n\n        function w(A, S) {\n          return function B(I, k, P) {\n            let C = Object.assign({}, S(I, k, P));\n            return C.children && (C.children = C.children.map((D, g) => B(D, g, [C, ...P]))), C;\n          }(A, null, []);\n        }\n\n        function T(A) {\n          if ((A == null ? void 0 : A.type) !== \"link\" || A.children.length !== 1) return !1;\n\n          let _A$children = _slicedToArray(A.children, 1),\n              S = _A$children[0];\n\n          return s(A) === s(S) && a(A) === a(S);\n        }\n\n        n.exports = {\n          mapAst: w,\n          splitText: d,\n          punctuationPattern: i,\n          getFencedCodeBlockValue: h,\n          getOrderedListItemInfo: p,\n          hasGitDiffFriendlyOrderedList: f,\n          INLINE_NODE_TYPES: o,\n          INLINE_NODE_WRAPPER_TYPES: c,\n          isAutolink: T\n        };\n      }\n\n    }),\n        Vd = Z({\n      \"src/language-markdown/embed.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue37 = Ue(),\n            t = _Ue37.inferParserByLanguage,\n            s = _Ue37.getMaxContinuousCount,\n            _Oe43 = Oe(),\n            _Oe43$builders = _Oe43.builders,\n            a = _Oe43$builders.hardline,\n            r = _Oe43$builders.markAsRoot,\n            u = _Oe43.utils.replaceEndOfLine,\n            i = Xn(),\n            _Kn = Kn(),\n            o = _Kn.getFencedCodeBlockValue;\n\n        function c(v, m, d, p) {\n          let f = v.getValue();\n\n          if (f.type === \"code\" && f.lang !== null) {\n            let h = t(f.lang, p);\n\n            if (h) {\n              let w = p.__inJsTemplate ? \"~\" : \"`\",\n                  T = w.repeat(Math.max(3, s(f.value, w) + 1)),\n                  A = {\n                parser: h\n              };\n              f.lang === \"tsx\" && (A.filepath = \"dummy.tsx\");\n              let S = d(o(f, p.originalText), A, {\n                stripTrailingHardline: !0\n              });\n              return r([T, f.lang, f.meta ? \" \" + f.meta : \"\", a, u(S), a, T]);\n            }\n          }\n\n          switch (f.type) {\n            case \"front-matter\":\n              return i(f, d);\n\n            case \"importExport\":\n              return [d(f.value, {\n                parser: \"babel\"\n              }, {\n                stripTrailingHardline: !0\n              }), a];\n\n            case \"jsx\":\n              return d(\"<$>\".concat(f.value, \"</$>\"), {\n                parser: \"__js_expression\",\n                rootMarker: \"mdx\"\n              }, {\n                stripTrailingHardline: !0\n              });\n          }\n\n          return null;\n        }\n\n        n.exports = c;\n      }\n\n    }),\n        yo = Z({\n      \"src/language-markdown/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = mo(),\n            s = [\"format\", \"prettier\"];\n\n        function a(r) {\n          let u = \"@(\".concat(s.join(\"|\"), \")\"),\n              i = new RegExp([\"<!--\\\\s*\".concat(u, \"\\\\s*-->\"), \"{\\\\s*\\\\/\\\\*\\\\s*\".concat(u, \"\\\\s*\\\\*\\\\/\\\\s*}\"), \"<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*\".concat(u, \"[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->\")].join(\"|\"), \"m\"),\n              o = r.match(i);\n          return (o == null ? void 0 : o.index) === 0;\n        }\n\n        n.exports = {\n          startWithPragma: a,\n          hasPragma: r => a(t(r).content.trimStart()),\n          insertPragma: r => {\n            let u = t(r),\n                i = \"<!-- @\".concat(s[0], \" -->\");\n            return u.frontMatter ? \"\".concat(u.frontMatter.raw, \"\\n\\n\").concat(i, \"\\n\\n\").concat(u.content) : \"\".concat(i, \"\\n\\n\").concat(u.content);\n          }\n        };\n      }\n\n    }),\n        Wd = Z({\n      \"src/language-markdown/print-preprocess.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = it(),\n            _Kn2 = Kn(),\n            s = _Kn2.getOrderedListItemInfo,\n            a = _Kn2.mapAst,\n            r = _Kn2.splitText,\n            u = /^.$/su;\n\n        function i(T, A) {\n          return T = v(T, A), T = p(T), T = c(T), T = h(T, A), T = w(T, A), T = f(T, A), T = o(T), T = m(T), T;\n        }\n\n        function o(T) {\n          return a(T, A => A.type !== \"import\" && A.type !== \"export\" ? A : Object.assign(Object.assign({}, A), {}, {\n            type: \"importExport\"\n          }));\n        }\n\n        function c(T) {\n          return a(T, A => A.type !== \"inlineCode\" ? A : Object.assign(Object.assign({}, A), {}, {\n            value: A.value.replace(/\\s+/g, \" \")\n          }));\n        }\n\n        function v(T, A) {\n          return a(T, S => S.type !== \"text\" || S.value === \"*\" || S.value === \"_\" || !u.test(S.value) || S.position.end.offset - S.position.start.offset === S.value.length ? S : Object.assign(Object.assign({}, S), {}, {\n            value: A.originalText.slice(S.position.start.offset, S.position.end.offset)\n          }));\n        }\n\n        function m(T) {\n          return d(T, (A, S) => A.type === \"importExport\" && S.type === \"importExport\", (A, S) => ({\n            type: \"importExport\",\n            value: A.value + \"\\n\\n\" + S.value,\n            position: {\n              start: A.position.start,\n              end: S.position.end\n            }\n          }));\n        }\n\n        function d(T, A, S) {\n          return a(T, B => {\n            if (!B.children) return B;\n            let I = B.children.reduce((k, P) => {\n              let C = t(k);\n              return C && A(C, P) ? k.splice(-1, 1, S(C, P)) : k.push(P), k;\n            }, []);\n            return Object.assign(Object.assign({}, B), {}, {\n              children: I\n            });\n          });\n        }\n\n        function p(T) {\n          return d(T, (A, S) => A.type === \"text\" && S.type === \"text\", (A, S) => ({\n            type: \"text\",\n            value: A.value + S.value,\n            position: {\n              start: A.position.start,\n              end: S.position.end\n            }\n          }));\n        }\n\n        function f(T, A) {\n          return a(T, (S, B, I) => {\n            let _I = _slicedToArray(I, 1),\n                k = _I[0];\n\n            if (S.type !== \"text\") return S;\n            let P = S.value;\n            return k.type === \"paragraph\" && (B === 0 && (P = P.trimStart()), B === k.children.length - 1 && (P = P.trimEnd())), {\n              type: \"sentence\",\n              position: S.position,\n              children: r(P, A)\n            };\n          });\n        }\n\n        function h(T, A) {\n          return a(T, (S, B, I) => {\n            if (S.type === \"code\") {\n              let k = /^\\n?(?: {4,}|\\t)/.test(A.originalText.slice(S.position.start.offset, S.position.end.offset));\n              if (S.isIndented = k, k) for (let P = 0; P < I.length; P++) {\n                let C = I[P];\n                if (C.hasIndentedCodeblock) break;\n                C.type === \"list\" && (C.hasIndentedCodeblock = !0);\n              }\n            }\n\n            return S;\n          });\n        }\n\n        function w(T, A) {\n          return a(T, (I, k, P) => {\n            if (I.type === \"list\" && I.children.length > 0) {\n              for (let C = 0; C < P.length; C++) {\n                let D = P[C];\n                if (D.type === \"list\" && !D.isAligned) return I.isAligned = !1, I;\n              }\n\n              I.isAligned = B(I);\n            }\n\n            return I;\n          });\n\n          function S(I) {\n            return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;\n          }\n\n          function B(I) {\n            if (!I.ordered) return !0;\n\n            let _I$children = _slicedToArray(I.children, 2),\n                k = _I$children[0],\n                P = _I$children[1];\n\n            if (s(k, A.originalText).leadingSpaces.length > 1) return !0;\n            let D = S(k);\n            if (D === -1) return !1;\n            if (I.children.length === 1) return D % A.tabWidth === 0;\n            let g = S(P);\n            return D !== g ? !1 : D % A.tabWidth === 0 ? !0 : s(P, A.originalText).leadingSpaces.length > 1;\n          }\n        }\n\n        n.exports = i;\n      }\n\n    }),\n        $d = Z({\n      \"src/language-markdown/clean.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue38 = Ue(),\n            t = _Ue38.isFrontMatterNode,\n            _yo = yo(),\n            s = _yo.startWithPragma,\n            a = new Set([\"position\", \"raw\"]);\n\n        function r(u, i, o) {\n          if ((u.type === \"front-matter\" || u.type === \"code\" || u.type === \"yaml\" || u.type === \"import\" || u.type === \"export\" || u.type === \"jsx\") && delete i.value, u.type === \"list\" && delete i.isAligned, (u.type === \"list\" || u.type === \"listItem\") && (delete i.spread, delete i.loose), u.type === \"text\" || (u.type === \"inlineCode\" && (i.value = u.value.replace(/[\\t\\n ]+/g, \" \")), u.type === \"wikiLink\" && (i.value = u.value.trim().replace(/[\\t\\n]+/g, \" \")), (u.type === \"definition\" || u.type === \"linkReference\") && (i.label = u.label.trim().replace(/[\\t\\n ]+/g, \" \").toLowerCase()), (u.type === \"definition\" || u.type === \"link\" || u.type === \"image\") && u.title && (i.title = u.title.replace(/\\\\([\"')])/g, \"$1\")), o && o.type === \"root\" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === \"html\" && s(u.value))) return null;\n        }\n\n        r.ignoredProperties = a, n.exports = r;\n      }\n\n    }),\n        Hd = Z({\n      \"src/language-markdown/printer-markdown.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue39 = Ue(),\n            t = _Ue39.getLast,\n            s = _Ue39.getMinNotPresentContinuousCount,\n            a = _Ue39.getMaxContinuousCount,\n            r = _Ue39.getStringWidth,\n            u = _Ue39.isNonEmptyArray,\n            _Oe44 = Oe(),\n            _Oe44$builders = _Oe44.builders,\n            i = _Oe44$builders.breakParent,\n            o = _Oe44$builders.join,\n            c = _Oe44$builders.line,\n            v = _Oe44$builders.literalline,\n            m = _Oe44$builders.markAsRoot,\n            d = _Oe44$builders.hardline,\n            p = _Oe44$builders.softline,\n            f = _Oe44$builders.ifBreak,\n            h = _Oe44$builders.fill,\n            w = _Oe44$builders.align,\n            T = _Oe44$builders.indent,\n            A = _Oe44$builders.group,\n            S = _Oe44$builders.hardlineWithoutBreakParent,\n            _Oe44$utils = _Oe44.utils,\n            B = _Oe44$utils.normalizeDoc,\n            I = _Oe44$utils.replaceTextEndOfLine,\n            k = _Oe44.printer.printDocToString,\n            P = Vd(),\n            _yo2 = yo(),\n            C = _yo2.insertPragma,\n            _go2 = go(),\n            D = _go2.locStart,\n            g = _go2.locEnd,\n            F = Wd(),\n            l = $d(),\n            _Kn3 = Kn(),\n            E = _Kn3.getFencedCodeBlockValue,\n            y = _Kn3.hasGitDiffFriendlyOrderedList,\n            N = _Kn3.splitText,\n            x = _Kn3.punctuationPattern,\n            b = _Kn3.INLINE_NODE_TYPES,\n            L = _Kn3.INLINE_NODE_WRAPPER_TYPES,\n            M = _Kn3.isAutolink,\n            j = new Set([\"importExport\"]),\n            $ = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"],\n            V = new Set([\"listItem\", \"definition\", \"footnoteDefinition\"]);\n\n        function q(ce, pe, de) {\n          let ae = ce.getValue();\n          if (le(ce)) return N(pe.originalText.slice(ae.position.start.offset, ae.position.end.offset), pe).map(ve => ve.type === \"word\" ? ve.value : ve.value === \"\" ? \"\" : oe(ce, ve.value, pe));\n\n          switch (ae.type) {\n            case \"front-matter\":\n              return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);\n\n            case \"root\":\n              return ae.children.length === 0 ? \"\" : [B(X(ce, pe, de)), j.has(De(ae).type) ? \"\" : d];\n\n            case \"paragraph\":\n              return ue(ce, pe, de, {\n                postprocessor: h\n              });\n\n            case \"sentence\":\n              return ue(ce, pe, de);\n\n            case \"word\":\n              {\n                let ve = ae.value.replace(/\\*/g, \"\\\\$&\").replace(new RegExp([\"(^|\".concat(x, \")(_+)\"), \"(_+)(\".concat(x, \"|$)\")].join(\"|\"), \"g\"), (ye, Ce, Ie, Fe, me) => (Ie ? \"\".concat(Ce).concat(Ie) : \"\".concat(Fe).concat(me)).replace(/_/g, \"\\\\_\")),\n                    K = (ye, Ce, Ie) => ye.type === \"sentence\" && Ie === 0,\n                    he = (ye, Ce, Ie) => M(ye.children[Ie - 1]);\n\n                return ve !== ae.value && (ce.match(void 0, K, he) || ce.match(void 0, K, (ye, Ce, Ie) => ye.type === \"emphasis\" && Ie === 0, he)) && (ve = ve.replace(/^(\\\\?[*_])+/, ye => ye.replace(/\\\\/g, \"\"))), ve;\n              }\n\n            case \"whitespace\":\n              {\n                let ve = ce.getParentNode(),\n                    K = ve.children.indexOf(ae),\n                    he = ve.children[K + 1],\n                    ye = he && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(he.value) ? \"never\" : pe.proseWrap;\n                return oe(ce, ae.value, {\n                  proseWrap: ye\n                });\n              }\n\n            case \"emphasis\":\n              {\n                let ve;\n                if (M(ae.children[0])) ve = pe.originalText[ae.position.start.offset];else {\n                  let K = ce.getParentNode(),\n                      he = K.children.indexOf(ae),\n                      ye = K.children[he - 1],\n                      Ce = K.children[he + 1];\n                  ve = ye && ye.type === \"sentence\" && ye.children.length > 0 && t(ye.children).type === \"word\" && !t(ye.children).hasTrailingPunctuation || Ce && Ce.type === \"sentence\" && Ce.children.length > 0 && Ce.children[0].type === \"word\" && !Ce.children[0].hasLeadingPunctuation || te(ce, \"emphasis\") ? \"*\" : \"_\";\n                }\n                return [ve, ue(ce, pe, de), ve];\n              }\n\n            case \"strong\":\n              return [\"**\", ue(ce, pe, de), \"**\"];\n\n            case \"delete\":\n              return [\"~~\", ue(ce, pe, de), \"~~\"];\n\n            case \"inlineCode\":\n              {\n                let ve = s(ae.value, \"`\"),\n                    K = \"`\".repeat(ve || 1),\n                    he = ve && !/^\\s/.test(ae.value) ? \" \" : \"\";\n                return [K, he, ae.value, he, K];\n              }\n\n            case \"wikiLink\":\n              {\n                let ve = \"\";\n                return pe.proseWrap === \"preserve\" ? ve = ae.value : ve = ae.value.replace(/[\\t\\n]+/g, \" \"), [\"[[\", ve, \"]]\"];\n              }\n\n            case \"link\":\n              switch (pe.originalText[ae.position.start.offset]) {\n                case \"<\":\n                  {\n                    let ve = \"mailto:\",\n                        K = ae.url.startsWith(ve) && pe.originalText.slice(ae.position.start.offset + 1, ae.position.start.offset + 1 + ve.length) !== ve ? ae.url.slice(ve.length) : ae.url;\n                    return [\"<\", K, \">\"];\n                  }\n\n                case \"[\":\n                  return [\"[\", ue(ce, pe, de), \"](\", ge(ae.url, \")\"), Ae(ae.title, pe), \")\"];\n\n                default:\n                  return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);\n              }\n\n            case \"image\":\n              return [\"![\", ae.alt || \"\", \"](\", ge(ae.url, \")\"), Ae(ae.title, pe), \")\"];\n\n            case \"blockquote\":\n              return [\"> \", w(\"> \", ue(ce, pe, de))];\n\n            case \"heading\":\n              return [\"#\".repeat(ae.depth) + \" \", ue(ce, pe, de)];\n\n            case \"code\":\n              {\n                if (ae.isIndented) {\n                  let he = \" \".repeat(4);\n                  return w(he, [he, ...I(ae.value, d)]);\n                }\n\n                let ve = pe.__inJsTemplate ? \"~\" : \"`\",\n                    K = ve.repeat(Math.max(3, a(ae.value, ve) + 1));\n                return [K, ae.lang || \"\", ae.meta ? \" \" + ae.meta : \"\", d, ...I(E(ae, pe.originalText), d), d, K];\n              }\n\n            case \"html\":\n              {\n                let ve = ce.getParentNode(),\n                    K = ve.type === \"root\" && t(ve.children) === ae ? ae.value.trimEnd() : ae.value,\n                    he = /^<!--.*-->$/s.test(K);\n                return I(K, he ? d : m(v));\n              }\n\n            case \"list\":\n              {\n                let ve = R(ae, ce.getParentNode()),\n                    K = y(ae, pe);\n                return ue(ce, pe, de, {\n                  processor: (he, ye) => {\n                    let Ce = Fe(),\n                        Ie = he.getValue();\n                    if (Ie.children.length === 2 && Ie.children[1].type === \"html\" && Ie.children[0].position.start.column !== Ie.children[1].position.start.column) return [Ce, Y(he, pe, de, Ce)];\n                    return [Ce, w(\" \".repeat(Ce.length), Y(he, pe, de, Ce))];\n\n                    function Fe() {\n                      let me = ae.ordered ? (ye === 0 ? ae.start : K ? 1 : ae.start + ye) + (ve % 2 === 0 ? \". \" : \") \") : ve % 2 === 0 ? \"- \" : \"* \";\n                      return ae.isAligned || ae.hasIndentedCodeblock ? H(me, pe) : me;\n                    }\n                  }\n                });\n              }\n\n            case \"thematicBreak\":\n              {\n                let ve = ee(ce, \"list\");\n                return ve === -1 ? \"---\" : R(ce.getParentNode(ve), ce.getParentNode(ve + 1)) % 2 === 0 ? \"***\" : \"---\";\n              }\n\n            case \"linkReference\":\n              return [\"[\", ue(ce, pe, de), \"]\", ae.referenceType === \"full\" ? [\"[\", ae.identifier, \"]\"] : ae.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n\n            case \"imageReference\":\n              switch (ae.referenceType) {\n                case \"full\":\n                  return [\"![\", ae.alt || \"\", \"][\", ae.identifier, \"]\"];\n\n                default:\n                  return [\"![\", ae.alt, \"]\", ae.referenceType === \"collapsed\" ? \"[]\" : \"\"];\n              }\n\n            case \"definition\":\n              {\n                let ve = pe.proseWrap === \"always\" ? c : \" \";\n                return A([\"[\", ae.identifier, \"]:\", T([ve, ge(ae.url), ae.title === null ? \"\" : [ve, Ae(ae.title, pe, !1)]])]);\n              }\n\n            case \"footnote\":\n              return [\"[^\", ue(ce, pe, de), \"]\"];\n\n            case \"footnoteReference\":\n              return [\"[^\", ae.identifier, \"]\"];\n\n            case \"footnoteDefinition\":\n              {\n                let ve = ce.getParentNode().children[ce.getName() + 1],\n                    K = ae.children.length === 1 && ae.children[0].type === \"paragraph\" && (pe.proseWrap === \"never\" || pe.proseWrap === \"preserve\" && ae.children[0].position.start.line === ae.children[0].position.end.line);\n                return [\"[^\", ae.identifier, \"]: \", K ? ue(ce, pe, de) : A([w(\" \".repeat(4), ue(ce, pe, de, {\n                  processor: (he, ye) => ye === 0 ? A([p, de()]) : de()\n                })), ve && ve.type === \"footnoteDefinition\" ? p : \"\"])];\n              }\n\n            case \"table\":\n              return W(ce, pe, de);\n\n            case \"tableCell\":\n              return ue(ce, pe, de);\n\n            case \"break\":\n              return /\\s/.test(pe.originalText[ae.position.start.offset]) ? [\"  \", m(v)] : [\"\\\\\", d];\n\n            case \"liquidNode\":\n              return I(ae.value, d);\n\n            case \"importExport\":\n              return [ae.value, d];\n\n            case \"esComment\":\n              return [\"{/* \", ae.value, \" */}\"];\n\n            case \"jsx\":\n              return ae.value;\n\n            case \"math\":\n              return [\"$$\", d, ae.value ? [...I(ae.value, d), d] : \"\", \"$$\"];\n\n            case \"inlineMath\":\n              return pe.originalText.slice(D(ae), g(ae));\n\n            case \"tableRow\":\n            case \"listItem\":\n            default:\n              throw new Error(\"Unknown markdown type \".concat(JSON.stringify(ae.type)));\n          }\n        }\n\n        function Y(ce, pe, de, ae) {\n          let ve = ce.getValue(),\n              K = ve.checked === null ? \"\" : ve.checked ? \"[x] \" : \"[ ] \";\n          return [K, ue(ce, pe, de, {\n            processor: (he, ye) => {\n              if (ye === 0 && he.getValue().type !== \"list\") return w(\" \".repeat(K.length), de());\n              let Ce = \" \".repeat(Ne(pe.tabWidth - ae.length, 0, 3));\n              return [Ce, w(Ce, de())];\n            }\n          })];\n        }\n\n        function H(ce, pe) {\n          let de = ae();\n          return ce + \" \".repeat(de >= 4 ? 0 : de);\n\n          function ae() {\n            let ve = ce.length % pe.tabWidth;\n            return ve === 0 ? 0 : pe.tabWidth - ve;\n          }\n        }\n\n        function R(ce, pe) {\n          return Q(ce, pe, de => de.ordered === ce.ordered);\n        }\n\n        function Q(ce, pe, de) {\n          let ae = -1;\n\n          for (let ve of pe.children) if (ve.type === ce.type && de(ve) ? ae++ : ae = -1, ve === ce) return ae;\n        }\n\n        function ee(ce, pe) {\n          let de = Array.isArray(pe) ? pe : [pe],\n              ae = -1,\n              ve;\n\n          for (; ve = ce.getParentNode(++ae);) if (de.includes(ve.type)) return ae;\n\n          return -1;\n        }\n\n        function te(ce, pe) {\n          let de = ee(ce, pe);\n          return de === -1 ? null : ce.getParentNode(de);\n        }\n\n        function oe(ce, pe, de) {\n          if (de.proseWrap === \"preserve\" && pe === \"\\n\") return d;\n          let ae = de.proseWrap === \"always\" && !te(ce, $);\n          return pe !== \"\" ? ae ? c : \" \" : ae ? p : \"\";\n        }\n\n        function W(ce, pe, de) {\n          let ae = ce.getValue(),\n              ve = [],\n              K = ce.map(me => me.map((_, J) => {\n            let ne = k(de(), pe).formatted,\n                Ee = r(ne);\n            return ve[J] = Math.max(ve[J] || 3, Ee), {\n              text: ne,\n              width: Ee\n            };\n          }, \"children\"), \"children\"),\n              he = Ce(!1);\n          if (pe.proseWrap !== \"never\") return [i, he];\n          let ye = Ce(!0);\n          return [i, A(f(ye, he))];\n\n          function Ce(me) {\n            let _ = [Fe(K[0], me), Ie(me)];\n            return K.length > 1 && _.push(o(S, K.slice(1).map(J => Fe(J, me)))), o(S, _);\n          }\n\n          function Ie(me) {\n            let _ = ve.map((J, ne) => {\n              let Ee = ae.align[ne],\n                  We = Ee === \"center\" || Ee === \"left\" ? \":\" : \"-\",\n                  Be = Ee === \"center\" || Ee === \"right\" ? \":\" : \"-\",\n                  Pe = me ? \"-\" : \"-\".repeat(J - 2);\n              return \"\".concat(We).concat(Pe).concat(Be);\n            });\n\n            return \"| \".concat(_.join(\" | \"), \" |\");\n          }\n\n          function Fe(me, _) {\n            let J = me.map((ne, Ee) => {\n              let We = ne.text,\n                  Be = ne.width;\n              if (_) return We;\n              let Pe = ve[Ee] - Be,\n                  Se = ae.align[Ee],\n                  Qe = 0;\n              Se === \"right\" ? Qe = Pe : Se === \"center\" && (Qe = Math.floor(Pe / 2));\n              let xe = Pe - Qe;\n              return \"\".concat(\" \".repeat(Qe)).concat(We).concat(\" \".repeat(xe));\n            });\n            return \"| \".concat(J.join(\" | \"), \" |\");\n          }\n        }\n\n        function X(ce, pe, de) {\n          let ae = [],\n              ve = null,\n              _ce$getValue = ce.getValue(),\n              K = _ce$getValue.children;\n\n          for (let _ref41 of K.entries()) {\n            var _ref42 = _slicedToArray(_ref41, 2);\n\n            let he = _ref42[0];\n            let ye = _ref42[1];\n\n            switch (ie(ye)) {\n              case \"start\":\n                ve === null && (ve = {\n                  index: he,\n                  offset: ye.position.end.offset\n                });\n                break;\n\n              case \"end\":\n                ve !== null && (ae.push({\n                  start: ve,\n                  end: {\n                    index: he,\n                    offset: ye.position.start.offset\n                  }\n                }), ve = null);\n                break;\n\n              default:\n                break;\n            }\n          }\n\n          return ue(ce, pe, de, {\n            processor: (he, ye) => {\n              if (ae.length > 0) {\n                let Ce = ae[0];\n                if (ye === Ce.start.index) return [K[Ce.start.index].value, pe.originalText.slice(Ce.start.offset, Ce.end.offset), K[Ce.end.index].value];\n                if (Ce.start.index < ye && ye < Ce.end.index) return !1;\n                if (ye === Ce.end.index) return ae.shift(), !1;\n              }\n\n              return de();\n            }\n          });\n        }\n\n        function ue(ce, pe, de) {\n          let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},\n              ve = ae.postprocessor,\n              K = ae.processor || (() => de()),\n              he = ce.getValue(),\n              ye = [],\n              Ce;\n\n          return ce.each((Ie, Fe) => {\n            let me = Ie.getValue(),\n                _ = K(Ie, Fe);\n\n            if (_ !== !1) {\n              let J = {\n                parts: ye,\n                prevNode: Ce,\n                parentNode: he,\n                options: pe\n              };\n              G(me, J) && (ye.push(d), Ce && j.has(Ce.type) || (z(me, J) || U(me, J)) && ye.push(d), U(me, J) && ye.push(d)), ye.push(_), Ce = me;\n            }\n          }, \"children\"), ve ? ve(ye) : ye;\n        }\n\n        function De(ce) {\n          let pe = ce;\n\n          for (; u(pe.children);) pe = t(pe.children);\n\n          return pe;\n        }\n\n        function ie(ce) {\n          let pe;\n          if (ce.type === \"html\") pe = ce.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);else {\n            let de;\n            ce.type === \"esComment\" ? de = ce : ce.type === \"paragraph\" && ce.children.length === 1 && ce.children[0].type === \"esComment\" && (de = ce.children[0]), de && (pe = de.value.match(/^prettier-ignore(?:-(start|end))?$/));\n          }\n          return pe ? pe[1] || \"next\" : !1;\n        }\n\n        function G(ce, pe) {\n          let de = pe.parts.length === 0,\n              ae = b.includes(ce.type),\n              ve = ce.type === \"html\" && L.includes(pe.parentNode.type);\n          return !de && !ae && !ve;\n        }\n\n        function z(ce, pe) {\n          var de, ae, ve;\n          let he = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type),\n              ye = pe.parentNode.type === \"listItem\" && !pe.parentNode.loose,\n              Ce = ((de = pe.prevNode) === null || de === void 0 ? void 0 : de.type) === \"listItem\" && pe.prevNode.loose,\n              Ie = ie(pe.prevNode) === \"next\",\n              Fe = ce.type === \"html\" && ((ae = pe.prevNode) === null || ae === void 0 ? void 0 : ae.type) === \"html\" && pe.prevNode.position.end.line + 1 === ce.position.start.line,\n              me = ce.type === \"html\" && pe.parentNode.type === \"listItem\" && ((ve = pe.prevNode) === null || ve === void 0 ? void 0 : ve.type) === \"paragraph\" && pe.prevNode.position.end.line + 1 === ce.position.start.line;\n          return Ce || !(he || ye || Ie || Fe || me);\n        }\n\n        function U(ce, pe) {\n          let de = pe.prevNode && pe.prevNode.type === \"list\",\n              ae = ce.type === \"code\" && ce.isIndented;\n          return de && ae;\n        }\n\n        function le(ce) {\n          let pe = te(ce, [\"linkReference\", \"imageReference\"]);\n          return pe && (pe.type !== \"linkReference\" || pe.referenceType !== \"full\");\n        }\n\n        function ge(ce) {\n          let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],\n              de = [\" \", ...(Array.isArray(pe) ? pe : [pe])];\n          return new RegExp(de.map(ae => \"\\\\\".concat(ae)).join(\"|\")).test(ce) ? \"<\".concat(ce, \">\") : ce;\n        }\n\n        function Ae(ce, pe) {\n          let de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n          if (!ce) return \"\";\n          if (de) return \" \" + Ae(ce, pe, !1);\n          if (ce = ce.replace(/\\\\([\"')])/g, \"$1\"), ce.includes('\"') && ce.includes(\"'\") && !ce.includes(\")\")) return \"(\".concat(ce, \")\");\n          let ae = ce.split(\"'\").length - 1,\n              ve = ce.split('\"').length - 1,\n              K = ae > ve ? '\"' : ve > ae || pe.singleQuote ? \"'\" : '\"';\n          return ce = ce.replace(/\\\\/, \"\\\\\\\\\"), ce = ce.replace(new RegExp(\"(\".concat(K, \")\"), \"g\"), \"\\\\$1\"), \"\".concat(K).concat(ce).concat(K);\n        }\n\n        function Ne(ce, pe, de) {\n          return ce < pe ? pe : ce > de ? de : ce;\n        }\n\n        function ke(ce) {\n          let pe = Number(ce.getName());\n          if (pe === 0) return !1;\n          let de = ce.getParentNode().children[pe - 1];\n          return ie(de) === \"next\";\n        }\n\n        n.exports = {\n          preprocess: F,\n          print: q,\n          embed: P,\n          massageAstNode: l,\n          hasPrettierIgnore: ke,\n          insertPragma: C\n        };\n      }\n\n    }),\n        Gd = Z({\n      \"src/language-markdown/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot();\n        n.exports = {\n          proseWrap: t.proseWrap,\n          singleQuote: t.singleQuote\n        };\n      }\n\n    }),\n        Jd = Z({\n      \"src/language-markdown/parsers.js\"() {\n        re();\n      }\n\n    }),\n        da = Z({\n      \"node_modules/linguist-languages/data/Markdown.json\"(e, n) {\n        n.exports = {\n          name: \"Markdown\",\n          type: \"prose\",\n          color: \"#083fa1\",\n          aliases: [\"pandoc\"],\n          aceMode: \"markdown\",\n          codemirrorMode: \"gfm\",\n          codemirrorMimeType: \"text/x-gfm\",\n          wrap: !0,\n          extensions: [\".md\", \".livemd\", \".markdown\", \".mdown\", \".mdwn\", \".mdx\", \".mkd\", \".mkdn\", \".mkdown\", \".ronn\", \".scd\", \".workbook\"],\n          filenames: [\"contents.lr\"],\n          tmScope: \"source.gfm\",\n          languageId: 222\n        };\n      }\n\n    }),\n        Ud = Z({\n      \"src/language-markdown/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = Hd(),\n            a = Gd(),\n            r = Jd(),\n            u = [t(da(), o => ({\n          since: \"1.8.0\",\n          parsers: [\"markdown\"],\n          vscodeLanguageIds: [\"markdown\"],\n          filenames: [...o.filenames, \"README\"],\n          extensions: o.extensions.filter(c => c !== \".mdx\")\n        })), t(da(), () => ({\n          name: \"MDX\",\n          since: \"1.15.0\",\n          parsers: [\"mdx\"],\n          vscodeLanguageIds: [\"mdx\"],\n          filenames: [],\n          extensions: [\".mdx\"]\n        }))],\n            i = {\n          mdast: s\n        };\n        n.exports = {\n          languages: u,\n          options: a,\n          printers: i,\n          parsers: r\n        };\n      }\n\n    }),\n        zd = Z({\n      \"src/language-html/clean.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue40 = Ue(),\n            t = _Ue40.isFrontMatterNode,\n            s = new Set([\"sourceSpan\", \"startSourceSpan\", \"endSourceSpan\", \"nameSpan\", \"valueSpan\"]);\n\n        function a(r, u) {\n          if (r.type === \"text\" || r.type === \"comment\" || t(r) || r.type === \"yaml\" || r.type === \"toml\") return null;\n          r.type === \"attribute\" && delete u.value, r.type === \"docType\" && delete u.value;\n        }\n\n        a.ignoredProperties = s, n.exports = a;\n      }\n\n    }),\n        Xd = Z({\n      \"src/language-html/constants.evaluate.js\"(e, n) {\n        n.exports = {\n          CSS_DISPLAY_TAGS: {\n            area: \"none\",\n            base: \"none\",\n            basefont: \"none\",\n            datalist: \"none\",\n            head: \"none\",\n            link: \"none\",\n            meta: \"none\",\n            noembed: \"none\",\n            noframes: \"none\",\n            param: \"block\",\n            rp: \"none\",\n            script: \"block\",\n            source: \"block\",\n            style: \"none\",\n            template: \"inline\",\n            track: \"block\",\n            title: \"none\",\n            html: \"block\",\n            body: \"block\",\n            address: \"block\",\n            blockquote: \"block\",\n            center: \"block\",\n            div: \"block\",\n            figure: \"block\",\n            figcaption: \"block\",\n            footer: \"block\",\n            form: \"block\",\n            header: \"block\",\n            hr: \"block\",\n            legend: \"block\",\n            listing: \"block\",\n            main: \"block\",\n            p: \"block\",\n            plaintext: \"block\",\n            pre: \"block\",\n            xmp: \"block\",\n            slot: \"contents\",\n            ruby: \"ruby\",\n            rt: \"ruby-text\",\n            article: \"block\",\n            aside: \"block\",\n            h1: \"block\",\n            h2: \"block\",\n            h3: \"block\",\n            h4: \"block\",\n            h5: \"block\",\n            h6: \"block\",\n            hgroup: \"block\",\n            nav: \"block\",\n            section: \"block\",\n            dir: \"block\",\n            dd: \"block\",\n            dl: \"block\",\n            dt: \"block\",\n            ol: \"block\",\n            ul: \"block\",\n            li: \"list-item\",\n            table: \"table\",\n            caption: \"table-caption\",\n            colgroup: \"table-column-group\",\n            col: \"table-column\",\n            thead: \"table-header-group\",\n            tbody: \"table-row-group\",\n            tfoot: \"table-footer-group\",\n            tr: \"table-row\",\n            td: \"table-cell\",\n            th: \"table-cell\",\n            fieldset: \"block\",\n            button: \"inline-block\",\n            details: \"block\",\n            summary: \"block\",\n            dialog: \"block\",\n            meter: \"inline-block\",\n            progress: \"inline-block\",\n            object: \"inline-block\",\n            video: \"inline-block\",\n            audio: \"inline-block\",\n            select: \"inline-block\",\n            option: \"block\",\n            optgroup: \"block\"\n          },\n          CSS_DISPLAY_DEFAULT: \"inline\",\n          CSS_WHITE_SPACE_TAGS: {\n            listing: \"pre\",\n            plaintext: \"pre\",\n            pre: \"pre\",\n            xmp: \"pre\",\n            nobr: \"nowrap\",\n            table: \"initial\",\n            textarea: \"pre-wrap\"\n          },\n          CSS_WHITE_SPACE_DEFAULT: \"normal\"\n        };\n      }\n\n    }),\n        Kd = Z({\n      \"src/language-html/utils/is-unknown-namespace.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s) {\n          return s.type === \"element\" && !s.hasExplicitNamespace && ![\"html\", \"svg\"].includes(s.namespace);\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        qt = Z({\n      \"src/language-html/utils/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue41 = Ue(),\n            t = _Ue41.inferParserByLanguage,\n            s = _Ue41.isFrontMatterNode,\n            _Oe45 = Oe(),\n            _Oe45$builders = _Oe45.builders,\n            a = _Oe45$builders.line,\n            r = _Oe45$builders.hardline,\n            u = _Oe45$builders.join,\n            _Oe45$utils = _Oe45.utils,\n            i = _Oe45$utils.getDocParts,\n            o = _Oe45$utils.replaceTextEndOfLine,\n            _Xd = Xd(),\n            c = _Xd.CSS_DISPLAY_TAGS,\n            v = _Xd.CSS_DISPLAY_DEFAULT,\n            m = _Xd.CSS_WHITE_SPACE_TAGS,\n            d = _Xd.CSS_WHITE_SPACE_DEFAULT,\n            p = Kd(),\n            f = new Set([\"\t\", \"\\n\", \"\\f\", \"\\r\", \" \"]),\n            h = _ => _.replace(/^[\\t\\n\\f\\r ]+/, \"\"),\n            w = _ => _.replace(/[\\t\\n\\f\\r ]+$/, \"\"),\n            T = _ => h(w(_)),\n            A = _ => _.replace(/^[\\t\\f\\r ]*\\n/g, \"\"),\n            S = _ => A(w(_)),\n            B = _ => _.split(/[\\t\\n\\f\\r ]+/),\n            I = _ => _.match(/^[\\t\\n\\f\\r ]*/)[0],\n            k = _ => {\n          let _$match = _.match(/^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s),\n              _$match2 = _slicedToArray(_$match, 4),\n              J = _$match2[1],\n              ne = _$match2[2],\n              Ee = _$match2[3];\n\n          return {\n            leadingWhitespace: J,\n            trailingWhitespace: Ee,\n            text: ne\n          };\n        },\n            P = _ => /[\\t\\n\\f\\r ]/.test(_);\n\n        function C(_, J) {\n          return !!(_.type === \"ieConditionalComment\" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === \"ieConditionalComment\" && !_.complete || le(_) && _.children.some(ne => ne.type !== \"text\" && ne.type !== \"interpolation\") || ye(_, J) && !l(_) && _.type !== \"interpolation\");\n        }\n\n        function D(_) {\n          return _.type === \"attribute\" || !_.parent || !_.prev ? !1 : g(_.prev);\n        }\n\n        function g(_) {\n          return _.type === \"comment\" && _.value.trim() === \"prettier-ignore\";\n        }\n\n        function F(_) {\n          return _.type === \"text\" || _.type === \"comment\";\n        }\n\n        function l(_) {\n          return _.type === \"element\" && (_.fullName === \"script\" || _.fullName === \"style\" || _.fullName === \"svg:style\" || p(_) && (_.name === \"script\" || _.name === \"style\"));\n        }\n\n        function E(_) {\n          return _.children && !l(_);\n        }\n\n        function y(_) {\n          return l(_) || _.type === \"interpolation\" || N(_);\n        }\n\n        function N(_) {\n          return ke(_).startsWith(\"pre\");\n        }\n\n        function x(_, J) {\n          let ne = Ee();\n          if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf) return _.type === \"interpolation\";\n          return ne;\n\n          function Ee() {\n            return s(_) ? !1 : (_.type === \"text\" || _.type === \"interpolation\") && _.prev && (_.prev.type === \"text\" || _.prev.type === \"interpolation\") ? !0 : !_.parent || _.parent.cssDisplay === \"none\" ? !1 : le(_.parent) ? !0 : !(!_.prev && (_.parent.type === \"root\" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !De(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));\n          }\n        }\n\n        function b(_, J) {\n          return s(_) ? !1 : (_.type === \"text\" || _.type === \"interpolation\") && _.next && (_.next.type === \"text\" || _.next.type === \"interpolation\") ? !0 : !_.parent || _.parent.cssDisplay === \"none\" ? !1 : le(_.parent) ? !0 : !(!_.next && (_.parent.type === \"root\" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));\n        }\n\n        function L(_) {\n          return U(_.cssDisplay) && !l(_);\n        }\n\n        function M(_) {\n          return s(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;\n        }\n\n        function j(_) {\n          return $(_) || _.type === \"element\" && _.children.length > 0 && ([\"body\", \"script\", \"style\"].includes(_.name) || _.children.some(J => te(J))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== \"text\" && H(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));\n        }\n\n        function $(_) {\n          return _.type === \"element\" && _.children.length > 0 && ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(_.name) || _.cssDisplay.startsWith(\"table\") && _.cssDisplay !== \"table-cell\");\n        }\n\n        function V(_) {\n          return Q(_) || _.prev && q(_.prev) || Y(_);\n        }\n\n        function q(_) {\n          return Q(_) || _.type === \"element\" && _.fullName === \"br\" || Y(_);\n        }\n\n        function Y(_) {\n          return H(_) && R(_);\n        }\n\n        function H(_) {\n          return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === \"root\" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);\n        }\n\n        function R(_) {\n          return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === \"root\" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);\n        }\n\n        function Q(_) {\n          switch (_.type) {\n            case \"ieConditionalComment\":\n            case \"comment\":\n            case \"directive\":\n              return !0;\n\n            case \"element\":\n              return [\"script\", \"select\"].includes(_.name);\n          }\n\n          return !1;\n        }\n\n        function ee(_) {\n          return _.lastChild ? ee(_.lastChild) : _;\n        }\n\n        function te(_) {\n          return _.children && _.children.some(J => J.type !== \"text\");\n        }\n\n        function oe(_) {\n          let _$attrMap = _.attrMap,\n              J = _$attrMap.type,\n              ne = _$attrMap.lang;\n          if (J === \"module\" || J === \"text/javascript\" || J === \"text/babel\" || J === \"application/javascript\" || ne === \"jsx\") return \"babel\";\n          if (J === \"application/x-typescript\" || ne === \"ts\" || ne === \"tsx\") return \"typescript\";\n          if (J === \"text/markdown\") return \"markdown\";\n          if (J === \"text/html\") return \"html\";\n          if (J && (J.endsWith(\"json\") || J.endsWith(\"importmap\")) || J === \"speculationrules\") return \"json\";\n          if (J === \"text/x-handlebars-template\") return \"glimmer\";\n        }\n\n        function W(_, J) {\n          let ne = _.attrMap.lang;\n          if (!ne || ne === \"postcss\" || ne === \"css\") return \"css\";\n          if (ne === \"scss\") return \"scss\";\n          if (ne === \"less\") return \"less\";\n          if (ne === \"stylus\") return t(\"stylus\", J);\n        }\n\n        function X(_, J) {\n          if (_.name === \"script\" && !_.attrMap.src) return !_.attrMap.lang && !_.attrMap.type ? \"babel\" : oe(_);\n          if (_.name === \"style\") return W(_, J);\n          if (J && ye(_, J)) return oe(_) || !(\"src\" in _.attrMap) && t(_.attrMap.lang, J);\n        }\n\n        function ue(_) {\n          return _ === \"block\" || _ === \"list-item\" || _.startsWith(\"table\");\n        }\n\n        function De(_) {\n          return !ue(_) && _ !== \"inline-block\";\n        }\n\n        function ie(_) {\n          return !ue(_) && _ !== \"inline-block\";\n        }\n\n        function G(_) {\n          return !ue(_);\n        }\n\n        function z(_) {\n          return !ue(_);\n        }\n\n        function U(_) {\n          return !ue(_) && _ !== \"inline-block\";\n        }\n\n        function le(_) {\n          return ke(_).startsWith(\"pre\");\n        }\n\n        function ge(_, J) {\n          let ne = 0;\n\n          for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {\n            let We = _.stack[Ee];\n            We && typeof We == \"object\" && !Array.isArray(We) && J(We) && ne++;\n          }\n\n          return ne;\n        }\n\n        function Ae(_, J) {\n          let ne = _;\n\n          for (; ne;) {\n            if (J(ne)) return !0;\n            ne = ne.parent;\n          }\n\n          return !1;\n        }\n\n        function Ne(_, J) {\n          if (_.prev && _.prev.type === \"comment\") {\n            let Ee = _.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);\n\n            if (Ee) return Ee[1];\n          }\n\n          let ne = !1;\n          if (_.type === \"element\" && _.namespace === \"svg\") if (Ae(_, Ee => Ee.fullName === \"svg:foreignObject\")) ne = !0;else return _.name === \"svg\" ? \"inline-block\" : \"block\";\n\n          switch (J.htmlWhitespaceSensitivity) {\n            case \"strict\":\n              return \"inline\";\n\n            case \"ignore\":\n              return \"block\";\n\n            default:\n              return J.parser === \"vue\" && _.parent && _.parent.type === \"root\" ? \"block\" : _.type === \"element\" && (!_.namespace || ne || p(_)) && c[_.name] || v;\n          }\n        }\n\n        function ke(_) {\n          return _.type === \"element\" && (!_.namespace || p(_)) && m[_.name] || d;\n        }\n\n        function ce(_) {\n          let J = Number.POSITIVE_INFINITY;\n\n          for (let ne of _.split(\"\\n\")) {\n            if (ne.length === 0) continue;\n            if (!f.has(ne[0])) return 0;\n            let Ee = I(ne).length;\n            ne.length !== Ee && Ee < J && (J = Ee);\n          }\n\n          return J === Number.POSITIVE_INFINITY ? 0 : J;\n        }\n\n        function pe(_) {\n          let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);\n          return J === 0 ? _ : _.split(\"\\n\").map(ne => ne.slice(J)).join(\"\\n\");\n        }\n\n        function de(_, J) {\n          let ne = 0;\n\n          for (let Ee = 0; Ee < _.length; Ee++) _[Ee] === J && ne++;\n\n          return ne;\n        }\n\n        function ae(_) {\n          return _.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n        }\n\n        var ve = new Set([\"template\", \"style\", \"script\"]);\n\n        function K(_, J) {\n          return he(_, J) && !ve.has(_.fullName);\n        }\n\n        function he(_, J) {\n          return J.parser === \"vue\" && _.type === \"element\" && _.parent.type === \"root\" && _.fullName.toLowerCase() !== \"html\";\n        }\n\n        function ye(_, J) {\n          return he(_, J) && (K(_, J) || _.attrMap.lang && _.attrMap.lang !== \"html\");\n        }\n\n        function Ce(_) {\n          let J = _.fullName;\n          return J.charAt(0) === \"#\" || J === \"slot-scope\" || J === \"v-slot\" || J.startsWith(\"v-slot:\");\n        }\n\n        function Ie(_, J) {\n          let ne = _.parent;\n          if (!he(ne, J)) return !1;\n          let Ee = ne.fullName,\n              We = _.fullName;\n          return Ee === \"script\" && We === \"setup\" || Ee === \"style\" && We === \"vars\";\n        }\n\n        function Fe(_) {\n          let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;\n          return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J) : o(pe(S(J)), r) : i(u(a, B(J)));\n        }\n\n        function me(_, J) {\n          return he(_, J) && _.name === \"script\";\n        }\n\n        n.exports = {\n          htmlTrim: T,\n          htmlTrimPreserveIndentation: S,\n          hasHtmlWhitespace: P,\n          getLeadingAndTrailingHtmlWhitespace: k,\n          canHaveInterpolation: E,\n          countChars: de,\n          countParents: ge,\n          dedentString: pe,\n          forceBreakChildren: $,\n          forceBreakContent: j,\n          forceNextEmptyLine: M,\n          getLastDescendant: ee,\n          getNodeCssStyleDisplay: Ne,\n          getNodeCssStyleWhiteSpace: ke,\n          hasPrettierIgnore: D,\n          inferScriptParser: X,\n          isVueCustomBlock: K,\n          isVueNonHtmlBlock: ye,\n          isVueScriptTag: me,\n          isVueSlotAttribute: Ce,\n          isVueSfcBindingsAttribute: Ie,\n          isVueSfcBlock: he,\n          isDanglingSpaceSensitiveNode: L,\n          isIndentationSensitiveNode: N,\n          isLeadingSpaceSensitiveNode: x,\n          isPreLikeNode: le,\n          isScriptLikeTag: l,\n          isTextLikeNode: F,\n          isTrailingSpaceSensitiveNode: b,\n          isWhitespaceSensitiveNode: y,\n          isUnknownNamespace: p,\n          preferHardlineAsLeadingSpaces: V,\n          preferHardlineAsTrailingSpaces: q,\n          shouldPreserveContent: C,\n          unescapeQuoteEntities: ae,\n          getTextValueParts: Fe\n        };\n      }\n\n    }),\n        Yd = Z({\n      \"node_modules/angular-html-parser/lib/compiler/src/chars.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;\n\n        function n(i) {\n          return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;\n        }\n\n        e.isWhitespace = n;\n\n        function t(i) {\n          return e.$0 <= i && i <= e.$9;\n        }\n\n        e.isDigit = t;\n\n        function s(i) {\n          return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;\n        }\n\n        e.isAsciiLetter = s;\n\n        function a(i) {\n          return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);\n        }\n\n        e.isAsciiHexDigit = a;\n\n        function r(i) {\n          return i === e.$LF || i === e.$CR;\n        }\n\n        e.isNewLine = r;\n\n        function u(i) {\n          return e.$0 <= i && i <= e.$7;\n        }\n\n        e.isOctalDigit = u;\n      }\n\n    }),\n        Qd = Z({\n      \"node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = class {\n          constructor(s, a, r) {\n            this.filePath = s, this.name = a, this.members = r;\n          }\n\n          assertNoMembers() {\n            if (this.members.length) throw new Error(\"Illegal state: symbol without members expected, but got \".concat(JSON.stringify(this), \".\"));\n          }\n\n        };\n        e.StaticSymbol = n;\n        var t = class {\n          constructor() {\n            this.cache = new Map();\n          }\n\n          get(s, a, r) {\n            r = r || [];\n            let u = r.length ? \".\".concat(r.join(\".\")) : \"\",\n                i = '\"'.concat(s, '\".').concat(a).concat(u),\n                o = this.cache.get(i);\n            return o || (o = new n(s, a, r), this.cache.set(i, o)), o;\n          }\n\n        };\n        e.StaticSymbolCache = t;\n      }\n\n    }),\n        Zd = Z({\n      \"node_modules/angular-html-parser/lib/compiler/src/util.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = /-+([a-z0-9])/g;\n\n        function t(l) {\n          return l.replace(n, function () {\n            for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++) y[N] = arguments[N];\n\n            return y[1].toUpperCase();\n          });\n        }\n\n        e.dashCaseToCamelCase = t;\n\n        function s(l, E) {\n          return r(l, \":\", E);\n        }\n\n        e.splitAtColon = s;\n\n        function a(l, E) {\n          return r(l, \".\", E);\n        }\n\n        e.splitAtPeriod = a;\n\n        function r(l, E, y) {\n          let N = l.indexOf(E);\n          return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];\n        }\n\n        function u(l, E, y) {\n          return Array.isArray(l) ? E.visitArray(l, y) : A(l) ? E.visitStringMap(l, y) : l == null || typeof l == \"string\" || typeof l == \"number\" || typeof l == \"boolean\" ? E.visitPrimitive(l, y) : E.visitOther(l, y);\n        }\n\n        e.visitValue = u;\n\n        function i(l) {\n          return l != null;\n        }\n\n        e.isDefined = i;\n\n        function o(l) {\n          return l === void 0 ? null : l;\n        }\n\n        e.noUndefined = o;\n        var c = class {\n          visitArray(l, E) {\n            return l.map(y => u(y, this, E));\n          }\n\n          visitStringMap(l, E) {\n            let y = {};\n            return Object.keys(l).forEach(N => {\n              y[N] = u(l[N], this, E);\n            }), y;\n          }\n\n          visitPrimitive(l, E) {\n            return l;\n          }\n\n          visitOther(l, E) {\n            return l;\n          }\n\n        };\n        e.ValueTransformer = c, e.SyncAsync = {\n          assertSync: l => {\n            if (k(l)) throw new Error(\"Illegal state: value cannot be a promise\");\n            return l;\n          },\n          then: (l, E) => k(l) ? l.then(E) : E(l),\n          all: l => l.some(k) ? Promise.all(l) : l\n        };\n\n        function v(l) {\n          throw new Error(\"Internal Error: \".concat(l));\n        }\n\n        e.error = v;\n\n        function m(l, E) {\n          let y = Error(l);\n          return y[d] = !0, E && (y[p] = E), y;\n        }\n\n        e.syntaxError = m;\n        var d = \"ngSyntaxError\",\n            p = \"ngParseErrors\";\n\n        function f(l) {\n          return l[d];\n        }\n\n        e.isSyntaxError = f;\n\n        function h(l) {\n          return l[p] || [];\n        }\n\n        e.getParseErrors = h;\n\n        function w(l) {\n          return l.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n        }\n\n        e.escapeRegExp = w;\n        var T = Object.getPrototypeOf({});\n\n        function A(l) {\n          return typeof l == \"object\" && l !== null && Object.getPrototypeOf(l) === T;\n        }\n\n        function S(l) {\n          let E = \"\";\n\n          for (let y = 0; y < l.length; y++) {\n            let N = l.charCodeAt(y);\n\n            if (N >= 55296 && N <= 56319 && l.length > y + 1) {\n              let x = l.charCodeAt(y + 1);\n              x >= 56320 && x <= 57343 && (y++, N = (N - 55296 << 10) + x - 56320 + 65536);\n            }\n\n            N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));\n          }\n\n          return E;\n        }\n\n        e.utf8Encode = S;\n\n        function B(l) {\n          if (typeof l == \"string\") return l;\n          if (l instanceof Array) return \"[\" + l.map(B).join(\", \") + \"]\";\n          if (l == null) return \"\" + l;\n          if (l.overriddenName) return \"\".concat(l.overriddenName);\n          if (l.name) return \"\".concat(l.name);\n          if (!l.toString) return \"object\";\n          let E = l.toString();\n          if (E == null) return \"\" + E;\n          let y = E.indexOf(\"\\n\");\n          return y === -1 ? E : E.substring(0, y);\n        }\n\n        e.stringify = B;\n\n        function I(l) {\n          return typeof l == \"function\" && l.hasOwnProperty(\"__forward_ref__\") ? l() : l;\n        }\n\n        e.resolveForwardRef = I;\n\n        function k(l) {\n          return !!l && typeof l.then == \"function\";\n        }\n\n        e.isPromise = k;\n        var P = class {\n          constructor(l) {\n            this.full = l;\n            let E = l.split(\".\");\n            this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(\".\");\n          }\n\n        };\n        e.Version = P;\n        var C = typeof window < \"u\" && window,\n            D = typeof self < \"u\" && typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope && self,\n            g = typeof globalThis < \"u\" && globalThis,\n            F = g || C || D;\n        e.global = F;\n      }\n\n    }),\n        eg = Z({\n      \"node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = Qd(),\n            t = Zd(),\n            s = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n\n        function a(y) {\n          return y.replace(/\\W/g, \"_\");\n        }\n\n        e.sanitizeIdentifier = a;\n        var r = 0;\n\n        function u(y) {\n          if (!y || !y.reference) return null;\n          let N = y.reference;\n          if (N instanceof n.StaticSymbol) return N.name;\n          if (N.__anonymousType) return N.__anonymousType;\n          let x = t.stringify(N);\n          return x.indexOf(\"(\") >= 0 ? (x = \"anonymous_\".concat(r++), N.__anonymousType = x) : x = a(x), x;\n        }\n\n        e.identifierName = u;\n\n        function i(y) {\n          let N = y.reference;\n          return N instanceof n.StaticSymbol ? N.filePath : \"./\".concat(t.stringify(N));\n        }\n\n        e.identifierModuleUrl = i;\n\n        function o(y, N) {\n          return \"View_\".concat(u({\n            reference: y\n          }), \"_\").concat(N);\n        }\n\n        e.viewClassName = o;\n\n        function c(y) {\n          return \"RenderType_\".concat(u({\n            reference: y\n          }));\n        }\n\n        e.rendererTypeName = c;\n\n        function v(y) {\n          return \"HostView_\".concat(u({\n            reference: y\n          }));\n        }\n\n        e.hostViewClassName = v;\n\n        function m(y) {\n          return \"\".concat(u({\n            reference: y\n          }), \"NgFactory\");\n        }\n\n        e.componentFactoryName = m;\n        var d;\n\n        (function (y) {\n          y[y.Pipe = 0] = \"Pipe\", y[y.Directive = 1] = \"Directive\", y[y.NgModule = 2] = \"NgModule\", y[y.Injectable = 3] = \"Injectable\";\n        })(d = e.CompileSummaryKind || (e.CompileSummaryKind = {}));\n\n        function p(y) {\n          return y.value != null ? a(y.value) : u(y.identifier);\n        }\n\n        e.tokenName = p;\n\n        function f(y) {\n          return y.identifier != null ? y.identifier.reference : y.value;\n        }\n\n        e.tokenReference = f;\n        var h = class {\n          constructor() {\n            let _ref43 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n                y = _ref43.moduleUrl,\n                N = _ref43.styles,\n                x = _ref43.styleUrls;\n\n            this.moduleUrl = y || null, this.styles = k(N), this.styleUrls = k(x);\n          }\n\n        };\n        e.CompileStylesheetMetadata = h;\n        var w = class {\n          constructor(y) {\n            let N = y.encapsulation,\n                x = y.template,\n                b = y.templateUrl,\n                L = y.htmlAst,\n                M = y.styles,\n                j = y.styleUrls,\n                $ = y.externalStylesheets,\n                V = y.animations,\n                q = y.ngContentSelectors,\n                Y = y.interpolation,\n                H = y.isInline,\n                R = y.preserveWhitespaces;\n            if (this.encapsulation = N, this.template = x, this.templateUrl = b, this.htmlAst = L, this.styles = k(M), this.styleUrls = k(j), this.externalStylesheets = k($), this.animations = V ? C(V) : [], this.ngContentSelectors = q || [], Y && Y.length != 2) throw new Error(\"'interpolation' should have a start and an end symbol.\");\n            this.interpolation = Y, this.isInline = H, this.preserveWhitespaces = R;\n          }\n\n          toSummary() {\n            return {\n              ngContentSelectors: this.ngContentSelectors,\n              encapsulation: this.encapsulation,\n              styles: this.styles,\n              animations: this.animations\n            };\n          }\n\n        };\n        e.CompileTemplateMetadata = w;\n        var T = class {\n          static create(y) {\n            let N = y.isHost,\n                x = y.type,\n                b = y.isComponent,\n                L = y.selector,\n                M = y.exportAs,\n                j = y.changeDetection,\n                $ = y.inputs,\n                V = y.outputs,\n                q = y.host,\n                Y = y.providers,\n                H = y.viewProviders,\n                R = y.queries,\n                Q = y.guards,\n                ee = y.viewQueries,\n                te = y.entryComponents,\n                oe = y.template,\n                W = y.componentViewType,\n                X = y.rendererType,\n                ue = y.componentFactory,\n                De = {},\n                ie = {},\n                G = {};\n            q != null && Object.keys(q).forEach(le => {\n              let ge = q[le],\n                  Ae = le.match(s);\n              Ae === null ? G[le] = ge : Ae[1] != null ? ie[Ae[1]] = ge : Ae[2] != null && (De[Ae[2]] = ge);\n            });\n            let z = {};\n            $ != null && $.forEach(le => {\n              let ge = t.splitAtColon(le, [le, le]);\n              z[ge[0]] = ge[1];\n            });\n            let U = {};\n            return V != null && V.forEach(le => {\n              let ge = t.splitAtColon(le, [le, le]);\n              U[ge[0]] = ge[1];\n            }), new T({\n              isHost: N,\n              type: x,\n              isComponent: !!b,\n              selector: L,\n              exportAs: M,\n              changeDetection: j,\n              inputs: z,\n              outputs: U,\n              hostListeners: De,\n              hostProperties: ie,\n              hostAttributes: G,\n              providers: Y,\n              viewProviders: H,\n              queries: R,\n              guards: Q,\n              viewQueries: ee,\n              entryComponents: te,\n              template: oe,\n              componentViewType: W,\n              rendererType: X,\n              componentFactory: ue\n            });\n          }\n\n          constructor(y) {\n            let N = y.isHost,\n                x = y.type,\n                b = y.isComponent,\n                L = y.selector,\n                M = y.exportAs,\n                j = y.changeDetection,\n                $ = y.inputs,\n                V = y.outputs,\n                q = y.hostListeners,\n                Y = y.hostProperties,\n                H = y.hostAttributes,\n                R = y.providers,\n                Q = y.viewProviders,\n                ee = y.queries,\n                te = y.guards,\n                oe = y.viewQueries,\n                W = y.entryComponents,\n                X = y.template,\n                ue = y.componentViewType,\n                De = y.rendererType,\n                ie = y.componentFactory;\n            this.isHost = !!N, this.type = x, this.isComponent = b, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y, this.hostAttributes = H, this.providers = k(R), this.viewProviders = k(Q), this.queries = k(ee), this.guards = te, this.viewQueries = k(oe), this.entryComponents = k(W), this.template = X, this.componentViewType = ue, this.rendererType = De, this.componentFactory = ie;\n          }\n\n          toSummary() {\n            return {\n              summaryKind: d.Directive,\n              type: this.type,\n              isComponent: this.isComponent,\n              selector: this.selector,\n              exportAs: this.exportAs,\n              inputs: this.inputs,\n              outputs: this.outputs,\n              hostListeners: this.hostListeners,\n              hostProperties: this.hostProperties,\n              hostAttributes: this.hostAttributes,\n              providers: this.providers,\n              viewProviders: this.viewProviders,\n              queries: this.queries,\n              guards: this.guards,\n              viewQueries: this.viewQueries,\n              entryComponents: this.entryComponents,\n              changeDetection: this.changeDetection,\n              template: this.template && this.template.toSummary(),\n              componentViewType: this.componentViewType,\n              rendererType: this.rendererType,\n              componentFactory: this.componentFactory\n            };\n          }\n\n        };\n        e.CompileDirectiveMetadata = T;\n        var A = class {\n          constructor(y) {\n            let N = y.type,\n                x = y.name,\n                b = y.pure;\n            this.type = N, this.name = x, this.pure = !!b;\n          }\n\n          toSummary() {\n            return {\n              summaryKind: d.Pipe,\n              type: this.type,\n              name: this.name,\n              pure: this.pure\n            };\n          }\n\n        };\n        e.CompilePipeMetadata = A;\n        var S = class {};\n        e.CompileShallowModuleMetadata = S;\n        var B = class {\n          constructor(y) {\n            let N = y.type,\n                x = y.providers,\n                b = y.declaredDirectives,\n                L = y.exportedDirectives,\n                M = y.declaredPipes,\n                j = y.exportedPipes,\n                $ = y.entryComponents,\n                V = y.bootstrapComponents,\n                q = y.importedModules,\n                Y = y.exportedModules,\n                H = y.schemas,\n                R = y.transitiveModule,\n                Q = y.id;\n            this.type = N || null, this.declaredDirectives = k(b), this.exportedDirectives = k(L), this.declaredPipes = k(M), this.exportedPipes = k(j), this.providers = k(x), this.entryComponents = k($), this.bootstrapComponents = k(V), this.importedModules = k(q), this.exportedModules = k(Y), this.schemas = k(H), this.id = Q || null, this.transitiveModule = R || null;\n          }\n\n          toSummary() {\n            let y = this.transitiveModule;\n            return {\n              summaryKind: d.NgModule,\n              type: this.type,\n              entryComponents: y.entryComponents,\n              providers: y.providers,\n              modules: y.modules,\n              exportedDirectives: y.exportedDirectives,\n              exportedPipes: y.exportedPipes\n            };\n          }\n\n        };\n        e.CompileNgModuleMetadata = B;\n        var I = class {\n          constructor() {\n            this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];\n          }\n\n          addProvider(y, N) {\n            this.providers.push({\n              provider: y,\n              module: N\n            });\n          }\n\n          addDirective(y) {\n            this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));\n          }\n\n          addExportedDirective(y) {\n            this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));\n          }\n\n          addPipe(y) {\n            this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));\n          }\n\n          addExportedPipe(y) {\n            this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));\n          }\n\n          addModule(y) {\n            this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));\n          }\n\n          addEntryComponent(y) {\n            this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));\n          }\n\n        };\n        e.TransitiveCompileNgModuleMetadata = I;\n\n        function k(y) {\n          return y || [];\n        }\n\n        var P = class {\n          constructor(y, N) {\n            let x = N.useClass,\n                b = N.useValue,\n                L = N.useExisting,\n                M = N.useFactory,\n                j = N.deps,\n                $ = N.multi;\n            this.token = y, this.useClass = x || null, this.useValue = b, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!$;\n          }\n\n        };\n        e.ProviderMeta = P;\n\n        function C(y) {\n          return y.reduce((N, x) => {\n            let b = Array.isArray(x) ? C(x) : x;\n            return N.concat(b);\n          }, []);\n        }\n\n        e.flatten = C;\n\n        function D(y) {\n          return y.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, \"ng:///\");\n        }\n\n        function g(y, N, x) {\n          let b;\n          return x.isInline ? N.type.reference instanceof n.StaticSymbol ? b = \"\".concat(N.type.reference.filePath, \".\").concat(N.type.reference.name, \".html\") : b = \"\".concat(u(y), \"/\").concat(u(N.type), \".html\") : b = x.templateUrl, N.type.reference instanceof n.StaticSymbol ? b : D(b);\n        }\n\n        e.templateSourceUrl = g;\n\n        function F(y, N) {\n          let x = y.moduleUrl.split(/\\/\\\\/g),\n              b = x[x.length - 1];\n          return D(\"css/\".concat(N).concat(b, \".ngstyle.js\"));\n        }\n\n        e.sharedStylesheetJitUrl = F;\n\n        function l(y) {\n          return D(\"\".concat(u(y.type), \"/module.ngfactory.js\"));\n        }\n\n        e.ngModuleJitUrl = l;\n\n        function E(y, N) {\n          return D(\"\".concat(u(y), \"/\").concat(u(N.type), \".ngfactory.js\"));\n        }\n\n        e.templateJitUrl = E;\n      }\n\n    }),\n        tg = Z({\n      \"node_modules/angular-html-parser/lib/compiler/src/parse_util.js\"(e) {\n        \"use strict\";\n\n        re(), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n        var n = Yd(),\n            t = eg(),\n            s = class {\n          constructor(v, m, d, p) {\n            this.file = v, this.offset = m, this.line = d, this.col = p;\n          }\n\n          toString() {\n            return this.offset != null ? \"\".concat(this.file.url, \"@\").concat(this.line, \":\").concat(this.col) : this.file.url;\n          }\n\n          moveBy(v) {\n            let m = this.file.content,\n                d = m.length,\n                p = this.offset,\n                f = this.line,\n                h = this.col;\n\n            for (; p > 0 && v < 0;) if (p--, v++, m.charCodeAt(p) == n.$LF) {\n              f--;\n              let T = m.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));\n              h = T > 0 ? p - T : p;\n            } else h--;\n\n            for (; p < d && v > 0;) {\n              let w = m.charCodeAt(p);\n              p++, v--, w == n.$LF ? (f++, h = 0) : h++;\n            }\n\n            return new s(this.file, p, f, h);\n          }\n\n          getContext(v, m) {\n            let d = this.file.content,\n                p = this.offset;\n\n            if (p != null) {\n              p > d.length - 1 && (p = d.length - 1);\n              let f = p,\n                  h = 0,\n                  w = 0;\n\n              for (; h < v && p > 0 && (p--, h++, !(d[p] == \"\\n\" && ++w == m)););\n\n              for (h = 0, w = 0; h < v && f < d.length - 1 && (f++, h++, !(d[f] == \"\\n\" && ++w == m)););\n\n              return {\n                before: d.substring(p, this.offset),\n                after: d.substring(this.offset, f + 1)\n              };\n            }\n\n            return null;\n          }\n\n        };\n        e.ParseLocation = s;\n        var a = class {\n          constructor(v, m) {\n            this.content = v, this.url = m;\n          }\n\n        };\n        e.ParseSourceFile = a;\n        var r = class {\n          constructor(v, m) {\n            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n            this.start = v, this.end = m, this.details = d;\n          }\n\n          toString() {\n            return this.start.file.content.substring(this.start.offset, this.end.offset);\n          }\n\n        };\n        e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a(\"\", \"\"), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);\n        var u;\n\n        (function (v) {\n          v[v.WARNING = 0] = \"WARNING\", v[v.ERROR = 1] = \"ERROR\";\n        })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));\n\n        var i = class {\n          constructor(v, m) {\n            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;\n            this.span = v, this.msg = m, this.level = d;\n          }\n\n          contextualMessage() {\n            let v = this.span.start.getContext(100, 3);\n            return v ? \"\".concat(this.msg, ' (\"').concat(v.before, \"[\").concat(u[this.level], \" ->]\").concat(v.after, '\")') : this.msg;\n          }\n\n          toString() {\n            let v = this.span.details ? \", \".concat(this.span.details) : \"\";\n            return \"\".concat(this.contextualMessage(), \": \").concat(this.span.start).concat(v);\n          }\n\n        };\n        e.ParseError = i;\n\n        function o(v, m) {\n          let d = t.identifierModuleUrl(m),\n              p = d != null ? \"in \".concat(v, \" \").concat(t.identifierName(m), \" in \").concat(d) : \"in \".concat(v, \" \").concat(t.identifierName(m)),\n              f = new a(\"\", p);\n          return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n        }\n\n        e.typeSourceSpan = o;\n\n        function c(v, m, d) {\n          let p = \"in \".concat(v, \" \").concat(m, \" in \").concat(d),\n              f = new a(\"\", p);\n          return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));\n        }\n\n        e.r3JitTypeSourceSpan = c;\n      }\n\n    }),\n        rg = Z({\n      \"src/language-html/print-preprocess.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _tg = tg(),\n            t = _tg.ParseSourceSpan,\n            _qt = qt(),\n            s = _qt.htmlTrim,\n            a = _qt.getLeadingAndTrailingHtmlWhitespace,\n            r = _qt.hasHtmlWhitespace,\n            u = _qt.canHaveInterpolation,\n            i = _qt.getNodeCssStyleDisplay,\n            o = _qt.isDanglingSpaceSensitiveNode,\n            c = _qt.isIndentationSensitiveNode,\n            v = _qt.isLeadingSpaceSensitiveNode,\n            m = _qt.isTrailingSpaceSensitiveNode,\n            d = _qt.isWhitespaceSensitiveNode,\n            p = _qt.isVueScriptTag,\n            f = [w, T, S, I, k, D, P, C, g, B, F];\n\n        function h(l, E) {\n          for (let y of f) y(l, E);\n\n          return l;\n        }\n\n        function w(l) {\n          l.walk(E => {\n            if (E.type === \"element\" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === \"text\" && E.children[0].value[0] === \"\\n\") {\n              let y = E.children[0];\n              y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);\n            }\n          });\n        }\n\n        function T(l) {\n          let E = y => y.type === \"element\" && y.prev && y.prev.type === \"ieConditionalStartComment\" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === \"ieConditionalEndComment\" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;\n\n          l.walk(y => {\n            if (y.children) for (let N = 0; N < y.children.length; N++) {\n              let x = y.children[N];\n              if (!E(x)) continue;\n              let b = x.prev,\n                  L = x.firstChild;\n              y.removeChild(b), N--;\n              let M = new t(b.sourceSpan.start, L.sourceSpan.end),\n                  j = new t(M.start, x.sourceSpan.end);\n              x.condition = b.condition, x.sourceSpan = j, x.startSourceSpan = M, x.removeChild(L);\n            }\n          });\n        }\n\n        function A(l, E, y) {\n          l.walk(N => {\n            if (N.children) for (let x = 0; x < N.children.length; x++) {\n              let b = N.children[x];\n              if (b.type !== \"text\" && !E(b)) continue;\n              b.type !== \"text\" && (b.type = \"text\", b.value = y(b));\n              let L = b.prev;\n              !L || L.type !== \"text\" || (L.value += b.value, L.sourceSpan = new t(L.sourceSpan.start, b.sourceSpan.end), N.removeChild(b), x--);\n            }\n          });\n        }\n\n        function S(l) {\n          return A(l, E => E.type === \"cdata\", E => \"<![CDATA[\".concat(E.value, \"]]>\"));\n        }\n\n        function B(l) {\n          let E = y => y.type === \"element\" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === \"text\" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === \"text\" && y.next && y.next.type === \"text\";\n\n          l.walk(y => {\n            if (y.children) for (let N = 0; N < y.children.length; N++) {\n              let x = y.children[N];\n              if (!E(x)) continue;\n              let b = x.prev,\n                  L = x.next;\n              b.value += \"<\".concat(x.rawName, \">\") + x.firstChild.value + \"</\".concat(x.rawName, \">\") + L.value, b.sourceSpan = new t(b.sourceSpan.start, L.sourceSpan.end), b.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x), N--, y.removeChild(L);\n            }\n          });\n        }\n\n        function I(l, E) {\n          if (E.parser === \"html\") return;\n          let y = /{{(.+?)}}/s;\n          l.walk(N => {\n            if (!!u(N)) for (let x of N.children) {\n              if (x.type !== \"text\") continue;\n              let b = x.sourceSpan.start,\n                  L = null,\n                  M = x.value.split(y);\n\n              for (let j = 0; j < M.length; j++, b = L) {\n                let $ = M[j];\n\n                if (j % 2 === 0) {\n                  L = b.moveBy($.length), $.length > 0 && N.insertChildBefore(x, {\n                    type: \"text\",\n                    value: $,\n                    sourceSpan: new t(b, L)\n                  });\n                  continue;\n                }\n\n                L = b.moveBy($.length + 4), N.insertChildBefore(x, {\n                  type: \"interpolation\",\n                  sourceSpan: new t(b, L),\n                  children: $.length === 0 ? [] : [{\n                    type: \"text\",\n                    value: $,\n                    sourceSpan: new t(b.moveBy(2), L.moveBy(-2))\n                  }]\n                });\n              }\n\n              N.removeChild(x);\n            }\n          });\n        }\n\n        function k(l) {\n          l.walk(E => {\n            if (!E.children) return;\n\n            if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === \"text\" && s(E.children[0].value).length === 0) {\n              E.hasDanglingSpaces = E.children.length > 0, E.children = [];\n              return;\n            }\n\n            let y = d(E),\n                N = c(E);\n            if (!y) for (let x = 0; x < E.children.length; x++) {\n              let b = E.children[x];\n              if (b.type !== \"text\") continue;\n\n              let _a5 = a(b.value),\n                  L = _a5.leadingWhitespace,\n                  M = _a5.text,\n                  j = _a5.trailingWhitespace,\n                  $ = b.prev,\n                  V = b.next;\n\n              M ? (b.value = M, b.sourceSpan = new t(b.sourceSpan.start.moveBy(L.length), b.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = !0), b.hasLeadingSpaces = !0), j && (b.hasTrailingSpaces = !0, V && (V.hasLeadingSpaces = !0))) : (E.removeChild(b), x--, (L || j) && ($ && ($.hasTrailingSpaces = !0), V && (V.hasLeadingSpaces = !0)));\n            }\n            E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;\n          });\n        }\n\n        function P(l) {\n          l.walk(E => {\n            E.isSelfClosing = !E.children || E.type === \"element\" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);\n          });\n        }\n\n        function C(l, E) {\n          l.walk(y => {\n            y.type === \"element\" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\\s*\\/\\s*\\/\\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));\n          });\n        }\n\n        function D(l, E) {\n          l.walk(y => {\n            y.cssDisplay = i(y, E);\n          });\n        }\n\n        function g(l, E) {\n          l.walk(y => {\n            let N = y.children;\n\n            if (!!N) {\n              if (N.length === 0) {\n                y.isDanglingSpaceSensitive = o(y);\n                return;\n              }\n\n              for (let x of N) x.isLeadingSpaceSensitive = v(x, E), x.isTrailingSpaceSensitive = m(x, E);\n\n              for (let x = 0; x < N.length; x++) {\n                let b = N[x];\n                b.isLeadingSpaceSensitive = (x === 0 || b.prev.isTrailingSpaceSensitive) && b.isLeadingSpaceSensitive, b.isTrailingSpaceSensitive = (x === N.length - 1 || b.next.isLeadingSpaceSensitive) && b.isTrailingSpaceSensitive;\n              }\n            }\n          });\n        }\n\n        function F(l, E) {\n          if (E.parser === \"vue\") {\n            let y = l.children.find(x => p(x, E));\n            if (!y) return;\n            let N = y.attrMap.lang;\n            (N === \"ts\" || N === \"typescript\") && (E.__should_parse_vue_template_with_ts = !0);\n          }\n        }\n\n        n.exports = h;\n      }\n\n    }),\n        ng = Z({\n      \"src/language-html/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(a);\n        }\n\n        function s(a) {\n          return \"<!-- @format -->\\n\\n\" + a.replace(/^\\s*\\n/, \"\");\n        }\n\n        n.exports = {\n          hasPragma: t,\n          insertPragma: s\n        };\n      }\n\n    }),\n        Yn = Z({\n      \"src/language-html/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return a.sourceSpan.start.offset;\n        }\n\n        function s(a) {\n          return a.sourceSpan.end.offset;\n        }\n\n        n.exports = {\n          locStart: t,\n          locEnd: s\n        };\n      }\n\n    }),\n        er = Z({\n      \"src/language-html/print/tag.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = Xt(),\n            _Ue42 = Ue(),\n            s = _Ue42.isNonEmptyArray,\n            _Oe46 = Oe(),\n            _Oe46$builders = _Oe46.builders,\n            a = _Oe46$builders.indent,\n            r = _Oe46$builders.join,\n            u = _Oe46$builders.line,\n            i = _Oe46$builders.softline,\n            o = _Oe46$builders.hardline,\n            c = _Oe46.utils.replaceTextEndOfLine,\n            _Yn = Yn(),\n            v = _Yn.locStart,\n            m = _Yn.locEnd,\n            _qt2 = qt(),\n            d = _qt2.isTextLikeNode,\n            p = _qt2.getLastDescendant,\n            f = _qt2.isPreLikeNode,\n            h = _qt2.hasPrettierIgnore,\n            w = _qt2.shouldPreserveContent,\n            T = _qt2.isVueSfcBlock;\n\n        function A(q, Y) {\n          return [q.isSelfClosing ? \"\" : S(q, Y), B(q, Y)];\n        }\n\n        function S(q, Y) {\n          return q.lastChild && l(q.lastChild) ? \"\" : [I(q, Y), P(q, Y)];\n        }\n\n        function B(q, Y) {\n          return (q.next ? g(q.next) : F(q.parent)) ? \"\" : [C(q, Y), k(q, Y)];\n        }\n\n        function I(q, Y) {\n          return F(q) ? C(q.lastChild, Y) : \"\";\n        }\n\n        function k(q, Y) {\n          return l(q) ? P(q.parent, Y) : E(q) ? $(q.next) : \"\";\n        }\n\n        function P(q, Y) {\n          if (t(!q.isSelfClosing), D(q, Y)) return \"\";\n\n          switch (q.type) {\n            case \"ieConditionalComment\":\n              return \"<!\";\n\n            case \"element\":\n              if (q.hasHtmComponentClosingTag) return \"<//\";\n\n            default:\n              return \"</\".concat(q.rawName);\n          }\n        }\n\n        function C(q, Y) {\n          if (D(q, Y)) return \"\";\n\n          switch (q.type) {\n            case \"ieConditionalComment\":\n            case \"ieConditionalEndComment\":\n              return \"[endif]-->\";\n\n            case \"ieConditionalStartComment\":\n              return \"]><!-->\";\n\n            case \"interpolation\":\n              return \"}}\";\n\n            case \"element\":\n              if (q.isSelfClosing) return \"/>\";\n\n            default:\n              return \">\";\n          }\n        }\n\n        function D(q, Y) {\n          return !q.isSelfClosing && !q.endSourceSpan && (h(q) || w(q.parent, Y));\n        }\n\n        function g(q) {\n          return q.prev && q.prev.type !== \"docType\" && !d(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;\n        }\n\n        function F(q) {\n          return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d(p(q.lastChild)) && !f(q);\n        }\n\n        function l(q) {\n          return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d(p(q));\n        }\n\n        function E(q) {\n          return q.next && !d(q.next) && d(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;\n        }\n\n        function y(q) {\n          let Y = q.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);\n          return Y ? Y[1] ? Y[1].split(/\\s+/) : !0 : !1;\n        }\n\n        function N(q) {\n          return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;\n        }\n\n        function x(q, Y, H) {\n          let R = q.getValue();\n          if (!s(R.attrs)) return R.isSelfClosing ? \" \" : \"\";\n          let Q = R.prev && R.prev.type === \"comment\" && y(R.prev.value),\n              ee = typeof Q == \"boolean\" ? () => Q : Array.isArray(Q) ? De => Q.includes(De.rawName) : () => !1,\n              te = q.map(De => {\n            let ie = De.getValue();\n            return ee(ie) ? c(Y.originalText.slice(v(ie), m(ie))) : H();\n          }, \"attrs\"),\n              oe = R.type === \"element\" && R.fullName === \"script\" && R.attrs.length === 1 && R.attrs[0].fullName === \"src\" && R.children.length === 0,\n              X = Y.singleAttributePerLine && R.attrs.length > 1 && !T(R, Y) ? o : u,\n              ue = [a([oe ? \" \" : u, r(X, te)])];\n          return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe ? ue.push(R.isSelfClosing ? \" \" : \"\") : ue.push(Y.bracketSameLine ? R.isSelfClosing ? \" \" : \"\" : R.isSelfClosing ? u : i), ue;\n        }\n\n        function b(q) {\n          return q.firstChild && N(q.firstChild) ? \"\" : V(q);\n        }\n\n        function L(q, Y, H) {\n          let R = q.getValue();\n          return [M(R, Y), x(q, Y, H), R.isSelfClosing ? \"\" : b(R)];\n        }\n\n        function M(q, Y) {\n          return q.prev && E(q.prev) ? \"\" : [j(q, Y), $(q)];\n        }\n\n        function j(q, Y) {\n          return N(q) ? V(q.parent) : g(q) ? C(q.prev, Y) : \"\";\n        }\n\n        function $(q) {\n          switch (q.type) {\n            case \"ieConditionalComment\":\n            case \"ieConditionalStartComment\":\n              return \"<!--[if \".concat(q.condition);\n\n            case \"ieConditionalEndComment\":\n              return \"<!--<!\";\n\n            case \"interpolation\":\n              return \"{{\";\n\n            case \"docType\":\n              return \"<!DOCTYPE\";\n\n            case \"element\":\n              if (q.condition) return \"<!--[if \".concat(q.condition, \"]><!--><\").concat(q.rawName);\n\n            default:\n              return \"<\".concat(q.rawName);\n          }\n        }\n\n        function V(q) {\n          switch (t(!q.isSelfClosing), q.type) {\n            case \"ieConditionalComment\":\n              return \"]>\";\n\n            case \"element\":\n              if (q.condition) return \"><!--<![endif]-->\";\n\n            default:\n              return \">\";\n          }\n        }\n\n        n.exports = {\n          printClosingTag: A,\n          printClosingTagStart: S,\n          printClosingTagStartMarker: P,\n          printClosingTagEndMarker: C,\n          printClosingTagSuffix: k,\n          printClosingTagEnd: B,\n          needsToBorrowLastChildClosingTagEndMarker: F,\n          needsToBorrowParentClosingTagStartMarker: l,\n          needsToBorrowPrevClosingTagEndMarker: g,\n          printOpeningTag: L,\n          printOpeningTagStart: M,\n          printOpeningTagPrefix: j,\n          printOpeningTagStartMarker: $,\n          printOpeningTagEndMarker: V,\n          needsToBorrowNextOpeningTagStartMarker: E,\n          needsToBorrowParentOpeningTagEndMarker: N\n        };\n      }\n\n    }),\n        ug = Z({\n      \"node_modules/parse-srcset/src/parse-srcset.js\"(e, n) {\n        re(), function (t, s) {\n          typeof define == \"function\" && define.amd ? define([], s) : typeof n == \"object\" && n.exports ? n.exports = s() : t.parseSrcset = s();\n        }(e, function () {\n          return function (t, s) {\n            var a = s && s.logger || console;\n\n            function r(P) {\n              return P === \" \" || P === \"\t\" || P === \"\\n\" || P === \"\\f\" || P === \"\\r\";\n            }\n\n            function u(P) {\n              var C,\n                  D = P.exec(t.substring(S));\n              if (D) return C = D[0], S += C.length, C;\n            }\n\n            for (var i = t.length, o = /^[ \\t\\n\\r\\u000c]+/, c = /^[, \\t\\n\\r\\u000c]+/, v = /^[^ \\t\\n\\r\\u000c]+/, m = /[,]+$/, d = /^\\d+$/, p = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h, w, T, A, S = 0, B = [];;) {\n              if (u(c), S >= i) return B;\n              f = u(v), h = [], f.slice(-1) === \",\" ? (f = f.replace(m, \"\"), k()) : I();\n            }\n\n            function I() {\n              for (u(o), w = \"\", T = \"in descriptor\";;) {\n                if (A = t.charAt(S), T === \"in descriptor\") {\n                  if (r(A)) w && (h.push(w), w = \"\", T = \"after descriptor\");else if (A === \",\") {\n                    S += 1, w && h.push(w), k();\n                    return;\n                  } else if (A === \"(\") w = w + A, T = \"in parens\";else if (A === \"\") {\n                    w && h.push(w), k();\n                    return;\n                  } else w = w + A;\n                } else if (T === \"in parens\") {\n                  if (A === \")\") w = w + A, T = \"in descriptor\";else if (A === \"\") {\n                    h.push(w), k();\n                    return;\n                  } else w = w + A;\n                } else if (T === \"after descriptor\" && !r(A)) if (A === \"\") {\n                  k();\n                  return;\n                } else T = \"in descriptor\", S -= 1;\n                S += 1;\n              }\n            }\n\n            function k() {\n              var P = !1,\n                  C,\n                  D,\n                  g,\n                  F,\n                  l = {},\n                  E,\n                  y,\n                  N,\n                  x,\n                  b;\n\n              for (F = 0; F < h.length; F++) E = h[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x = parseInt(N, 10), b = parseFloat(N), d.test(N) && y === \"w\" ? ((C || D) && (P = !0), x === 0 ? P = !0 : C = x) : p.test(N) && y === \"x\" ? ((C || D || g) && (P = !0), b < 0 ? P = !0 : D = b) : d.test(N) && y === \"h\" ? ((g || D) && (P = !0), x === 0 ? P = !0 : g = x) : P = !0;\n\n              P ? a && a.error && a.error(\"Invalid srcset descriptor found in '\" + t + \"' at '\" + E + \"'.\") : (l.url = f, C && (l.w = C), D && (l.d = D), g && (l.h = g), B.push(l));\n            }\n          };\n        });\n      }\n\n    }),\n        sg = Z({\n      \"src/language-html/syntax-attribute.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var t = ug(),\n            _Oe47 = Oe(),\n            _Oe47$builders = _Oe47.builders,\n            s = _Oe47$builders.ifBreak,\n            a = _Oe47$builders.join,\n            r = _Oe47$builders.line;\n\n        function u(o) {\n          let c = t(o, {\n            logger: {\n              error(I) {\n                throw new Error(I);\n              }\n\n            }\n          }),\n              v = c.some(I => {\n            let k = I.w;\n            return k;\n          }),\n              m = c.some(I => {\n            let k = I.h;\n            return k;\n          }),\n              d = c.some(I => {\n            let k = I.d;\n            return k;\n          });\n          if (v + m + d > 1) throw new Error(\"Mixed descriptor in srcset is not supported\");\n\n          let p = v ? \"w\" : m ? \"h\" : \"d\",\n              f = v ? \"w\" : m ? \"h\" : \"x\",\n              h = I => Math.max(...I),\n              w = c.map(I => I.url),\n              T = h(w.map(I => I.length)),\n              A = c.map(I => I[p]).map(I => I ? I.toString() : \"\"),\n              S = A.map(I => {\n            let k = I.indexOf(\".\");\n            return k === -1 ? I.length : k;\n          }),\n              B = h(S);\n\n          return a([\",\", r], w.map((I, k) => {\n            let P = [I],\n                C = A[k];\n\n            if (C) {\n              let D = T - I.length + 1,\n                  g = B - S[k],\n                  F = \" \".repeat(D + g);\n              P.push(s(F, \" \"), C + f);\n            }\n\n            return P;\n          }));\n        }\n\n        function i(o) {\n          return o.trim().split(/\\s+/).join(\" \");\n        }\n\n        n.exports = {\n          printImgSrcset: u,\n          printClassNames: i\n        };\n      }\n\n    }),\n        ig = Z({\n      \"src/language-html/syntax-vue.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe48 = Oe(),\n            t = _Oe48.builders.group;\n\n        function s(i, o) {\n          let _a6 = a(i),\n              c = _a6.left,\n              v = _a6.operator,\n              m = _a6.right;\n\n          return [t(o(\"function _(\".concat(c, \") {}\"), {\n            parser: \"babel\",\n            __isVueForBindingLeft: !0\n          })), \" \", v, \" \", o(m, {\n            parser: \"__js_expression\"\n          }, {\n            stripTrailingHardline: !0\n          })];\n        }\n\n        function a(i) {\n          let o = /(.*?)\\s+(in|of)\\s+(.*)/s,\n              c = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/,\n              v = /^\\(|\\)$/g,\n              m = i.match(o);\n          if (!m) return;\n          let d = {};\n          if (d.for = m[3].trim(), !d.for) return;\n          let p = m[1].trim().replace(v, \"\"),\n              f = p.match(c);\n          f ? (d.alias = p.replace(c, \"\"), d.iterator1 = f[1].trim(), f[2] && (d.iterator2 = f[2].trim())) : d.alias = p;\n          let h = [d.alias, d.iterator1, d.iterator2];\n          if (!h.some((w, T) => !w && (T === 0 || h.slice(T + 1).some(Boolean)))) return {\n            left: h.filter(Boolean).join(\",\"),\n            operator: m[2],\n            right: d.for\n          };\n        }\n\n        function r(i, o) {\n          return o(\"function _(\".concat(i, \") {}\"), {\n            parser: \"babel\",\n            __isVueBindings: !0\n          });\n        }\n\n        function u(i) {\n          let o = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/,\n              c = /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/,\n              v = i.trim();\n          return o.test(v) || c.test(v);\n        }\n\n        n.exports = {\n          isVueEventBindingExpression: u,\n          printVueFor: s,\n          printVueBindings: r\n        };\n      }\n\n    }),\n        ho = Z({\n      \"src/language-html/get-node-content.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _er = er(),\n            t = _er.needsToBorrowParentClosingTagStartMarker,\n            s = _er.printClosingTagStartMarker,\n            a = _er.needsToBorrowLastChildClosingTagEndMarker,\n            r = _er.printClosingTagEndMarker,\n            u = _er.needsToBorrowParentOpeningTagEndMarker,\n            i = _er.printOpeningTagEndMarker;\n\n        function o(c, v) {\n          let m = c.startSourceSpan.end.offset;\n          c.firstChild && u(c.firstChild) && (m -= i(c).length);\n          let d = c.endSourceSpan.start.offset;\n          return c.lastChild && t(c.lastChild) ? d += s(c, v).length : a(c) && (d -= r(c.lastChild, v).length), v.originalText.slice(m, d);\n        }\n\n        n.exports = o;\n      }\n\n    }),\n        ag = Z({\n      \"src/language-html/embed.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe49 = Oe(),\n            _Oe49$builders = _Oe49.builders,\n            t = _Oe49$builders.breakParent,\n            s = _Oe49$builders.group,\n            a = _Oe49$builders.hardline,\n            r = _Oe49$builders.indent,\n            u = _Oe49$builders.line,\n            i = _Oe49$builders.fill,\n            o = _Oe49$builders.softline,\n            _Oe49$utils = _Oe49.utils,\n            c = _Oe49$utils.mapDoc,\n            v = _Oe49$utils.replaceTextEndOfLine,\n            m = Xn(),\n            _er2 = er(),\n            d = _er2.printClosingTag,\n            p = _er2.printClosingTagSuffix,\n            f = _er2.needsToBorrowPrevClosingTagEndMarker,\n            h = _er2.printOpeningTagPrefix,\n            w = _er2.printOpeningTag,\n            _sg = sg(),\n            T = _sg.printImgSrcset,\n            A = _sg.printClassNames,\n            _ig = ig(),\n            S = _ig.printVueFor,\n            B = _ig.printVueBindings,\n            I = _ig.isVueEventBindingExpression,\n            _qt3 = qt(),\n            k = _qt3.isScriptLikeTag,\n            P = _qt3.isVueNonHtmlBlock,\n            C = _qt3.inferScriptParser,\n            D = _qt3.htmlTrimPreserveIndentation,\n            g = _qt3.dedentString,\n            F = _qt3.unescapeQuoteEntities,\n            l = _qt3.isVueSlotAttribute,\n            E = _qt3.isVueSfcBindingsAttribute,\n            y = _qt3.getTextValueParts,\n            N = ho();\n\n        function x(L, M, j) {\n          let $ = te => new RegExp(te.join(\"|\")).test(L.fullName),\n              V = () => F(L.value),\n              q = !1,\n              Y = (te, oe) => {\n            let W = te.type === \"NGRoot\" ? te.node.type === \"NGMicrosyntax\" && te.node.body.length === 1 && te.node.body[0].type === \"NGMicrosyntaxExpression\" ? te.node.body[0].expression : te.node : te.type === \"JsExpressionRoot\" ? te.node : te;\n            W && (W.type === \"ObjectExpression\" || W.type === \"ArrayExpression\" || oe.parser === \"__vue_expression\" && (W.type === \"TemplateLiteral\" || W.type === \"StringLiteral\")) && (q = !0);\n          },\n              H = te => s(te),\n              R = function (te) {\n            let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n            return s([r([o, te]), oe ? o : \"\"]);\n          },\n              Q = te => q ? H(te) : R(te),\n              ee = (te, oe) => M(te, Object.assign({\n            __onHtmlBindingRoot: Y,\n            __embeddedInHtml: !0\n          }, oe));\n\n          if (L.fullName === \"srcset\" && (L.parent.fullName === \"img\" || L.parent.fullName === \"source\")) return R(T(V()));\n\n          if (L.fullName === \"class\" && !j.parentParser) {\n            let te = V();\n            if (!te.includes(\"{{\")) return A(te);\n          }\n\n          if (L.fullName === \"style\" && !j.parentParser) {\n            let te = V();\n            if (!te.includes(\"{{\")) return R(ee(te, {\n              parser: \"css\",\n              __isHTMLStyleAttribute: !0\n            }));\n          }\n\n          if (j.parser === \"vue\") {\n            if (L.fullName === \"v-for\") return S(V(), ee);\n            if (l(L) || E(L, j)) return B(V(), ee);\n            let te = [\"^@\", \"^v-on:\"],\n                oe = [\"^:\", \"^v-bind:\"],\n                W = [\"^v-\"];\n\n            if ($(te)) {\n              let X = V(),\n                  ue = I(X) ? \"__js_expression\" : j.__should_parse_vue_template_with_ts ? \"__vue_ts_event_binding\" : \"__vue_event_binding\";\n              return Q(ee(X, {\n                parser: ue\n              }));\n            }\n\n            if ($(oe)) return Q(ee(V(), {\n              parser: \"__vue_expression\"\n            }));\n            if ($(W)) return Q(ee(V(), {\n              parser: \"__js_expression\"\n            }));\n          }\n\n          if (j.parser === \"angular\") {\n            let te = (G, z) => ee(G, Object.assign(Object.assign({}, z), {}, {\n              trailingComma: \"none\"\n            })),\n                oe = [\"^\\\\*\"],\n                W = [\"^\\\\(.+\\\\)$\", \"^on-\"],\n                X = [\"^\\\\[.+\\\\]$\", \"^bind(on)?-\", \"^ng-(if|show|hide|class|style)$\"],\n                ue = [\"^i18n(-.+)?$\"];\n\n            if ($(W)) return Q(te(V(), {\n              parser: \"__ng_action\"\n            }));\n            if ($(X)) return Q(te(V(), {\n              parser: \"__ng_binding\"\n            }));\n\n            if ($(ue)) {\n              let G = V().trim();\n              return R(i(y(L, G)), !G.includes(\"@@\"));\n            }\n\n            if ($(oe)) return Q(te(V(), {\n              parser: \"__ng_directive\"\n            }));\n            let De = /{{(.+?)}}/s,\n                ie = V();\n\n            if (De.test(ie)) {\n              let G = [];\n\n              for (let _ref44 of ie.split(De).entries()) {\n                var _ref45 = _slicedToArray(_ref44, 2);\n\n                let z = _ref45[0];\n                let U = _ref45[1];\n                if (z % 2 === 0) G.push(v(U));else try {\n                  G.push(s([\"{{\", r([u, te(U, {\n                    parser: \"__ng_interpolation\",\n                    __isInHtmlInterpolation: !0\n                  })]), u, \"}}\"]));\n                } catch {\n                  G.push(\"{{\", v(U), \"}}\");\n                }\n              }\n\n              return s(G);\n            }\n          }\n\n          return null;\n        }\n\n        function b(L, M, j, $) {\n          let V = L.getValue();\n\n          switch (V.type) {\n            case \"element\":\n              {\n                if (k(V) || V.type === \"interpolation\") return;\n\n                if (!V.isSelfClosing && P(V, $)) {\n                  let q = C(V, $);\n                  if (!q) return;\n                  let Y = N(V, $),\n                      H = /^\\s*$/.test(Y),\n                      R = \"\";\n                  return H || (R = j(D(Y), {\n                    parser: q,\n                    __embeddedInHtml: !0\n                  }, {\n                    stripTrailingHardline: !0\n                  }), H = R === \"\"), [h(V, $), s(w(L, $, M)), H ? \"\" : a, R, H ? \"\" : a, d(V, $), p(V, $)];\n                }\n\n                break;\n              }\n\n            case \"text\":\n              {\n                if (k(V.parent)) {\n                  let q = C(V.parent, $);\n\n                  if (q) {\n                    let Y = q === \"markdown\" ? g(V.value.replace(/^[^\\S\\n]*\\n/, \"\")) : V.value,\n                        H = {\n                      parser: q,\n                      __embeddedInHtml: !0\n                    };\n\n                    if ($.parser === \"html\" && q === \"babel\") {\n                      let R = \"script\",\n                          Q = V.parent.attrMap;\n                      Q && (Q.type === \"module\" || Q.type === \"text/babel\" && Q[\"data-type\"] === \"module\") && (R = \"module\"), H.__babelSourceType = R;\n                    }\n\n                    return [t, h(V, $), j(Y, H, {\n                      stripTrailingHardline: !0\n                    }), p(V, $)];\n                  }\n                } else if (V.parent.type === \"interpolation\") {\n                  let q = {\n                    __isInHtmlInterpolation: !0,\n                    __embeddedInHtml: !0\n                  };\n                  return $.parser === \"angular\" ? (q.parser = \"__ng_interpolation\", q.trailingComma = \"none\") : $.parser === \"vue\" ? q.parser = $.__should_parse_vue_template_with_ts ? \"__vue_ts_expression\" : \"__vue_expression\" : q.parser = \"__js_expression\", [r([u, j(V.value, q, {\n                    stripTrailingHardline: !0\n                  })]), V.parent.next && f(V.parent.next) ? \" \" : u];\n                }\n\n                break;\n              }\n\n            case \"attribute\":\n              {\n                if (!V.value) break;\n                if (/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, \"=\", V.value];\n                if ($.parser === \"lwc\" && /^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset))) return [V.rawName, \"=\", V.value];\n                let q = x(V, (Y, H) => j(Y, Object.assign({\n                  __isInHtmlAttribute: !0,\n                  __embeddedInHtml: !0\n                }, H), {\n                  stripTrailingHardline: !0\n                }), $);\n                if (q) return [V.rawName, '=\"', s(c(q, Y => typeof Y == \"string\" ? Y.replace(/\"/g, \"&quot;\") : Y)), '\"'];\n                break;\n              }\n\n            case \"front-matter\":\n              return m(V, j);\n          }\n        }\n\n        n.exports = b;\n      }\n\n    }),\n        vo = Z({\n      \"src/language-html/print/children.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe50 = Oe(),\n            _Oe50$builders = _Oe50.builders,\n            t = _Oe50$builders.breakParent,\n            s = _Oe50$builders.group,\n            a = _Oe50$builders.ifBreak,\n            r = _Oe50$builders.line,\n            u = _Oe50$builders.softline,\n            i = _Oe50$builders.hardline,\n            o = _Oe50.utils.replaceTextEndOfLine,\n            _Yn2 = Yn(),\n            c = _Yn2.locStart,\n            v = _Yn2.locEnd,\n            _qt4 = qt(),\n            m = _qt4.forceBreakChildren,\n            d = _qt4.forceNextEmptyLine,\n            p = _qt4.isTextLikeNode,\n            f = _qt4.hasPrettierIgnore,\n            h = _qt4.preferHardlineAsLeadingSpaces,\n            _er3 = er(),\n            w = _er3.printOpeningTagPrefix,\n            T = _er3.needsToBorrowNextOpeningTagStartMarker,\n            A = _er3.printOpeningTagStartMarker,\n            S = _er3.needsToBorrowPrevClosingTagEndMarker,\n            B = _er3.printClosingTagEndMarker,\n            I = _er3.printClosingTagSuffix,\n            k = _er3.needsToBorrowParentClosingTagStartMarker;\n\n        function P(g, F, l) {\n          let E = g.getValue();\n          return f(E) ? [w(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T(E.prev) ? A(E).length : 0), v(E) - (E.next && S(E.next) ? B(E, F).length : 0))), I(E, F)] : l();\n        }\n\n        function C(g, F) {\n          return p(g) && p(F) ? g.isTrailingSpaceSensitive ? g.hasTrailingSpaces ? h(F) ? i : r : \"\" : h(F) ? i : u : T(g) && (f(F) || F.firstChild || F.isSelfClosing || F.type === \"element\" && F.attrs.length > 0) || g.type === \"element\" && g.isSelfClosing && S(F) ? \"\" : !F.isLeadingSpaceSensitive || h(F) || S(F) && g.lastChild && k(g.lastChild) && g.lastChild.lastChild && k(g.lastChild.lastChild) ? i : F.hasLeadingSpaces ? r : u;\n        }\n\n        function D(g, F, l) {\n          let E = g.getValue();\n          if (m(E)) return [t, ...g.map(N => {\n            let x = N.getValue(),\n                b = x.prev ? C(x.prev, x) : \"\";\n            return [b ? [b, d(x.prev) ? i : \"\"] : \"\", P(N, F, l)];\n          }, \"children\")];\n          let y = E.children.map(() => Symbol(\"\"));\n          return g.map((N, x) => {\n            let b = N.getValue();\n\n            if (p(b)) {\n              if (b.prev && p(b.prev)) {\n                let Y = C(b.prev, b);\n                if (Y) return d(b.prev) ? [i, i, P(N, F, l)] : [Y, P(N, F, l)];\n              }\n\n              return P(N, F, l);\n            }\n\n            let L = [],\n                M = [],\n                j = [],\n                $ = [],\n                V = b.prev ? C(b.prev, b) : \"\",\n                q = b.next ? C(b, b.next) : \"\";\n            return V && (d(b.prev) ? L.push(i, i) : V === i ? L.push(i) : p(b.prev) ? M.push(V) : M.push(a(\"\", u, {\n              groupId: y[x - 1]\n            }))), q && (d(b) ? p(b.next) && $.push(i, i) : q === i ? p(b.next) && $.push(i) : j.push(q)), [...L, s([...M, s([P(N, F, l), ...j], {\n              id: y[x]\n            })]), ...$];\n          }, \"children\");\n        }\n\n        n.exports = {\n          printChildren: D\n        };\n      }\n\n    }),\n        og = Z({\n      \"src/language-html/print/element.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe51 = Oe(),\n            _Oe51$builders = _Oe51.builders,\n            t = _Oe51$builders.breakParent,\n            s = _Oe51$builders.dedentToRoot,\n            a = _Oe51$builders.group,\n            r = _Oe51$builders.ifBreak,\n            u = _Oe51$builders.indentIfBreak,\n            i = _Oe51$builders.indent,\n            o = _Oe51$builders.line,\n            c = _Oe51$builders.softline,\n            v = _Oe51.utils.replaceTextEndOfLine,\n            m = ho(),\n            _qt5 = qt(),\n            d = _qt5.shouldPreserveContent,\n            p = _qt5.isScriptLikeTag,\n            f = _qt5.isVueCustomBlock,\n            h = _qt5.countParents,\n            w = _qt5.forceBreakContent,\n            _er4 = er(),\n            T = _er4.printOpeningTagPrefix,\n            A = _er4.printOpeningTag,\n            S = _er4.printClosingTagSuffix,\n            B = _er4.printClosingTag,\n            I = _er4.needsToBorrowPrevClosingTagEndMarker,\n            k = _er4.needsToBorrowLastChildClosingTagEndMarker,\n            _vo = vo(),\n            P = _vo.printChildren;\n\n        function C(D, g, F) {\n          let l = D.getValue();\n          if (d(l, g)) return [T(l, g), a(A(D, g, F)), ...v(m(l, g)), ...B(l, g), S(l, g)];\n\n          let E = l.children.length === 1 && l.firstChild.type === \"interpolation\" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces,\n              y = Symbol(\"element-attr-group-id\"),\n              N = M => a([a(A(D, g, F), {\n            id: y\n          }), M, B(l, g)]),\n              x = M => E ? u(M, {\n            groupId: y\n          }) : (p(l) || f(l, g)) && l.parent.type === \"root\" && g.parser === \"vue\" && !g.vueIndentScriptAndStyle ? M : i(M),\n              b = () => E ? r(c, \"\", {\n            groupId: y\n          }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === \"text\" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s(c) : c,\n              L = () => (l.next ? I(l.next) : k(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? \" \" : \"\" : E ? r(c, \"\", {\n            groupId: y\n          }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === \"comment\" || l.lastChild.type === \"text\" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp(\"\\\\n[\\\\t ]{\".concat(g.tabWidth * h(D, j => j.parent && j.parent.type !== \"root\"), \"}$\")).test(l.lastChild.value) ? \"\" : c;\n\n          return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : \"\") : N([w(l) ? t : \"\", x([b(), P(D, g, F)]), L()]);\n        }\n\n        n.exports = {\n          printElement: C\n        };\n      }\n\n    }),\n        lg = Z({\n      \"src/language-html/printer-html.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe52 = Oe(),\n            _Oe52$builders = _Oe52.builders,\n            t = _Oe52$builders.fill,\n            s = _Oe52$builders.group,\n            a = _Oe52$builders.hardline,\n            r = _Oe52$builders.literalline,\n            _Oe52$utils = _Oe52.utils,\n            u = _Oe52$utils.cleanDoc,\n            i = _Oe52$utils.getDocParts,\n            o = _Oe52$utils.isConcat,\n            c = _Oe52$utils.replaceTextEndOfLine,\n            v = zd(),\n            _qt6 = qt(),\n            m = _qt6.countChars,\n            d = _qt6.unescapeQuoteEntities,\n            p = _qt6.getTextValueParts,\n            f = rg(),\n            _ng = ng(),\n            h = _ng.insertPragma,\n            _Yn3 = Yn(),\n            w = _Yn3.locStart,\n            T = _Yn3.locEnd,\n            A = ag(),\n            _er5 = er(),\n            S = _er5.printClosingTagSuffix,\n            B = _er5.printClosingTagEnd,\n            I = _er5.printOpeningTagPrefix,\n            k = _er5.printOpeningTagStart,\n            _og = og(),\n            P = _og.printElement,\n            _vo2 = vo(),\n            C = _vo2.printChildren;\n\n        function D(g, F, l) {\n          let E = g.getValue();\n\n          switch (E.type) {\n            case \"front-matter\":\n              return c(E.raw);\n\n            case \"root\":\n              return F.__onHtmlRoot && F.__onHtmlRoot(E), [s(C(g, F, l)), a];\n\n            case \"element\":\n            case \"ieConditionalComment\":\n              return P(g, F, l);\n\n            case \"ieConditionalStartComment\":\n            case \"ieConditionalEndComment\":\n              return [k(E), B(E)];\n\n            case \"interpolation\":\n              return [k(E, F), ...g.map(l, \"children\"), B(E, F)];\n\n            case \"text\":\n              {\n                if (E.parent.type === \"interpolation\") {\n                  let N = /\\n[^\\S\\n]*$/,\n                      x = N.test(E.value),\n                      b = x ? E.value.replace(N, \"\") : E.value;\n                  return [...c(b), x ? a : \"\"];\n                }\n\n                let y = u([I(E, F), ...p(E), S(E, F)]);\n                return o(y) || y.type === \"fill\" ? t(i(y)) : y;\n              }\n\n            case \"docType\":\n              return [s([k(E, F), \" \", E.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \")]), B(E, F)];\n\n            case \"comment\":\n              return [I(E, F), ...c(F.originalText.slice(w(E), T(E)), r), S(E, F)];\n\n            case \"attribute\":\n              {\n                if (E.value === null) return E.rawName;\n                let y = d(E.value),\n                    N = m(y, \"'\"),\n                    x = m(y, '\"'),\n                    b = N < x ? \"'\" : '\"';\n                return [E.rawName, \"=\", b, ...c(b === '\"' ? y.replace(/\"/g, \"&quot;\") : y.replace(/'/g, \"&apos;\")), b];\n              }\n\n            default:\n              throw new Error(\"Unexpected node type \".concat(E.type));\n          }\n        }\n\n        n.exports = {\n          preprocess: f,\n          print: D,\n          insertPragma: h,\n          massageAstNode: v,\n          embed: A\n        };\n      }\n\n    }),\n        cg = Z({\n      \"src/language-html/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot(),\n            s = \"HTML\";\n        n.exports = {\n          bracketSameLine: t.bracketSameLine,\n          htmlWhitespaceSensitivity: {\n            since: \"1.15.0\",\n            category: s,\n            type: \"choice\",\n            default: \"css\",\n            description: \"How to handle whitespaces in HTML.\",\n            choices: [{\n              value: \"css\",\n              description: \"Respect the default value of CSS display property.\"\n            }, {\n              value: \"strict\",\n              description: \"Whitespaces are considered sensitive.\"\n            }, {\n              value: \"ignore\",\n              description: \"Whitespaces are considered insensitive.\"\n            }]\n          },\n          singleAttributePerLine: t.singleAttributePerLine,\n          vueIndentScriptAndStyle: {\n            since: \"1.19.0\",\n            category: s,\n            type: \"boolean\",\n            default: !1,\n            description: \"Indent script and style tags in Vue files.\"\n          }\n        };\n      }\n\n    }),\n        pg = Z({\n      \"src/language-html/parsers.js\"() {\n        re();\n      }\n\n    }),\n        xn = Z({\n      \"node_modules/linguist-languages/data/HTML.json\"(e, n) {\n        n.exports = {\n          name: \"HTML\",\n          type: \"markup\",\n          tmScope: \"text.html.basic\",\n          aceMode: \"html\",\n          codemirrorMode: \"htmlmixed\",\n          codemirrorMimeType: \"text/html\",\n          color: \"#e34c26\",\n          aliases: [\"xhtml\"],\n          extensions: [\".html\", \".hta\", \".htm\", \".html.hl\", \".inc\", \".xht\", \".xhtml\"],\n          languageId: 146\n        };\n      }\n\n    }),\n        fg = Z({\n      \"node_modules/linguist-languages/data/Vue.json\"(e, n) {\n        n.exports = {\n          name: \"Vue\",\n          type: \"markup\",\n          color: \"#41b883\",\n          extensions: [\".vue\"],\n          tmScope: \"text.html.vue\",\n          aceMode: \"html\",\n          languageId: 391\n        };\n      }\n\n    }),\n        Dg = Z({\n      \"src/language-html/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = lg(),\n            a = cg(),\n            r = pg(),\n            u = [t(xn(), () => ({\n          name: \"Angular\",\n          since: \"1.15.0\",\n          parsers: [\"angular\"],\n          vscodeLanguageIds: [\"html\"],\n          extensions: [\".component.html\"],\n          filenames: []\n        })), t(xn(), o => ({\n          since: \"1.15.0\",\n          parsers: [\"html\"],\n          vscodeLanguageIds: [\"html\"],\n          extensions: [...o.extensions, \".mjml\"]\n        })), t(xn(), () => ({\n          name: \"Lightning Web Components\",\n          since: \"1.17.0\",\n          parsers: [\"lwc\"],\n          vscodeLanguageIds: [\"html\"],\n          extensions: [],\n          filenames: []\n        })), t(fg(), () => ({\n          since: \"1.10.0\",\n          parsers: [\"vue\"],\n          vscodeLanguageIds: [\"vue\"]\n        }))],\n            i = {\n          html: s\n        };\n        n.exports = {\n          languages: u,\n          printers: i,\n          options: a,\n          parsers: r\n        };\n      }\n\n    }),\n        mg = Z({\n      \"src/language-yaml/pragma.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(r) {\n          return /^\\s*@(?:prettier|format)\\s*$/.test(r);\n        }\n\n        function s(r) {\n          return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(r);\n        }\n\n        function a(r) {\n          return \"# @format\\n\\n\".concat(r);\n        }\n\n        n.exports = {\n          isPragma: t,\n          hasPragma: s,\n          insertPragma: a\n        };\n      }\n\n    }),\n        dg = Z({\n      \"src/language-yaml/loc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(a) {\n          return a.position.start.offset;\n        }\n\n        function s(a) {\n          return a.position.end.offset;\n        }\n\n        n.exports = {\n          locStart: t,\n          locEnd: s\n        };\n      }\n\n    }),\n        gg = Z({\n      \"src/language-yaml/embed.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        function t(s, a, r, u) {\n          if (s.getValue().type === \"root\" && u.filepath && /(?:[/\\\\]|^)\\.(?:prettier|stylelint)rc$/.test(u.filepath)) return r(u.originalText, Object.assign(Object.assign({}, u), {}, {\n            parser: \"json\"\n          }));\n        }\n\n        n.exports = t;\n      }\n\n    }),\n        Mt = Z({\n      \"src/language-yaml/utils.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Ue43 = Ue(),\n            t = _Ue43.getLast,\n            s = _Ue43.isNonEmptyArray;\n\n        function a(C, D) {\n          let g = 0,\n              F = C.stack.length - 1;\n\n          for (let l = 0; l < F; l++) {\n            let E = C.stack[l];\n            r(E) && D(E) && g++;\n          }\n\n          return g;\n        }\n\n        function r(C, D) {\n          return C && typeof C.type == \"string\" && (!D || D.includes(C.type));\n        }\n\n        function u(C, D, g) {\n          return D(\"children\" in C ? Object.assign(Object.assign({}, C), {}, {\n            children: C.children.map(F => u(F, D, C))\n          }) : C, g);\n        }\n\n        function i(C, D, g) {\n          Object.defineProperty(C, D, {\n            get: g,\n            enumerable: !1\n          });\n        }\n\n        function o(C, D) {\n          let g = 0,\n              F = D.length;\n\n          for (let l = C.position.end.offset - 1; l < F; l++) {\n            let E = D[l];\n            if (E === \"\\n\" && g++, g === 1 && /\\S/.test(E)) return !1;\n            if (g === 2) return !0;\n          }\n\n          return !1;\n        }\n\n        function c(C) {\n          switch (C.getValue().type) {\n            case \"tag\":\n            case \"anchor\":\n            case \"comment\":\n              return !1;\n          }\n\n          let g = C.stack.length;\n\n          for (let F = 1; F < g; F++) {\n            let l = C.stack[F],\n                E = C.stack[F - 1];\n            if (Array.isArray(E) && typeof l == \"number\" && l !== E.length - 1) return !1;\n          }\n\n          return !0;\n        }\n\n        function v(C) {\n          return s(C.children) ? v(t(C.children)) : C;\n        }\n\n        function m(C) {\n          return C.value.trim() === \"prettier-ignore\";\n        }\n\n        function d(C) {\n          let D = C.getValue();\n\n          if (D.type === \"documentBody\") {\n            let g = C.getParentNode();\n            return S(g.head) && m(t(g.head.endComments));\n          }\n\n          return h(D) && m(t(D.leadingComments));\n        }\n\n        function p(C) {\n          return !s(C.children) && !f(C);\n        }\n\n        function f(C) {\n          return h(C) || w(C) || T(C) || A(C) || S(C);\n        }\n\n        function h(C) {\n          return s(C == null ? void 0 : C.leadingComments);\n        }\n\n        function w(C) {\n          return s(C == null ? void 0 : C.middleComments);\n        }\n\n        function T(C) {\n          return C == null ? void 0 : C.indicatorComment;\n        }\n\n        function A(C) {\n          return C == null ? void 0 : C.trailingComment;\n        }\n\n        function S(C) {\n          return s(C == null ? void 0 : C.endComments);\n        }\n\n        function B(C) {\n          let D = [],\n              g;\n\n          for (let F of C.split(/( +)/)) F !== \" \" ? g === \" \" ? D.push(F) : D.push((D.pop() || \"\") + F) : g === void 0 && D.unshift(\"\"), g = F;\n\n          return g === \" \" && D.push((D.pop() || \"\") + \" \"), D[0] === \"\" && (D.shift(), D.unshift(\" \" + (D.shift() || \"\"))), D;\n        }\n\n        function I(C, D, g) {\n          let F = D.split(\"\\n\").map((l, E, y) => E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());\n          return g.proseWrap === \"preserve\" ? F.map(l => l.length === 0 ? [] : [l]) : F.map(l => l.length === 0 ? [] : B(l)).reduce((l, E, y) => y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C === \"quoteDouble\" && t(t(l)).endsWith(\"\\\\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map(l => g.proseWrap === \"never\" ? [l.join(\" \")] : l);\n        }\n\n        function k(C, D) {\n          let g = D.parentIndent,\n              F = D.isLastDescendant,\n              l = D.options,\n              E = C.position.start.line === C.position.end.line ? \"\" : l.originalText.slice(C.position.start.offset, C.position.end.offset).match(/^[^\\n]*\\n(.*)$/s)[1],\n              y;\n\n          if (C.indent === null) {\n            let b = E.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);\n            y = b ? b.groups.leadingSpace.length : Number.POSITIVE_INFINITY;\n          } else y = C.indent - 1 + g;\n\n          let N = E.split(\"\\n\").map(b => b.slice(y));\n          if (l.proseWrap === \"preserve\" || C.type === \"blockLiteral\") return x(N.map(b => b.length === 0 ? [] : [b]));\n          return x(N.map(b => b.length === 0 ? [] : B(b)).reduce((b, L, M) => M !== 0 && N[M - 1].length > 0 && L.length > 0 && !/^\\s/.test(L[0]) && !/^\\s|\\s$/.test(t(b)) ? [...b.slice(0, -1), [...t(b), ...L]] : [...b, L], []).map(b => b.reduce((L, M) => L.length > 0 && /\\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + \" \" + M] : [...L, M], [])).map(b => l.proseWrap === \"never\" ? [b.join(\" \")] : b));\n\n          function x(b) {\n            if (C.chomping === \"keep\") return t(b).length === 0 ? b.slice(0, -1) : b;\n            let L = 0;\n\n            for (let M = b.length - 1; M >= 0 && b[M].length === 0; M--) L++;\n\n            return L === 0 ? b : L >= 2 && !F ? b.slice(0, -(L - 1)) : b.slice(0, -L);\n          }\n        }\n\n        function P(C) {\n          if (!C) return !0;\n\n          switch (C.type) {\n            case \"plain\":\n            case \"quoteDouble\":\n            case \"quoteSingle\":\n            case \"alias\":\n            case \"flowMapping\":\n            case \"flowSequence\":\n              return !0;\n\n            default:\n              return !1;\n          }\n        }\n\n        n.exports = {\n          getLast: t,\n          getAncestorCount: a,\n          isNode: r,\n          isEmptyNode: p,\n          isInlineNode: P,\n          mapNode: u,\n          defineShortcut: i,\n          isNextLineEmpty: o,\n          isLastDescendantNode: c,\n          getBlockValueLineContents: k,\n          getFlowScalarLineContents: I,\n          getLastDescendantNode: v,\n          hasPrettierIgnore: d,\n          hasLeadingComments: h,\n          hasMiddleComments: w,\n          hasIndicatorComment: T,\n          hasTrailingComment: A,\n          hasEndComments: S\n        };\n      }\n\n    }),\n        yg = Z({\n      \"src/language-yaml/print-preprocess.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Mt = Mt(),\n            t = _Mt.defineShortcut,\n            s = _Mt.mapNode;\n\n        function a(u) {\n          return s(u, r);\n        }\n\n        function r(u) {\n          switch (u.type) {\n            case \"document\":\n              t(u, \"head\", () => u.children[0]), t(u, \"body\", () => u.children[1]);\n              break;\n\n            case \"documentBody\":\n            case \"sequenceItem\":\n            case \"flowSequenceItem\":\n            case \"mappingKey\":\n            case \"mappingValue\":\n              t(u, \"content\", () => u.children[0]);\n              break;\n\n            case \"mappingItem\":\n            case \"flowMappingItem\":\n              t(u, \"key\", () => u.children[0]), t(u, \"value\", () => u.children[1]);\n              break;\n          }\n\n          return u;\n        }\n\n        n.exports = a;\n      }\n\n    }),\n        jr = Z({\n      \"src/language-yaml/print/misc.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe53 = Oe(),\n            _Oe53$builders = _Oe53.builders,\n            t = _Oe53$builders.softline,\n            s = _Oe53$builders.align,\n            _Mt2 = Mt(),\n            a = _Mt2.hasEndComments,\n            r = _Mt2.isNextLineEmpty,\n            u = _Mt2.isNode,\n            i = new WeakMap();\n\n        function o(m, d) {\n          let p = m.getValue(),\n              f = m.stack[0],\n              h;\n          return i.has(f) ? h = i.get(f) : (h = new Set(), i.set(f, h)), !h.has(p.position.end.line) && (h.add(p.position.end.line), r(p, d) && !c(m.getParentNode())) ? t : \"\";\n        }\n\n        function c(m) {\n          return a(m) && !u(m, [\"documentHead\", \"documentBody\", \"flowMapping\", \"flowSequence\"]);\n        }\n\n        function v(m, d) {\n          return s(\" \".repeat(m), d);\n        }\n\n        n.exports = {\n          alignWithSpaces: v,\n          shouldPrintEndComments: c,\n          printNextEmptyLine: o\n        };\n      }\n\n    }),\n        hg = Z({\n      \"src/language-yaml/print/flow-mapping-sequence.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe54 = Oe(),\n            _Oe54$builders = _Oe54.builders,\n            t = _Oe54$builders.ifBreak,\n            s = _Oe54$builders.line,\n            a = _Oe54$builders.softline,\n            r = _Oe54$builders.hardline,\n            u = _Oe54$builders.join,\n            _Mt3 = Mt(),\n            i = _Mt3.isEmptyNode,\n            o = _Mt3.getLast,\n            c = _Mt3.hasEndComments,\n            _jr = jr(),\n            v = _jr.printNextEmptyLine,\n            m = _jr.alignWithSpaces;\n\n        function d(f, h, w) {\n          let T = f.getValue(),\n              A = T.type === \"flowMapping\",\n              S = A ? \"{\" : \"[\",\n              B = A ? \"}\" : \"]\",\n              I = a;\n          A && T.children.length > 0 && w.bracketSpacing && (I = s);\n          let k = o(T.children),\n              P = k && k.type === \"flowMappingItem\" && i(k.key) && i(k.value);\n          return [S, m(w.tabWidth, [I, p(f, h, w), w.trailingComma === \"none\" ? \"\" : t(\",\"), c(T) ? [r, u(r, f.map(h, \"endComments\"))] : \"\"]), P ? \"\" : I, B];\n        }\n\n        function p(f, h, w) {\n          let T = f.getValue();\n          return f.map((S, B) => [h(), B === T.children.length - 1 ? \"\" : [\",\", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? v(S, w.originalText) : \"\"]], \"children\");\n        }\n\n        n.exports = {\n          printFlowMapping: d,\n          printFlowSequence: d\n        };\n      }\n\n    }),\n        vg = Z({\n      \"src/language-yaml/print/mapping-item.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe55 = Oe(),\n            _Oe55$builders = _Oe55.builders,\n            t = _Oe55$builders.conditionalGroup,\n            s = _Oe55$builders.group,\n            a = _Oe55$builders.hardline,\n            r = _Oe55$builders.ifBreak,\n            u = _Oe55$builders.join,\n            i = _Oe55$builders.line,\n            _Mt4 = Mt(),\n            o = _Mt4.hasLeadingComments,\n            c = _Mt4.hasMiddleComments,\n            v = _Mt4.hasTrailingComment,\n            m = _Mt4.hasEndComments,\n            d = _Mt4.isNode,\n            p = _Mt4.isEmptyNode,\n            f = _Mt4.isInlineNode,\n            _jr2 = jr(),\n            h = _jr2.alignWithSpaces;\n\n        function w(B, I, k, P, C) {\n          let D = B.key,\n              g = B.value,\n              F = p(D),\n              l = p(g);\n          if (F && l) return \": \";\n          let E = P(\"key\"),\n              y = A(B) ? \" \" : \"\";\n          if (l) return B.type === \"flowMappingItem\" && I.type === \"flowMapping\" ? E : B.type === \"mappingItem\" && T(D.content, C) && !v(D.content) && (!I.tag || I.tag.value !== \"tag:yaml.org,2002:set\") ? [E, y, \":\"] : [\"? \", h(2, E)];\n          let N = P(\"value\");\n          if (F) return [\": \", h(2, N)];\n          if (o(g) || !f(D.content)) return [\"? \", h(2, E), a, u(\"\", k.map(P, \"value\", \"leadingComments\").map($ => [$, a])), \": \", h(2, N)];\n          if (S(D.content) && !o(D.content) && !c(D.content) && !v(D.content) && !m(D) && !o(g.content) && !c(g.content) && !m(g) && T(g.content, C)) return [E, y, \": \", N];\n          let x = Symbol(\"mappingKey\"),\n              b = s([r(\"? \"), s(h(2, E), {\n            id: x\n          })]),\n              L = [a, \": \", h(2, N)],\n              M = [y, \":\"];\n          o(g.content) || m(g) && g.content && !d(g.content, [\"mapping\", \"sequence\"]) || I.type === \"mapping\" && v(D.content) && f(g.content) || d(g.content, [\"mapping\", \"sequence\"]) && g.content.tag === null && g.content.anchor === null ? M.push(a) : g.content && M.push(i), M.push(N);\n          let j = h(C.tabWidth, M);\n          return T(D.content, C) && !o(D.content) && !c(D.content) && !m(D) ? t([[E, j]]) : t([[b, r(L, j, {\n            groupId: x\n          })]]);\n        }\n\n        function T(B, I) {\n          if (!B) return !0;\n\n          switch (B.type) {\n            case \"plain\":\n            case \"quoteSingle\":\n            case \"quoteDouble\":\n              break;\n\n            case \"alias\":\n              return !0;\n\n            default:\n              return !1;\n          }\n\n          if (I.proseWrap === \"preserve\") return B.position.start.line === B.position.end.line;\n          if (/\\\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset))) return !1;\n\n          switch (I.proseWrap) {\n            case \"never\":\n              return !B.value.includes(\"\\n\");\n\n            case \"always\":\n              return !/[\\n ]/.test(B.value);\n\n            default:\n              return !1;\n          }\n        }\n\n        function A(B) {\n          return B.key.content && B.key.content.type === \"alias\";\n        }\n\n        function S(B) {\n          if (!B) return !0;\n\n          switch (B.type) {\n            case \"plain\":\n            case \"quoteDouble\":\n            case \"quoteSingle\":\n              return B.position.start.line === B.position.end.line;\n\n            case \"alias\":\n              return !0;\n\n            default:\n              return !1;\n          }\n        }\n\n        n.exports = w;\n      }\n\n    }),\n        Cg = Z({\n      \"src/language-yaml/print/block.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe56 = Oe(),\n            _Oe56$builders = _Oe56.builders,\n            t = _Oe56$builders.dedent,\n            s = _Oe56$builders.dedentToRoot,\n            a = _Oe56$builders.fill,\n            r = _Oe56$builders.hardline,\n            u = _Oe56$builders.join,\n            i = _Oe56$builders.line,\n            o = _Oe56$builders.literalline,\n            c = _Oe56$builders.markAsRoot,\n            v = _Oe56.utils.getDocParts,\n            _Mt5 = Mt(),\n            m = _Mt5.getAncestorCount,\n            d = _Mt5.getBlockValueLineContents,\n            p = _Mt5.hasIndicatorComment,\n            f = _Mt5.isLastDescendantNode,\n            h = _Mt5.isNode,\n            _jr3 = jr(),\n            w = _jr3.alignWithSpaces;\n\n        function T(A, S, B) {\n          let I = A.getValue(),\n              k = m(A, F => h(F, [\"sequence\", \"mapping\"])),\n              P = f(A),\n              C = [I.type === \"blockFolded\" ? \">\" : \"|\"];\n          I.indent !== null && C.push(I.indent.toString()), I.chomping !== \"clip\" && C.push(I.chomping === \"keep\" ? \"+\" : \"-\"), p(I) && C.push(\" \", S(\"indicatorComment\"));\n          let D = d(I, {\n            parentIndent: k,\n            isLastDescendant: P,\n            options: B\n          }),\n              g = [];\n\n          for (let _ref46 of D.entries()) {\n            var _ref47 = _slicedToArray(_ref46, 2);\n\n            let F = _ref47[0];\n            let l = _ref47[1];\n            F === 0 && g.push(r), g.push(a(v(u(i, l)))), F !== D.length - 1 ? g.push(l.length === 0 ? r : c(o)) : I.chomping === \"keep\" && P && g.push(s(l.length === 0 ? r : o));\n          }\n\n          return I.indent === null ? C.push(t(w(B.tabWidth, g))) : C.push(s(w(I.indent - 1 + k, g))), C;\n        }\n\n        n.exports = T;\n      }\n\n    }),\n        Eg = Z({\n      \"src/language-yaml/printer-yaml.js\"(e, n) {\n        \"use strict\";\n\n        re();\n\n        var _Oe57 = Oe(),\n            _Oe57$builders = _Oe57.builders,\n            t = _Oe57$builders.breakParent,\n            s = _Oe57$builders.fill,\n            a = _Oe57$builders.group,\n            r = _Oe57$builders.hardline,\n            u = _Oe57$builders.join,\n            i = _Oe57$builders.line,\n            o = _Oe57$builders.lineSuffix,\n            c = _Oe57$builders.literalline,\n            _Oe57$utils = _Oe57.utils,\n            v = _Oe57$utils.getDocParts,\n            m = _Oe57$utils.replaceTextEndOfLine,\n            _Ue44 = Ue(),\n            d = _Ue44.isPreviousLineEmpty,\n            _mg = mg(),\n            p = _mg.insertPragma,\n            f = _mg.isPragma,\n            _dg = dg(),\n            h = _dg.locStart,\n            w = gg(),\n            _Mt6 = Mt(),\n            T = _Mt6.getFlowScalarLineContents,\n            A = _Mt6.getLastDescendantNode,\n            S = _Mt6.hasLeadingComments,\n            B = _Mt6.hasMiddleComments,\n            I = _Mt6.hasTrailingComment,\n            k = _Mt6.hasEndComments,\n            P = _Mt6.hasPrettierIgnore,\n            C = _Mt6.isLastDescendantNode,\n            D = _Mt6.isNode,\n            g = _Mt6.isInlineNode,\n            F = yg(),\n            _jr4 = jr(),\n            l = _jr4.alignWithSpaces,\n            E = _jr4.printNextEmptyLine,\n            y = _jr4.shouldPrintEndComments,\n            _hg = hg(),\n            N = _hg.printFlowMapping,\n            x = _hg.printFlowSequence,\n            b = vg(),\n            L = Cg();\n\n        function M(R, Q, ee) {\n          let te = R.getValue(),\n              oe = [];\n          te.type !== \"mappingValue\" && S(te) && oe.push([u(r, R.map(ee, \"leadingComments\")), r]);\n          let W = te.tag,\n              X = te.anchor;\n          W && oe.push(ee(\"tag\")), W && X && oe.push(\" \"), X && oe.push(ee(\"anchor\"));\n          let ue = \"\";\n          D(te, [\"mapping\", \"sequence\", \"comment\", \"directive\", \"mappingItem\", \"sequenceItem\"]) && !C(R) && (ue = E(R, Q.originalText)), (W || X) && (D(te, [\"sequence\", \"mapping\"]) && !B(te) ? oe.push(r) : oe.push(\" \")), B(te) && oe.push([te.middleComments.length === 1 ? \"\" : r, u(r, R.map(ee, \"middleComments\")), r]);\n          let De = R.getParentNode();\n          return P(R) ? oe.push(m(Q.originalText.slice(te.position.start.offset, te.position.end.offset).trimEnd(), c)) : oe.push(a(j(te, De, R, Q, ee))), I(te) && !D(te, [\"document\", \"documentHead\"]) && oe.push(o([te.type === \"mappingValue\" && !te.content ? \"\" : \" \", De.type === \"mappingKey\" && R.getParentNode(2).type === \"mapping\" && g(te) ? \"\" : t, ee(\"trailingComment\")])), y(te) && oe.push(l(te.type === \"sequenceItem\" ? 2 : 0, [r, u(r, R.map(ie => [d(Q.originalText, ie.getValue(), h) ? r : \"\", ee()], \"endComments\"))])), oe.push(ue), oe;\n        }\n\n        function j(R, Q, ee, te, oe) {\n          switch (R.type) {\n            case \"root\":\n              {\n                let W = R.children,\n                    X = [];\n                ee.each((De, ie) => {\n                  let G = W[ie],\n                      z = W[ie + 1];\n                  ie !== 0 && X.push(r), X.push(oe()), V(G, z) ? (X.push(r, \"...\"), I(G) && X.push(\" \", oe(\"trailingComment\"))) : z && !I(z.head) && X.push(r, \"---\");\n                }, \"children\");\n                let ue = A(R);\n                return (!D(ue, [\"blockLiteral\", \"blockFolded\"]) || ue.chomping !== \"keep\") && X.push(r), X;\n              }\n\n            case \"document\":\n              {\n                let W = Q.children[ee.getName() + 1],\n                    X = [];\n                return q(R, W, Q, te) === \"head\" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X.push(oe(\"head\")), I(R.head) ? X.push([\"---\", \" \", oe([\"head\", \"trailingComment\"])]) : X.push(\"---\")), $(R) && X.push(oe(\"body\")), u(r, X);\n              }\n\n            case \"documentHead\":\n              return u(r, [...ee.map(oe, \"children\"), ...ee.map(oe, \"endComments\")]);\n\n            case \"documentBody\":\n              {\n                let W = R.children,\n                    X = R.endComments,\n                    ue = \"\";\n\n                if (W.length > 0 && X.length > 0) {\n                  let De = A(R);\n                  D(De, [\"blockFolded\", \"blockLiteral\"]) ? De.chomping !== \"keep\" && (ue = [r, r]) : ue = r;\n                }\n\n                return [u(r, ee.map(oe, \"children\")), ue, u(r, ee.map(oe, \"endComments\"))];\n              }\n\n            case \"directive\":\n              return [\"%\", u(\" \", [R.name, ...R.parameters])];\n\n            case \"comment\":\n              return [\"#\", R.value];\n\n            case \"alias\":\n              return [\"*\", R.value];\n\n            case \"tag\":\n              return te.originalText.slice(R.position.start.offset, R.position.end.offset);\n\n            case \"anchor\":\n              return [\"&\", R.value];\n\n            case \"plain\":\n              return Y(R.type, te.originalText.slice(R.position.start.offset, R.position.end.offset), te);\n\n            case \"quoteDouble\":\n            case \"quoteSingle\":\n              {\n                let W = \"'\",\n                    X = '\"',\n                    ue = te.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);\n\n                if (R.type === \"quoteSingle\" && ue.includes(\"\\\\\") || R.type === \"quoteDouble\" && /\\\\[^\"]/.test(ue)) {\n                  let ie = R.type === \"quoteDouble\" ? X : W;\n                  return [ie, Y(R.type, ue, te), ie];\n                }\n\n                if (ue.includes(X)) return [W, Y(R.type, R.type === \"quoteDouble\" ? ue.replace(/\\\\\"/g, X).replace(/'/g, W.repeat(2)) : ue, te), W];\n                if (ue.includes(W)) return [X, Y(R.type, R.type === \"quoteSingle\" ? ue.replace(/''/g, W) : ue, te), X];\n                let De = te.singleQuote ? W : X;\n                return [De, Y(R.type, ue, te), De];\n              }\n\n            case \"blockFolded\":\n            case \"blockLiteral\":\n              return L(ee, oe, te);\n\n            case \"mapping\":\n            case \"sequence\":\n              return u(r, ee.map(oe, \"children\"));\n\n            case \"sequenceItem\":\n              return [\"- \", l(2, R.content ? oe(\"content\") : \"\")];\n\n            case \"mappingKey\":\n            case \"mappingValue\":\n              return R.content ? oe(\"content\") : \"\";\n\n            case \"mappingItem\":\n            case \"flowMappingItem\":\n              return b(R, Q, ee, oe, te);\n\n            case \"flowMapping\":\n              return N(ee, oe, te);\n\n            case \"flowSequence\":\n              return x(ee, oe, te);\n\n            case \"flowSequenceItem\":\n              return oe(\"content\");\n\n            default:\n              throw new Error(\"Unexpected node type \".concat(R.type));\n          }\n        }\n\n        function $(R) {\n          return R.body.children.length > 0 || k(R.body);\n        }\n\n        function V(R, Q) {\n          return I(R) || Q && (Q.head.children.length > 0 || k(Q.head));\n        }\n\n        function q(R, Q, ee, te) {\n          return ee.children[0] === R && /---(?:\\s|$)/.test(te.originalText.slice(h(R), h(R) + 4)) || R.head.children.length > 0 || k(R.head) || I(R.head) ? \"head\" : V(R, Q) ? !1 : Q ? \"root\" : !1;\n        }\n\n        function Y(R, Q, ee) {\n          let te = T(R, Q, ee);\n          return u(r, te.map(oe => s(v(u(i, oe)))));\n        }\n\n        function H(R, Q) {\n          if (D(Q)) switch (delete Q.position, Q.type) {\n            case \"comment\":\n              if (f(Q.value)) return null;\n              break;\n\n            case \"quoteDouble\":\n            case \"quoteSingle\":\n              Q.type = \"quote\";\n              break;\n          }\n        }\n\n        n.exports = {\n          preprocess: F,\n          embed: w,\n          print: M,\n          massageAstNode: H,\n          insertPragma: p\n        };\n      }\n\n    }),\n        Fg = Z({\n      \"src/language-yaml/options.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Ot();\n        n.exports = {\n          bracketSpacing: t.bracketSpacing,\n          singleQuote: t.singleQuote,\n          proseWrap: t.proseWrap\n        };\n      }\n\n    }),\n        Ag = Z({\n      \"src/language-yaml/parsers.js\"() {\n        re();\n      }\n\n    }),\n        Sg = Z({\n      \"node_modules/linguist-languages/data/YAML.json\"(e, n) {\n        n.exports = {\n          name: \"YAML\",\n          type: \"data\",\n          color: \"#cb171e\",\n          tmScope: \"source.yaml\",\n          aliases: [\"yml\"],\n          extensions: [\".yml\", \".mir\", \".reek\", \".rviz\", \".sublime-syntax\", \".syntax\", \".yaml\", \".yaml-tmlanguage\", \".yaml.sed\", \".yml.mysql\"],\n          filenames: [\".clang-format\", \".clang-tidy\", \".gemrc\", \"CITATION.cff\", \"glide.lock\", \"yarn.lock\"],\n          aceMode: \"yaml\",\n          codemirrorMode: \"yaml\",\n          codemirrorMimeType: \"text/x-yaml\",\n          languageId: 407\n        };\n      }\n\n    }),\n        xg = Z({\n      \"src/language-yaml/index.js\"(e, n) {\n        \"use strict\";\n\n        re();\n        var t = Bt(),\n            s = Eg(),\n            a = Fg(),\n            r = Ag(),\n            u = [t(Sg(), i => ({\n          since: \"1.14.0\",\n          parsers: [\"yaml\"],\n          vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],\n          filenames: [...i.filenames.filter(o => o !== \"yarn.lock\"), \".prettierrc\", \".stylelintrc\"]\n        }))];\n        n.exports = {\n          languages: u,\n          printers: {\n            yaml: s\n          },\n          options: a,\n          parsers: r\n        };\n      }\n\n    }),\n        bg = Z({\n      \"src/languages.js\"(e, n) {\n        \"use strict\";\n\n        re(), n.exports = [id(), Sd(), Pd(), Md(), Ud(), Dg(), xg()];\n      }\n\n    });\n\n    re();\n\n    var _ya = ya(),\n        Tg = _ya.version,\n        kt = Sm(),\n        _Mn3 = Mn(),\n        Bg = _Mn3.getSupportInfo,\n        Ng = xm(),\n        wg = bg(),\n        _g = Oe();\n\n    function bt(e) {\n      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n      return function () {\n        for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];\n\n        let r = s[n] || {},\n            u = r.plugins || [];\n        return s[n] = Object.assign(Object.assign({}, r), {}, {\n          plugins: [...wg, ...(Array.isArray(u) ? u : Object.values(u))]\n        }), e(...s);\n      };\n    }\n\n    var bn = bt(kt.formatWithCursor);\n    Co.exports = {\n      formatWithCursor: bn,\n\n      format(e, n) {\n        return bn(e, n).formatted;\n      },\n\n      check(e, n) {\n        let _bn = bn(e, n),\n            t = _bn.formatted;\n\n        return t === e;\n      },\n\n      doc: _g,\n      getSupportInfo: bt(Bg, 0),\n      version: Tg,\n      util: Ng,\n      __debug: {\n        parse: bt(kt.parse),\n        formatAST: bt(kt.formatAST),\n        formatDoc: bt(kt.formatDoc),\n        printToDoc: bt(kt.printToDoc),\n        printDocToString: bt(kt.printDocToString)\n      }\n    };\n  });\n  return Pg();\n});","map":null,"metadata":{},"sourceType":"module"}